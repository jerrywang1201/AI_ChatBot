import os
import re
import json
import logging
import requests
import tempfile
from pydantic import BaseModel
from typing import Any, Self, ClassVar, Optional

from interlinked.core.tool import Tool
from interlinked.core.config import Config
from interlinked.core.utilities import Utilities
from interlinked.core.dynamic.functions import Function
from interlinked.core.clients.baseaiclient import BaseAIClient
from interlinked.core.dynamic.functions import FunctionSignature

logger = logging.getLogger(__name__)


class MCP(BaseModel):
	"""
	Used in `Applet`
	"""

	command: Optional[str]
	args: Optional[list[str]] = None
	env: Optional[dict[str, str|int]] = None


class Applet(BaseModel):
	"""
	This class represents a collection of functions/Tools bundled into an Applet.

	To create an Applet, navigate to [interlinked.apple.com/applets](https://interlinked.apple.com/applets).

	To use an Applet:
	```
	from interlinked import AI

	observation = AI.ask(prompt='Summarize rdar://123456', tools=['com.apple.radar'])
	print(observation.response)
	```
	"""

	bundle_id: str
	name: Optional[str] = None

	# the URL, if this Applet is from GitHub
	external_id: Optional[str] = None

	# a list of files this Applet contains
	# e.g. `[{'type': 'backend', 'tools': […]}, …]`
	files: Optional[list[dict]] = None

	# if this Applet is also an MCP Server
	mcp: Optional[MCP] = None

	kwargs: Optional[dict[str, list[str]]] = None

	# the local path where the files of this Applet are stored on you device
	# (e.g. `/tmp/…/com.apple.radar.interlinked`)
	path: Optional[str] = None

	# [Internal]
	# the ID of the Asset which contains the files for this Applet
	asset_external_id: Optional[str] = None

	# [Internal]
	base_url: str = None
	api_key: str | None = None
	oidc_token: str | None = None
	BASE_URL: ClassVar[str] = 'https://interlinked.apple.com/api/v1'

	__tools__: list[Tool] = None

	@classmethod
	def get(cls, bundle_id: str, api_key: str = None, base_url: str = None) -> Self:
		"""
		Returns an Applet from interlinked.apple.com/applets, which contains

		@param bundle_id(str): A bundle ID from interlinked.apple.com/applets (e.g. `com.apple.radar`)
		@param api_key(str): Your API Key (e.g. `in-…`)
		@return (Applet): An Applet
		"""

		base_url = base_url or cls.BASE_URL

		if '/api' not in base_url:
			base_url = f'{base_url}/api/v1'

		# get the user's OIDC token
		oidc_token: str = None

		if Config.current.is_development and not api_key:
			oidc_token = Utilities.get_apple_connect_token(app_id=Config.current.IDMS_APP_OIDC_CLIENT_ID, type='oauth')

		cookies: dict[str, Any] = {}
		headers: dict[str, str] = {'accept': 'application/json'}

		if api_key:
			headers['Authorization'] = f'Bearer {api_key}'

		elif oidc_token:
			cookies['acoidc'] = oidc_token

		response = requests.get(f'{base_url}/applets/{bundle_id}', headers=headers, cookies=cookies, allow_redirects=False)

		if not response.ok or response.status_code != 200:

			if response.status_code == 404:
				raise Exception(f'There is no "{bundle_id}" Applet found. Find all Applets in interlinked.apple.com/applets')

			raise Exception(f'Could not get Applet ({bundle_id=}, {response.text=})')

		response_json: dict[str, Any] = response.json()

		return Applet(name=response_json['name'], bundle_id=response_json['bundle_id'],
					  external_id=response_json['external_id'], mcp=response_json['mcp'],
					  files=response_json['files'], kwargs=response_json['kwargs'], base_url=base_url, api_key=api_key,
					  oidc_token=oidc_token, path=os.path.join(tempfile.gettempdir(), f'{response_json["bundle_id"]}.interlinked'),
					  asset_external_id=response_json.get('asset_external_id'))

	def get_tools(self, function_kwargs: dict[str, dict[str, Any]] = None,
				  client: BaseAIClient = None) -> list[Tool]:
		"""
		Returns a list of `Tool`s this Applet offers
		"""

		import os
		import tempfile

		tools: list[Tool] = []

		# fetch the package if we haven't before or if the folder
		# is empty (with only `__pycache__` in it)
		asset_exists: bool = os.path.exists(self.path) and not all(item == '__pycache__' for item in os.listdir(self.path))

		# check if the asset is old
		if asset_exists:

			with open(f'{self.path}/applet.json', 'r') as file:

				applet_definition: dict[str, Any] = json.loads(file.read())
				old_asset_external_id: str = applet_definition.get('asset_external_id')

				if not old_asset_external_id or old_asset_external_id != self.asset_external_id:

					logger.info(f'⬇️ Installing a new version of {self.name}…')
					asset_exists = False

		if not asset_exists:

			cookies: dict[str, Any] = {}
			headers: dict[str, str] = {'accept': 'application/json'}

			if self.api_key:
				headers['Authorization'] = f'Bearer {self.api_key}'

			elif self.oidc_token:
				cookies['acoidc'] = self.oidc_token

			response = requests.get(f'{self.base_url or self.BASE_URL}/applets/{self.bundle_id}/package',
									headers=headers, cookies=cookies, stream=True, allow_redirects=False)

			if not response.ok or response.status_code != 200:
				raise Exception(f'could not get Applet tools ({self.bundle_id=}, {response.text=})')

			# read the contents of the file
			Utilities.decompress(content=response.content, directory_name=f'{self.bundle_id}.interlinked')

			# add the Applet Asset version
			applet_definition: dict[str, Any] = None

			with open(f'{self.path}/applet.json', 'r') as file:
				applet_definition = json.loads(file.read())

			applet_definition['asset_external_id'] = self.asset_external_id

			with open(f'{self.path}/applet.json', 'w') as file:
				file.write(json.dumps(applet_definition))

		skipped_function_names: set[str] = set()
		files: list[dict] = Applet.get_files_for_path(path=self.path)

		for file in files:

			path: str = file['path']

			if file.get('type') != 'backend':
				continue

			for function_definition in file['tools']:

				function_name: str = function_definition['name']

				# skip functions with errors
				if error := function_definition.get('error'):

					logger.warning(f'skipping function with error ({function_name=}, {error=})')
					continue

				tool = Tool.get_tool_from_file(path=path, function_name=function_name)

				# prefix with the Applet name
				# e.g. `Slack.send_message`
				if client and client.__class__.__name__ == 'GoogleAIClient':
					tool.alternative_name = f'{self.name.replace(" ", "")}.{tool.name}'

				# not all clients support `.` in the name
				else:
					tool.alternative_name = f'{self.name.replace(" ", "")}_{tool.name}'

				# add function kwargs
				# e.g. `{'create': {'password': …}, 'lookup': {'api_key': …}}`
				expected_tool_kwarg_names: list[str] = self.kwargs.get(tool.name)

				if function_kwargs:

					# option 1
					# e.g. `{'get_document': {'token': '…'}`
					if _function_kwargs := function_kwargs.get(tool.name):
						tool.function_kwargs = _function_kwargs

					# option 2: support cases where the user passes
					# kwargs directly rather than function names + kwargs
					# e.g. `{'password': …, 'api_key': …}`
					elif self.kwargs and expected_tool_kwarg_names:

						if not tool.function_kwargs:
							tool.function_kwargs = {}

						for expected_tool_kwarg_name in expected_tool_kwarg_names:

							if kwarg_value := function_kwargs.get(expected_tool_kwarg_name):
								tool.function_kwargs[expected_tool_kwarg_name] = kwarg_value

				# skip the tool if the user has not provided all of the required kwargs
				if expected_tool_kwarg_names:

					# if there's a kwarg in `applet.json` and the user hasn't provided it
					# unless that kwarg is optional (e.g. `tests/test_applet/code.py` › `search` function)
					required_kwarg_names = [argument['name'] for argument in tool.function.signature.arguments
											if not argument.get('optional', False) and argument['name'] in expected_tool_kwarg_names]

					missing_required_kwargs = [name for name in required_kwarg_names
											   if not tool.function_kwargs or name not in tool.function_kwargs]

					if missing_required_kwargs:

						skipped_function_names.add(tool.name)
						continue

				tools.append(tool)

		if skipped_function_names:
			logger.warning(f'⚠️ Skipping {", ".join(skipped_function_names)} functions in {self.name}. To resolve, add `applet.get_tools(function_kwargs={{…}})` to your code.')

		return tools

	def create_mcp_client(self, transport: str = 'stdio', **kwargs):
		"""
		Creates an MCPClient configured for this applet's MCP server

		@param transport: Transport type ('stdio' or 'sse')
		@param kwargs: Additional configuration options for the MCP server
		@return: Configured MCPClient instance

		Example:
		```python
		applet = Applet.get('com.apple.quip')

		# Async usage
		async with applet.create_mcp_client() as client:
			tools = await client.get_tools()
			result = await client.run_tool('get_document', {'id': '123'})

		# Sync usage
		with applet.create_mcp_client() as client:
			tools = client.get_tools_sync()
			result = client.run_tool_sync('get_document', {'id': '123'})
		```
		"""

		from interlinked.core.clients.mcpclient import MCPClient

		return MCPClient.from_applet(self, transport=transport, **kwargs)

	""" Internal """

	@classmethod
	def publish(cls, path: str, api_key: str = None, base_url: str = None) -> 'Applet':
		"""
		[Internal]
		Publishes an Applet to interlinked.apple.com/applets
		"""

		from pathlib import Path

		# get the user's API Key
		api_key = api_key or cls.get_api_key(base_url=base_url)

		# ensure the folder exists
		if not os.path.exists(path):
			raise Exception(f'{path} does not exist')

		if path.rsplit('/', 1)[-1] == '.':
			path = Path.cwd()

		# if the user passes a file accidentally, get the directory of it
		if os.path.basename(path) == 'applet.json':
			path = path.rsplit('/', 1)[0]

		# ensure the path is a directory
		if not os.path.isdir(path):
			raise Exception(f'{path} should be a directory containing your Applet')

		# ensure `applet.json` file exists
		if not os.path.exists(f'{path}/applet.json'):
			raise MissingDefinition

		# ensure `applet.json` file is a correct JSON
		applet_definition: dict[str, Any] = None
		applet_definition_2: dict[str, Any] = None

		with open(f'{path}/applet.json', 'r') as file:

			applet_definition_raw: str = file.read()

			try:
				applet_definition_2 = Tool.get_dictionary_from_string(string=applet_definition_raw)

			except Exception as exception:
				raise Exception('The applet.json file is not a correctly-formatted JSON')

			try:
				applet_definition = json.loads(applet_definition_raw)

			except Exception as exception:
				pass

		# auto-fix the format
		if not applet_definition and applet_definition_2:

			logger.info('Your applet.json is not a correctly-formatted JSON. Interlinked will automatically fix the format.')

			with open(f'{path}/applet.json', 'w') as file:
				file.write(json.dumps(applet_definition_2, indent='\t'))

		# we could not auto-fix the format
		elif not applet_definition:
			raise Exception('The applet.json file is not a correctly-formatted JSON')

		directory_name: str = os.path.basename(path)
		data: bytes = Utilities.compress(path=path, root_directory_name=directory_name, skipped_file_names=['uv.lock', 'package-lock.json', 'tests', '__pycache__', 'tests', '.venv', '.git', '.github', '.idea', '.vs', '.vscode'])
		files: dict[str, tuple] = {'file': (directory_name, data, 'application/zip')}
		headers: dict[str, str] = {'accept': 'application/json', 'Authorization': f'Bearer {api_key}'}

		response = requests.post(f'{base_url or cls.BASE_URL}/applets/package', files=files, headers=headers)
		response_json: dict[str, Any] = response.json()

		if not response.ok or response.status_code != 200:
			raise Exception(f'Could not upload Applet. {response_json.get("message", response_json.get("detail", response.text))}')

		return Applet.get(bundle_id=response_json['bundle_id'], base_url=base_url)

	@classmethod
	def get_files_for_path(cls, path: str, include_backend: bool = True,
						   included_file_paths: str = None, is_mcp: bool = False) -> list[dict]:
		"""
		[Internal]
		Returns a list of files (dicts) for a given path
		The list only includes supported formats (`.py`)

		e.g. `[{'path': '….py', 'type': 'backend', 'tools': […], …}]`

		@param path(str): the path that contains supported files
		@param include_backend(bool): Whether to include backend files (e.g. Python)
		"""

		import fnmatch
		from pathlib import Path

		path = Path(path).resolve()

		files: list[dict] = []
		file_paths: list[str] = []

		if path.suffix in {'.py'}:
			file_paths = [path]

		else:

			for pattern in ['*.py']:
				file_paths.extend([str(file_path) for file_path in path.rglob(pattern) if not file_path.name.startswith('.')])

		# remove any file path not in `included_file_paths`
		if included_file_paths:

			for file_path in file_paths[:]:

				# avoid skipping our own Applet directory
				if os.path.isdir(file_path):
					continue

				if not any(file_path.endswith(included_file_path) for included_file_path in included_file_paths):
					file_paths.remove(file_path)

		if include_backend:

			for file_path in file_paths:

				if not file_path.endswith('.py'):
					continue

				# always exclude any test files
				if 'test' in os.path.basename(file_path):
					continue

				file: dict[str, Any] = {

					'type': 'backend',
					'path': file_path,
					'tools': [], 'apis': [],
				}

				for function in Utilities.get_functions_in_file(path=file_path):

					function_name: str = function['name']

					# skip functions prefixed with `api_`
					if function_name.startswith('api_'):

						file['apis'].append(function)
						continue

					# skip internal functions
					# TODO: class names should not be in the function name
					elif '._' in function_name or function_name.startswith('_'):
						continue

					# skip main function, since it is typically used in CLIs
					elif function_name == 'main':
						continue

					function_description: str = function['description']
					function_signature: FunctionSignature = FunctionSignature.get_signature_for_code(code=function['code'], require_types=False)
					function: Function = Function(signature=function_signature, code=function['code'], is_dynamic=False, decorators=[])
					tool: Tool = Tool(function=function)

					# tool: Tool = Tool()
					# errors
					error: str = None

					if not function_description or len(function_description) <= 5:
						error = 'This function is missing docstrings, which is the description underneath the function.'  \
								'AI uses docstrings to understand what your function does and how to call it.'

					else:

						try:

							from interlinked.core.ai import AI

							# pass any AI client. We only need `to_dict` to see if there are any exceptions
							tool.to_dict(client=AI.client)

						except Exception as exception:

							# Ignore error if applet is MCP
							if not is_mcp:
								error = str(exception)

					should_skip_tool: bool = False

					# append the description of the arguments
					for argument in function.signature.arguments:

						# if any of the arguments is `self`, that is not supported
						# since it requires initialization of the class
						if argument['name'] == 'self':

							should_skip_tool = True
							break

						description: str = function.signature.get_description_for_argument(name=argument['name'])
						argument['description'] = description

						file_extensions: list[str] = []

						if description:

							# check for supported file extensions
							# in the description of each argument
							# e.g. `@param code(str): the file path to the code` or
							# 	   `@param code(str): supports .c, .swift`
							file_extensions = re.findall(r'\W\.([a-z]{1}[a-z0-9]{0,5})\b', description, flags=re.MULTILINE)

							if not file_extensions and 'file path' in description or 'path of' in description:
								file_extensions = ['*']

						argument['file_extensions'] = file_extensions

					if should_skip_tool:

						logger.warning(f'skipping function that has `self` in the arguments ({function_name=})')
						continue

					file['tools'].append({'name': function_name, 'description': function.signature.description,
										  'arguments': function.signature.arguments, 'code': function.code,
										  'error': error})

				files.append(file)

		return files

	@classmethod
	def get_api_key(cls, base_url: str) -> str:
		"""
		[Internal]
		Uses AppleConnect to return the user's active API Key

		@return (str): The user's API Key (e.g. `in-…`)
		"""

		base_url = base_url or cls.BASE_URL

		if '/api' not in base_url:
			base_url = f'{base_url}/api/v1'

		daw_token: str = Utilities.get_apple_connect_token(app_id=Config.current.IDMS_APP_ID)

		cookies: dict[str, Any] = {'acack': daw_token}
		headers: dict[str, Any] = {'Content-Type': 'application/json'}

		response = requests.post(f'{base_url}/keys/appleconnect', headers=headers, cookies=cookies, json={}, timeout=10)

		if not response.ok:
			raise Exception(f'Could not get your API Key ({response.text=})')

		response_json: dict[str, Any] = response.json()
		value: str = response_json.get('value')

		if not value:
			raise Exception(f'You do not have an API Key created yet. Create one in interlinked.apple.com/playground › API Keys, then run again.')

		return value


class MissingDefinition(Exception):
	"""
	[Internal]
	Raised by Interlinked if the Applet directory is missing
	an `applet.json` file
	"""