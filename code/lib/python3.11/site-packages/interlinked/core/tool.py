import re
import json
import logging
from textwrap import dedent
from datetime import datetime
from typing import Any, Callable
from dataclasses import dataclass

from interlinked.core.utilities import Utilities
from interlinked.core.dynamic.functions import Function

logger = logging.getLogger(__name__)


class Tool:
	"""
	Give AI access to your Python functions, allowing it to autonomously perform
	actions on Radars, spin up a VM via DeviceCompute, schedule meetings, and more.

	In most cases, you do _not_ need to use this class directly. Instead, pass your Python function
	directly to `AI.ask(prompt='What is rdar://…', tools=[lookup_radar])`.
	**[Full Example ›](github.pie.apple.com/Interlinked/interlinked/blob/main/examples/function_calling/lookup_radar.py)**

	One benefit of this class instead, is being able to pass secrets to the function without AI seeing them.
	For example, if you have a function that requires the user's password as an argument. To avoid having AI ask
	for it or see the password, wrap your function with `Tool`:
	```
	from interlinked import AI, Tool
	observation = AI.ask(prompt='Build project123 in bats', tools=[Tool(function=build_bats, function_kwargs={'password': …})])
	```
	"""

	name: str = None
	description: str = None
	raw_description: str = ''

	# indicates whether this Function is server-side or not
	# e.g. `google_search_retrieval`
	has_code: bool = True

	function: Callable | Function = None
	function_kwargs: dict = None

	# [internal]
	# prefix the tool name with app name, such as,
	# `lookup` › `Radar_lookup`
	alternative_name: str = None

	# [internal]
	# allows arguments to not have a description
	require_argument_description: bool = True

	def __init__(self, function: Callable | Function | str, function_kwargs: dict[str, Any] = None):
		"""
		Initializes this tool to pass to `AI.ask(…)`

		@param function(Callable | Function | str): a Python function or function name
		@param function_kwargs(dict): arguments that will always be passed by the code to the _tool_ (not by AI)
		"""

		# if this is a string, it means the function is defined server-side by the AI client
		# e.g. `google_search`
		if isinstance(function, str):

			self.name = function
			self.has_code = False
			self.function_kwargs = function_kwargs
			return

		# cast the function to type `Function` to get the arguments
		if not isinstance(function, Function):
			function = Function.get_function_for_callable(callable_=function, dynamic_only=False)

		self.has_code = True
		self.function = function
		self.name = function.__name__
		self.function_kwargs = function_kwargs

		# includes both description of the function and @param(s)
		self.raw_description = dedent(function.__doc__).strip()

		# just the description
		self.description = self.raw_description.split('@param')[0].strip().replace('\n', ' ')

		# tag the function, so we can easily detect it in `@AI.track`
		# we can't set it if the function is part of a class, though (`AttributeError: 'method' object has no attribute '__is_tool__'`)
		if self.function.callable_ and not hasattr(self.function.callable_, '__self__'):
			self.function.callable_.__is_tool__ = True

	@classmethod
	def get_tool_from_file(cls, path: str, function_name: str) -> 'Tool':
		"""
		[Internal/Used in CLI]
		Returns a Tool for a given Python file path and a function name

		e.g. `path = '~/my_file.py'`
			 `function_name = 'lookup_radar'` or `function_name = 'Tools.lookup_radar'`

		@param path(str): a Python file path
		@function_name function_name(str): a Python function name
		@return (Tool): a Tool for the function
		"""

		import os
		import importlib.util
		from importlib.machinery import ModuleSpec

		class_name: str = None
		module_name: str = os.path.basename(path).replace('.py', '')

		# e.g. Tools.lookup_radar
		if '.' in function_name:
			class_name, function_name = function_name.split('.')

		# run the Python file
		spec: ModuleSpec = importlib.util.spec_from_file_location(name=module_name, location=path)
		module: Any = importlib.util.module_from_spec(spec=spec)
		spec.loader.exec_module(module=module)

		function: callable = None

		# get the function, then convert it to a `Tool`
		if class_name:

			_cls: Any = getattr(module, class_name, None)

			if not _cls:
				raise Exception(f'"{module_name}" does not have "{class_name}"')

			function = getattr(_cls, function_name, None)

		else:

			function = getattr(module, function_name, None)

			if not function:
				raise Exception(f'"{module_name}" does not have a function "{function_name}"')

		return cls(function=function)

	@classmethod
	def get_tools_for_url(cls, url: str, callback: Callable = None) -> list['Tool']:
		"""
		Creates and returns a list of `Tool`s from a given OpenAPI endpoint. Allows you to give AI access
		to call API endpoints autonomously.

		Pass the output of this function to `AI.ask(…, tools=Tool.get_tools_for_url(…))`

		@param url(str): A JSON OpenAPI endpoint (e.g. `interlinked.apple.com/openapi.json`)
		@param callback(Callable): (optional for non-authenticated endpoints) a callback function that should contain the `requests.…` call
		@return (list): A list of `Tool`s
		"""

		import os, requests
		from urllib.parse import urlparse
		from string import Template as BaseTemplate

		# prefix the URL if it's not already prefixed
		if not url.startswith('http'):

			if 'localhost' in url or '127.0.0.1' in url or '0.0.0.0' in url:
				url = f'http://{url}'
			else:
				url = f'https://{url}'

		data: dict[str, Any] = requests.get(url).json()

		# get the true base URL (e.g. `https://…/openapi.json` -> `https://…`)
		url_parsed: Any = urlparse(url)
		base_url: str = f'{url_parsed.scheme or ("http")}://{url_parsed.netloc.removesuffix("/")}'

		# get the API server URL (if the spec points to a different server from the `url`)
		servers: list[dict[str, Any]] = data.get('servers', [])
		server_url: str = servers[0]['url'] if servers else base_url

		# if the server URL is a relative path (e.g. `/api/v3`)
		# convert to full URL (e.g. `https://…/api/v3`)
		if server_url:
			base_url = f'{base_url}/{server_url.lstrip("/")}' if server_url.startswith('/') else server_url

		return Tool.get_tools_for_data(data=data, callback=callback, base_url=base_url)

	@classmethod
	def get_tools_for_mcp(cls, mcp: dict) -> list['Tool']:
		"""
		Creates and returns a list of `Tool`s from a given MCP definition.

		Pass the output of this function to `AI.ask(…, tools=Tool.get_tools_for_mcp(…))`

		@param mcp(dict): An MCP definition or path to a file
		@return (list): A list of `Tool`s
		"""

		logger.warning('⚠️ Function Calling with MCP is currently in beta. results may be unexpected')

		tools = []

		# server_name is, e.g., `weather`
		for server_name, server_definition in mcp.items():
			tools.extend(cls._list_tools_for_mcp_server(server_name, server_definition))
		return tools

	@classmethod
	def _list_tools_for_mcp_server(cls, server_name: str, server_definition: dict) -> list['Tool']:

		import os
		import requests
		from interlinked.core.clients.mcpclient import MCPClient

		server_url = server_definition.get('url')

		if server_url:

			try:

				base_url = server_url.replace('/sse', '')
				response = requests.get(f'{base_url}/health', timeout=5)

				response.raise_for_status()

				data = response.json()
				response_text: str = str(data).lower()

				if 'interlinked' in response_text:
					return cls._list_tools_for_interlinked_server(server_name=server_name, server_definition=server_definition)

			except Exception:
				pass

		# Replace $HOME in args to users home
		home_path: str = os.path.expanduser('~')

		if 'args' in server_definition:

			modified_argument_names: list[str] = []

			for argument_name in server_definition.get('args'):

				if '$HOME' in argument_name:
					argument_name = argument_name.replace('$HOME', home_path)

				elif argument_name.startswith('~'):
					argument_name = os.path.expanduser(argument_name)

				modified_argument_names.append(argument_name)

			server_definition['args'] = modified_argument_names

		# connect to the server
		env_vars = server_definition.get('env') or server_definition.get('envs')
		mcp_client: MCPClient = MCPClient(command=server_definition.get('command'), arguments=server_definition.get('args'),
										  environment_variables=env_vars, url=server_definition.get('url'),
										  auth=server_definition.get('auth'))
		mcp_client.connect_sync()

		def _internal_tool_callback(mcp_tool: 'MCPTool', **kwargs) -> Any:

			tool_result: CallToolResult = mcp_client.run_tool_sync(name=mcp_tool.name, arguments=kwargs)

			if tool_result.isError:

				if (contents := tool_result.content) and len(contents) > 0:

					content: Any = contents[0]

					if content.type == 'text' and 'Field required' in content.text:
						raise MissingArguments()

					else:
						raise Exception(content.text)

				raise Exception(tool_result.content)

			return tool_result.content

		tools: list[Tool] = []

		for mcp_tool in mcp_client.get_tools_sync():

			properties: dict[str, Any] = mcp_tool.inputSchema.get('properties')
			required_property_names: list[str] = mcp_tool.inputSchema.get('required') or []

			arguments = cls._modify_mcp_properties(properties=properties, required_property_names=required_property_names, tool_name=mcp_tool.name)

			tool = cls._create_mcp_tool(server_name=server_name, tool_name=mcp_tool.name, tool_description=mcp_tool.description, arguments=arguments,
										callback=_internal_tool_callback, function_kwargs={'mcp_tool': mcp_tool})

			tools.append(tool)

		return tools

	@classmethod
	def _list_tools_for_interlinked_server(cls, server_name: str, server_definition: dict) -> list['Tool']:
		"""
		Handle Interlinked SSE server using direct HTTP calls to /mcp endpoint
		"""

		import requests

		base_url = server_definition['url'].replace('/sse', '')

		def _make_mcp_request(method: str, params: dict = None) -> dict:
			"""Make MCP request to Interlinked server"""

			request_data = {
				'jsonrpc': '2.0',
				'id': 'mcp_request',
				'method': method,
				'params': params or {}
			}
			response = requests.post(f'{base_url}/mcp', json=request_data)

			return response.json()


		try:

			response = _make_mcp_request('tools/list')

			if 'result' not in response or 'tools' not in response['result']:
				return []

			mcp_tools = response['result']['tools']

		except Exception as exception:
			logger.error(f'Failed to get tools from Interlinked server {server_name}: {exception}')
			return []

		def _internal_tool_callback(mcp_tool_name: str, **kwargs) -> Any:
			"""Execute tool on Interlinked server"""

			try:

				response = _make_mcp_request('tools/call', {'name': mcp_tool_name, 'arguments': kwargs})

				if 'result' in response:

					content = response['result'].get('content', [])

					if content and len(content) > 0:
						return content[0].get('text', str(content))

					return str(response['result'])

				elif 'error' in response:
					raise Exception(response['error'].get('message', str(response['error'])))

				return str(response)

			except Exception as exception:
				raise Exception(f'Error calling tool {mcp_tool_name}: {str(exception)}')

		tools: list[Tool] = []

		for mcp_tool in mcp_tools:

			properties: dict[str, Any] = mcp_tool.get('inputSchema', {}).get('properties', {})
			required_property_names: list[str] = mcp_tool.get('inputSchema', {}).get('required', [])

			arguments = cls._modify_mcp_properties(properties, required_property_names, mcp_tool['name'])

			tool = cls._create_mcp_tool(server_name, mcp_tool['name'], mcp_tool['description'], arguments, _internal_tool_callback, {'mcp_tool_name': mcp_tool['name']})
			tools.append(tool)

		return tools

	@classmethod
	def _modify_mcp_properties(cls, properties: dict[str, Any], required_property_names: list[str], tool_name: str) -> list[dict[str, Any]]:
		"""
		Convert MCP tool properties to argument list format

		@param properties: The properties dictionary from the tool's input schema
		@param required_property_names: List of required property names
		@param tool_name: Name of the tool (for logging)
		@return: List of argument dictionaries
		"""

		arguments: list[dict[str, Any]] = []

		for property_name, property_definition in properties.items():

			property_type: str = property_definition.get('type')

			if not property_type:

				logger.warning(f'MCP tool "{tool_name}" property "{property_name}" has no type definition, defaulting to string')
				property_type = 'string'

			if property_type == 'string':
				argument_type = 'str'

			elif property_type == 'number':
				argument_type = 'float'

			elif property_type == 'integer':
				argument_type = 'int'

			elif property_type == 'object':
				argument_type = 'dict'

			elif property_type == 'array':
				argument_type = 'list'

			elif property_type == 'boolean':
				argument_type = 'bool'

			else:

				logger.warning(f'MCP tool "{tool_name}" property "{property_name}" has unknown type "{property_type}", defaulting to string')
				argument_type = 'str'

			arguments.append({
				'name': property_name,
				'type': argument_type,
				'optional': property_name not in required_property_names
			})

		return arguments

	@classmethod
	def _create_mcp_tool(cls, server_name: str, tool_name: str, tool_description: str,
						arguments: list[dict[str, Any]], callback: Callable, function_kwargs: dict[str, Any]) -> 'Tool':
		"""
		Create a Tool object for MCP tools

		@param server_name(str): Name of the MCP server
		@param tool_name(str): Name of the tool
		@param tool_description(str): Description of the tool
		@param arguments(list): List of argument dictionaries
		@param callback(Callable): The callback function to execute the tool
		@param function_kwargs(dict): Additional kwargs to pass to the function
		@return: Tool object
		"""

		from interlinked.core.dynamic.functions import FunctionSignature

		signature: FunctionSignature = FunctionSignature(name=tool_name, description=tool_description, arguments=arguments, has_kwargs=False)

		function: Function = Function(signature=signature, callable_=callback, is_dynamic=False,decorators=[])

		tool: Tool = Tool(function=function, function_kwargs=function_kwargs)
		tool.alternative_name = f'{server_name}_{tool.name}'
		tool.require_argument_description = False

		return tool

	@classmethod
	def get_tools_for_data(cls, data: dict[str], base_url: str, callback: Callable = None, specification: str = 'openapi') -> list['Tool']:
		"""
		Creates and returns a list of `Tool`s from a given an OpenAPI JSON. Allows you to give AI access
		to call API endpoints autonomously.

		You'd likely want to use `Tool.get_tools_for_url` instead, but you can use this if you prefer fetching
		the OpenAPI dictionary manually, then calling this function.

		Pass the output of this function to `AI.ask(…, tools=Tool.get_tools_for_url(…))`

		@param data(dict): an OpenAPI JSON (e.g. the response of `interlinked.apple.com/openapi.json`)
		@param callback(Callable): (optional for non-authenticated endpoints) a callback function that should contain the `requests.…` call
		@param base_url(str): the URL/domain that was used to generate the data
		@param specification(str): (optional) the API specification (only OpenAPI is supported)
		@return (list): a list of `Tool`s
		"""

		# prefix the URL if it's not already prefixed
		if not base_url.startswith('http'):

			if 'localhost' in base_url or '127.0.0.1' in base_url or '0.0.0.0' in base_url:
				base_url = f'http://{base_url}'
			else:
				base_url = f'https://{base_url}'

		tools: list[Tool] = []

		# iterate over every API available (e.g. `path = '/api/…' without the base URL)
		for path, methods in data.get('paths', {}).items():

			for method, method_dict in methods.items():

				# skip any non-HTTP method keys
				# e.g. `parameters` key in `/access/fleet/{fleet}/hardware-model/{hardware-model}`
				# from Device Compute
				if method.upper() not in {'GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'CONNECT', 'OPTIONS', 'TRACE', 'PATCH'}:
					continue

				# if the method is POST/PUT, add a `data` argument and docstring for `data
				has_data: bool = method.upper() in {'POST', 'PUT'}

				# skip PUT/POST calls. We'll likely add support in the future
				if has_data:
					continue

				def _get_python_name_for_key(key: str) -> str:
					"""
					[Internal]
					Converts a parameter or function name to one that can be used in Python

					e.g. `hardware-model` › `hardware_model`
						 `get:Value` › `get_value`
					"""
					return key.lower().replace('-', '_').replace('.', '_').replace(':', '_').  \
							   replace('/', '_').replace('-', '_').replace('__', '_').strip()

				# endpoint name (e.g. `/api/ai/ask` -> `post_ai_ask`)
				name: str = f'{method}_{path.replace(method, "").replace("/api/", "")}'
				name = _get_python_name_for_key(key=name)
				name = re.sub(r'{(.*?)}', r'\1', name)
				name = name.strip().strip('_').strip()

				# truncate if name is too long
				if len(name) > 63:

					name = name[:63]
					logger.warning(f'truncated long endpoint name ({path} -> {name})')

				def _get_schema_for_ref(ref_url: str) -> dict[str, Any]:
					"""
					[Internal]
					Returns the schema dict for a given ref URL (e.g. `#/components/schemas/AskRequest`)
					"""

					refs: list[str] = ref_url.removeprefix('#/').split('/')
					current_ref: str = data.get(refs[0])

					for ref in refs[1:]:

						if not current_ref:
							raise Exception(f'the schema has no definition for {ref_url}')

						current_ref = current_ref.get(ref)

					return current_ref

				# list of URL parameters the API accepts
				parameters: list[dict] = method_dict.get('parameters', [])

				for parameter_index, parameter in enumerate(parameters):

					if parameter_ref_url := parameter.get('$ref'):
						parameters[parameter_index] = _get_schema_for_ref(ref_url=parameter_ref_url)

				parameter_names: list[str] = [parameter['name'] for parameter in parameters]

				# endpoint description
				docstring: str = (method_dict.get('description', '') or method_dict.get('summary', '')).strip()

				# a description is required by `Tool`
				if not docstring:

					logger.warning(f'skipping "{path}" ({method.upper()}) endpoint because it has no `description` or `summary`…')
					continue

				# check the quality of the docstring
				# default docstrings have the same words as path but with method
				# e.g. `/api/configurations` = `Get Api Configurations`
				# we check to see if the docstring is default, and let the user know
				if set(path.replace('/', ' ').lower().split()) == set(docstring.strip().lower().replace(method, '').strip().split()):
					logger.warning(f'"{path}" ({method.upper()}) endpoint has a default description. setting a custom description will likely improve results')

				# split into lines, then append parameters
				docstring = docstring.split('\n')
				should_skip: bool = False

				# sort parameters by required, so when we convert them to a function,
				# the required ones are first, and the optional ones (with a default value) are at the end
				# to match Python's syntax
				parameters = sorted(parameters, key=lambda parameter: parameter.get('required', False), reverse=True)

				for parameter in parameters:

					parameter_name: str = parameter.get('name')
					parameter_schema: str = parameter.get('schema', {})
					parameter_description: str = parameter_schema.get('title')

					if not parameter_description:
						parameter_description = parameter.get('description')

					# parameter descriptions are needed to create the function signature
					if not parameter_description:

						logger.warning(f'skipping "{path}" ({method.upper()}) endpoint because "{parameter_name}" has no title or description set…')
						should_skip = True
						break

					docstring.append(f'@param {_get_python_name_for_key(key=parameter_name)}(any): {parameter_description}')

				if should_skip:
					continue

				if has_data:

					# find the expected format
					content: dict[str, Any] = method_dict.get('requestBody').get('content')

					# we currently only support JSON payload/data
					if 'application/json' not in content:

						logger.warning(f'skipping "{path}" ({method.upper()}) endpoint because it does not support JSON payload')
						continue

					# get the schema for `data` and generate a docstring for it
					# this is used to let AI know the expected JSON format of the endpoint
					# e.g. `@param data(dict): … (this format: {"prompt": …, "client": …})`
					data_docstring: str = None

					if ref_url := content.get('application/json', {}).get('schema', {}).get('$ref'):

						# e.g. the contents of `AskRequest`
						if schema := _get_schema_for_ref(ref_url=ref_url):

							properties: list[dict] = []

							for property_name, property_ in schema.get('properties').items():

								property_ref_url: str = property_.get('$ref')
								property_ref: dict[str, Any] = None

								if property_ref_url:
									property_ref = _get_schema_for_ref(ref_url=property_ref_url)

								properties.append({'name': property_name, 'type': property_.get('type') or property_ref})

							properties_display: str = ', '.join([f'"{property_.get("name")}": …' for property_ in properties])
							properties_display = f'{{{properties_display}}}'
							data_docstring = f'@param data(dict): JSON (schema: {properties_display})'
							docstring.append(data_docstring)

					# without a known format for the endpoint, it'd be hard to generate a docstring for it
					if not data_docstring:

						logger.warning(f'skipping "{path}" ({method.upper()}) endpoint because it has no documentation…')
						continue

				# merge the docstring lines into a format that we can use in the function signature
				docstring = '\n'.join([f'\t{line}' for line in docstring])
				docstring = f'\"\"\"\n{docstring}\n\t\"\"\"' if docstring else ''
				docstring = docstring.replace('\\_', '\\\\_')

				# construct the function arguments by converting parameters into arguments
				# e.g. `{'name': 'filter', 'required': False}` -> `filter: Any = None`
				arguments: list[str] = []

				arguments += [f'{_get_python_name_for_key(key=parameter["name"])}: Any{"" if parameter.get("required") else " = None"}' for parameter in parameters]

				if has_data:

					# should never occur, but in case the API ever has a parameter with the same name, warn the user
					# e.g. `/api/endpoint/{data}` or `/api/endpoint?data=…`
					# `data` in this case is also used as the data to pass in the `PUT/POST` request
					data_parameter: dict[str, Any] = next((parameter for parameter in parameters if parameter['name'] == 'data'), None)

					if data_parameter and data_parameter.get('in') != 'body':

						logger.warning(f'skipping "{path}" ({method.upper()}) endpoint because the endpoint has a `data` parameter, which is used twice')
						continue

					arguments.append(f'data: dict{"" if data_parameter and data_parameter.get("required") else " = None"}')

				# always allow passing arbitrary arguments in case the response includes them,
				# we don't want to error-out
				arguments.append('**kwargs')

				# create a non-real function with a signature that matches the API
				function_code: str = f'def {name.replace("-", "_").replace(".", "_").replace(":", "_")}({", ".join(arguments)}) -> Any:\n\t{docstring}'
				function: Callable = Function.get_function_for_code(code=function_code)

				def _request(base_url: str, path: str, method: str, parameters: list[dict[str, Any]], **kwargs) -> Any:
					"""
					The function gets called directly by AI. Internally, this function
					redirects the call to `callback` (provided by the user)
					"""

					# construct the URL (e.g. `https://interlinked.apple.com/api/…`)
					url: str = f'{base_url}/{path.removeprefix("/")}'

					# arguments to pass to `callback`, which will then be passed to `requests.post(…)`
					params: list[dict[str, str]] = []
					parameter_names: list[str] = [parameter['name'] for parameter in parameters]

					for argument_name, argument_value in list(kwargs.items()):

						# find the matching parameter (from the path definition)
						parameter: dict[str, Any] = next((parameter for parameter in parameters if _get_python_name_for_key(key=parameter['name']) == argument_name), None)

						if not parameter:
							continue

						# append the parameter to either `params` (passed to `requests`), or replace the placeholder in the url
						# with the value (e.g. `…/api/configurations/{id}` -> `…/api/configurations/1`)
						parameter_in: str = parameter.get('in')

						if parameter_in == 'path':

							# this should never occur
							if f'{{{parameter["name"]}}}' not in url:
								raise Exception(f'url ({url}) is unexpectedly missing parameter ({argument_name}). Please file a radar')

							url = url.replace(f'{{{parameter["name"]}}}', str(argument_value))
							del kwargs[argument_name]

						elif parameter_in == 'query':

							params.append({argument_name: argument_value})
							del kwargs[argument_name]

						else:
							raise NotImplementedError(f'Unknown `in` in parameter: {parameter_in}. Please file a radar')

					# we allow callback to not be set if the method is `GET` or `DELETE`
					# for convenience
					if not callback:

						import requests
						method_upper: str = method.upper()

						if method_upper == 'GET':
							return requests.get(url, params=params).text

						elif method_upper == 'DELETE':
							return requests.delete(url, params=params).text

					return callback(url=url, method=method.upper(), params=params, data=kwargs.pop('data', None), **kwargs)

				# override callable to actually call `_request` instead of the non-real function
				function.callable_ = _request
				tools.append(Tool(function=function, function_kwargs={'base_url': base_url, 'path': path, 'method': method, 'parameters': parameters}))

		return tools

	def run(self, arguments: str|dict = None) -> Any:
		"""
		Called by AI, which then calls the function of this tool
		"""

		kwargs: dict[str, Any] = arguments

		if isinstance(kwargs, str):
			kwargs = Tool.get_dictionary_from_string(string=arguments)

		# make sure the call isn't missing any required arguments
		# skip `function_kwargs` which have already been configured and aren't passed in `arguments`
		if missing_arguments := [argument for argument in self.function.signature.arguments if argument['name'] not in kwargs and not argument['optional']  \
			and argument['name'] not in (self.function_kwargs or {})]:
			raise MissingArguments(arguments=missing_arguments)

		# if the tool does not support kwargs (e.g. `def lookup_radar(…, **kwargs):`)
		# remove any argument that is not in the function signature
		if not self.function.signature.has_kwargs and kwargs:

			allowed_argument_names: set[str] = [argument.get('name') for argument in self.function.signature.arguments]
			kwargs = {key: value for key, value in kwargs.items() if key in allowed_argument_names}

		# make sure the types match
		for argument in self.function.signature.arguments:

			argument_name: str = argument['name']
			argument_type: Any = argument['type']

			# skip any argument with no type, since we can't check its type
			if not argument_type:
				continue

			argument_value: Any = arguments.get(argument_name)

			# if the string is meant to be `None`
			if isinstance(argument_value, str) and argument_value.lower() in {'null', 'none', 'nil'}:
				kwargs[argument_name] = None

			# if we expect a boolean, make sure the value is casted to boolean
			# accounts for multiple types (e.g. `arg1: bool` and `arg1: bool|int`)
			# e.g. `"yes"` -> `True`
			elif argument_type.startswith('bool') and not isinstance(argument_value, bool):

				argument_value = str(argument_value)

				if argument_value.lower() in {'y', 'yes', 'true', 'on', '1'}:
					kwargs[argument_name] = True

				elif argument_value.lower() in {'n', 'no', 'false', 'off', '0'}:
					kwargs[argument_name] = False

			# e.g. `"1"` -> `1` or `"1.1"` -> `1.1`
			elif argument_type.startswith(('int', 'float')) and isinstance(argument_value, str):

				if Utilities.get_is_numeric(value=argument_value):

					# if we're expecting a float/double and the number
					if argument_type.startswith('float') and '.' not in argument_value:
						argument_value = f'{argument_value}.0'

					if '.' in argument_value:
						argument_value = float(argument_value)

					else:
						argument_value = int(argument_value)

					kwargs[argument_name] = argument_value

			# e.g. `2025-05-09T22:03:45.123456`
			elif argument_type.startswith('date') and isinstance(argument_value, str):

				try:
					kwargs[argument_name] = datetime.fromisoformat(argument_value)

				except ValueError:

					# try with `dateutil`, if installed
					try:
						from dateutil.parser import parse
						kwargs[argument_name] = parse(argument_value)

					except ModuleNotFoundError:
						logger.info('Run `pip3 install python-dateutil` to get more accurate results.')

					except Exception as exception:
						pass

			# e.g. `'{"id": 123}'`
			elif argument_type.startswith('dict') and isinstance(argument_value, str) and  \
				 argument_value.startswith('{'):

				try:
					kwargs[argument_name] = Tool.get_dictionary_from_string(string=argument_value)

				except Exception as exception:
					logger.warning(f'could not convert {argument_name} from string to dictionary.')

		if self.function_kwargs:
			return self.function(**kwargs, **self.function_kwargs)

		return self.function(**kwargs) if kwargs else self.function()

	def to_dict(self, client: Any) -> dict[str, Any]:
		"""
		[Internal]
		Converts this `Tool` to a dictionary to be used in Requests to AI clients

		@param client(BaseAIClient): An AI client (e.g. `OllamaClient`)
		"""

		arguments: dict[str, Any] = {}

		# e.g. `Quip.get_document` (Applet) or `lookup_radar` (standalone function)
		final_name: str = self.alternative_name or self.name

		from interlinked.core.clients.ajaxclient import AJAXClient
		from interlinked.core.clients.ollamaclient import OllamaClient
		from interlinked.core.clients.openaiclient import OpenAIClient
		from interlinked.core.clients.googleaiclient import GoogleAIClient
		from interlinked.core.clients.anthropicclient import AnthropicClient

		# if this is a test client (in unit tests)
		if 'test' in client.__class__.__name__.lower():
			return {}

		if not self.has_code:

			if isinstance(client, GoogleAIClient):
				return {final_name: self.function_kwargs or {}}

			elif isinstance(client, OpenAIClient):
				return {'type': final_name, **(self.function_kwargs or {})}

			else:
				logger.warning(f'⚠️unsupported AI client for functions with no code: {client}')

			return self.function_kwargs

		required_argument_names: list[str] = []

		for argument in self.function.signature.arguments:

			name: str = argument['name']
			type_: str = argument['type']
			optional: bool = argument['optional']

			if name in {'self', 'cls', 'kwargs'}:
				continue

			# skip arguments in `function_kwargs` since they'll always be passed
			if self.function_kwargs:

				if name in self.function_kwargs:
					continue

			# arguments that don't have a default value (e.g. `to_addresses: list[str]`)
			if not optional:
				required_argument_names.append(name)

			# if there is no type, assume it is a string
			if not type_:
				type_ = 'str'

			# e.g. `to_addresses: list[str]` -> `list` -> `array`
			if '|' in type_:
				type_ = type_.split('|')[0].strip()

			description: str = self.function.signature.get_description_for_argument(name=name)

			# argument descriptions are required
			if not description and self.require_argument_description:

				type_ = type_.replace('\'', '')
				raise ValueError(f'The `{name}` argument in `def {self.name}(…):` is missing a description (e.g. `@param {name}({type_}): lorem ipsum…`)')

			argument_dictionary: dict[str, Any] = {'description': description or ''}

			if type_.startswith('list'):

				argument_dictionary['type'] = 'array'

				if 'str' in type_:
					argument_dictionary['items'] = {'type': 'string'}

				elif 'int' in type_:
					argument_dictionary['items'] = {'type': 'number'}

				elif 'float' in type_ or 'double' in type_:
					argument_dictionary['items'] = {'type': 'number'}

				elif 'bool' in type_:
					argument_dictionary['items'] = {'type': 'boolean'}

				else:
					argument_dictionary['items'] = {'type': 'object'}

				# TODO: add support for more types (currently, only string is implemented)

			elif type_ == 'int':

				if isinstance(client, OpenAIClient):
					argument_dictionary['type'] = 'number'

				else:
					argument_dictionary['type'] = 'integer'

			# some clients support `number`, which covers `float`
			elif type_ == 'float' and isinstance(client, (OpenAIClient, AnthropicClient)):
				argument_dictionary['type'] = 'number'

			else:
				argument_dictionary['type'] = 'string'

			arguments[name] = argument_dictionary

		if isinstance(client, GoogleAIClient):

			return_dict: dict[str, Any] = {

				'name': final_name,
				'description': self.description
			}

			if arguments:

				return_dict['parameters'] = {

					'type': 'object',
					'properties': arguments,
					'required': required_argument_names
				}

			return return_dict

		# external anthropic
		# FloodGate anthropic uses OpenAI schema
		elif isinstance(client, AnthropicClient):

			return_dict: dict[str, Any] = {

				'name': final_name,
				'description': self.description
			}

			if arguments:
				return_dict['input_schema'] = {

					'type': 'object',
					'properties': arguments,
					'required': required_argument_names
				}

			else:
				return_dict['input_schema'] = {

					'type': 'object',
					'properties': {}
				}

			return return_dict

		return {

			'function': {

				'name': final_name,
				'description': self.description or '',
				'parameters': {'type': 'object', 'properties': arguments or {},
							   'required': required_argument_names or []},
			},
			'type': 'TOOL_TYPE_FUNCTION' if isinstance(client, AJAXClient) else 'function',
		}

	""" Parsing """

	@classmethod
	def get_dictionary_from_string(cls, string: str, _retry_count: int = 0) -> dict[str, Any]:
		"""
		Converts a string to JSON. Handles a lot of potential format errors from AI

		e.g. `'{"name": "Jane"}'` -> `{'name': 'Jane'}`
			 `name=Jane`          -> `{'name': 'Jane'}`

		@param string(str): The raw string with the potentially invalid JSON
		"""

		if not string:
			return {}

		if isinstance(string, dict):
			return string

		string = string.strip()

		# if the format isn't even JSON, try to convert it into one
		# e.g. `name=Jane` -> `{'name': 'Jane'}`
		if not string.startswith(('[', '{')):

			# find where the JSON starts
			# e.g. `lorem {"name": "jane"}` -> `{"name": "jane"}`
			dictionary_start_index: int = string.find('{')
			list_start_index: int = string.find('[')
			start_index: int = -1

			start_character: str = None

			# pick either dictionary or list start index, whichever is first
			if dictionary_start_index != -1 and (dictionary_start_index < list_start_index or list_start_index == -1):

				start_index = dictionary_start_index
				start_character = '{'

			elif list_start_index != -1:

				start_index = list_start_index
				start_character = '['

			if start_index == -1:

				# no JSON?
				# check if the format is different
				# e.g. `name=Jane,email=jane@apple.com`
				dictionary: dict[str, Any] = {}

				if '=' in string:

					# e.g. `name=Jane,email=jane@apple.com` -> `[('name', 'Jane'), ('email', '…')]`
					key_values: list[tuple[str]] = [tuple(key_value.split('=', 1)) for key_value in string.split(',')]

					# convert to dictionary
					# e.g. `[('name', 'Jane'), ('email', '…')]` -> `{'name': 'Jane', 'email': '…'}`
					for key_value in key_values:

						if len(key_value) == 2:

							value: Any = key_value[1]
							dictionary |= {key_value[0]: value if len(value) > 0 else None}

				if not dictionary:
					raise Exception(f'no JSON in string ({string=})')

				return dictionary

			# handle nested JSON dicts/lists
			level: int = 0
			_string: str = string
			for index in range(start_index, len(string)):

				if string[index] == start_character:
					level += 1

				elif string[index] == ('}' if start_character == '{' else ']'):
					level -= 1

				if level == 0:
					_string = string[start_index:index + 1]

			string = _string

		string = string.strip()

		# ensure that the ending of the string is valid
		if not string.endswith((']', '}')):

			# TODO: traverse to find the correct closing tag instead
			if string.endswith('```'):
				string = string.removesuffix('```')

		# fix any invalid escape sequences (e.g. `\_` -> `\\_`)
		string = re.sub(r'(?<!\\)\\_', '_', string)

		# try parsing the JSON
		try:
			string = json.loads(string, strict=False)

		except json.decoder.JSONDecodeError as error:

			# if the string uses `'`, convert all to `"`
			if _retry_count < 2:

				import ast

				try:

					# safely convert the string to dictionary
					return ast.literal_eval(string)

				except (ValueError, SyntaxError) as error:

					# if the format is a string wrapped with a list
					# e.g. `[jane]` (no `"`)
					if string.startswith('[') and string.endswith(']'):

						# e.g. `[jane]` -> `jane` or `[ 1 ]` -> `1`
						_string: str = string.removeprefix('[').removesuffix(']').strip()

						# only modify if the string is not a dictionary or string
						# e.g. `jane` = handle
						# 	   `function::1` = handle
						# 	   `{"name: "jane"}` = skip
						if _string and ('[' not in _string and '{' not in _string) and (_string_split := _string.split(',')):

							# skip if the first value is actually wrapped with quotes or is a number
							# e.g. `jane` = handle
							#	   `"jane"` = skip
							#	   `1` = skip
							if not _string_split[0].startswith('"') and not Utilities.get_is_numeric(value=_string_split[0]):
								string = re.sub(r'^\[(.*?)\]$', r'["\1"]', string, flags=re.MULTILINE)

					# the logic below is currently a best effort attempt at parsing invalid JSON
					# e.g. `'string': '…'` -> `"string": "…"`
					string = re.sub(r'\':\s?\'', '":"', string, flags=re.MULTILINE)

					# e.g. `'string": …` -> `"string": …`
					string = re.sub(r'({|\[|\,)(\')([A-Z0-9])', r'\1"\3', string, flags=re.IGNORECASE | re.MULTILINE)

					# e.g. `:…'` -> `:…"`
					string = re.sub(r':([A-Z0-9])(\')', r'\1"', string, flags=re.IGNORECASE | re.MULTILINE)

					# e.g. `"string":'…'` -> `"string":"…"`
					string = re.sub(r'":\'', '":"', string, flags=re.MULTILINE)

					# e.g. `"string": `value`` -> `"string": "value"`
					string = re.sub(r'":\W`', '": "', string, flags=re.MULTILINE)
					string = re.sub(r'`}', '"}', string, flags=re.MULTILINE)

					# e.g. `"string": 'value"` -> `"string": "value"`
					string = re.sub(r'": \'', '": "', string, flags=re.MULTILINE)

					# handle lists
					string = re.sub(r'\',\s?\'', '", "', string, flags=re.MULTILINE)
					string = re.sub(r'\']', '"]', string, flags=re.MULTILINE)
					string = re.sub(r'\':\s?\[', '":[', string, flags=re.MULTILINE)
					string = re.sub(r'\',\s?"', '","', string, flags=re.MULTILINE)

					# e.g. `{\\"id\\": 123}` -> `{\"id\": 123}`
					string = re.sub(r'\\\"', '"', string, flags=re.MULTILINE)

					# e.g. `\\{"id": 123\\}` -> `{\"id\": 123}`
					string = re.sub(r'\\(\{|\}|\[|\])', r'\1', string, flags=re.MULTILINE)

					# other
					string = re.sub(r'\"\"', '"', string, flags=re.MULTILINE)
					string = re.sub(r'[\\]+\'', '\'', string, flags=re.MULTILINE)

					# replace `\n` with `\\n`
					string = re.sub(r'\b\n\b', r'\\n', string, flags=re.MULTILINE)

					# if the string starts with `{` but does not end with `}`
					if string.startswith('{') and not string.endswith('}'):

						last_matching_index: int = string.rfind('}')
						string = string[:last_matching_index + 1]

					# check for extra closing `]` or `}`
					# e.g. `{"name": `test`}}`
					if string.count('{') < string.count('}'):
						string = string[:string.rfind('}')]

					# remove the last ']'
					if string.count('[') < string.count(']'):
						string = string[:string.rfind(']')]

					# TODO: if we reach maximum retry count, ask AI to parse the JSON
					return cls.get_dictionary_from_string(string=string, _retry_count=_retry_count + 1)

			if _retry_count < 5:

				# try to fix the format
				# e.g. `"code": item.…` -> `"code": "item.…"`
				matches: list[str] = re.findall(r'(?<=":)[A-Za-z].*(?=, ")', string, re.DOTALL | re.MULTILINE)

				if matches:

					for match in matches:
						string = string.replace(f'{match}', f'"{match}"')

					return cls.get_dictionary_from_string(string=string, _retry_count=_retry_count + 1)

				# attempt to ensure that the parentheses match
				# e.g. `[1, 2, 3, {"name": "apple"}` ->
				if string.count('{') != string.count('}') or string.count('[') != string.count(']'):

					brackets: list[str] = []
					bracket_pairs: list[str] = {'[': ']', '{': '}'}

					for character in string:

						# if it's an opening bracket
						if character in {'[', '{'}:
							brackets.append(character)

						# if it's a closing bracket, remove it from `brackets` if matches the last opening
						elif character in {']', '}'} and brackets:

							if bracket_pairs[brackets[-1]] == character:
								brackets.pop()

					string = f'{string}{"".join([bracket_pairs[bracket] for bracket in reversed(brackets)])}'
					return cls.get_dictionary_from_string(string=string, _retry_count=_retry_count + 1)

				# if we have multiple lists
				# e.g. `[…] […]` -> `[[…], […]]` -> `[…]`
				matches: list[str] = re.findall(r'\[.*?\]', string, re.DOTALL | re.MULTILINE)

				if matches:

					try:
						combined_list: list[list[dict[Any]]] = cls.get_dictionary_from_string(string=f'[{", ".join(matches)}]', _retry_count=_retry_count + 1)

						# e.g. `[[…], […]]` -> `[…]`
						if combined_list:
							return sum(combined_list, [])

					except Exception as exception:
						pass

				# check to see if there are missing quotes
				if string.count('"') % 2 != 0 and 'Unterminated string starting at' in str(error):

					# identify the unterminated string error
					# e.g. `unterminated string starting at 123` -> `123`
					column_index_raw: str = str(error).index('line 1 column ') + len('line 1 column ')
					column_str: str = str(error)[column_index_raw:].split(' ')[0]
					column_index: int = int(column_str) - 1

					# close with double quotes before each `}` and `]`
					# until the error is resolved
					for character_index in range(len(string) - 1, column_index, -1):

						if string[character_index] in '}]':

							new_string: str = f'{string[:character_index]}"{string[character_index:]}'

							try:
								return json.loads(new_string, strict=False)

							except json.decoder.JSONDecodeError as sub_error:
								pass

			raise Exception(f'could not convert string to JSON ({string=}, {error=})')

		return string

	@classmethod
	def get_mcp_definition_from_string(cls, string: str) -> dict[str, Any]:
		"""
		Returns the MCP definition from a given Markdown definition

		@param string(str): A string containing markdown text
		@return (list): A list of code blocks found in the markdown
		"""

		language: str = ''
		code_blocks: list[str] = []
		in_code_block: bool = False
		current_block: list[str] = []
		lines: list[str] = string.split('\n')

		for line in lines:

			if line.startswith('```'):

				if not in_code_block:

					current_block = []
					in_code_block = True
					language = line[3:].strip()

				else:

					in_code_block = False
					code_blocks.append({
						'language': language,
						'code': '\n'.join(current_block)
					})

			elif in_code_block:

				if line.startswith(('#', '...')):
					continue

				current_block.append(line)

		# handle case where markdown ends without closing code block
		if in_code_block and current_block:
			code_blocks.append({'language': language, 'code': '\n'.join(current_block)})

		for code_block in code_blocks:

			code: str = code_block['code']

			if code.startswith('{'):

				mcp_definition: dict[str, Any] = None

				try:
					mcp_definition = Tool.get_dictionary_from_string(string=code)

				except:
					continue

				# check if the top-level dictionary has 'command' and 'args'
				if 'command' in mcp_definition and 'args' in mcp_definition:
					return mcp_definition

				# Helper function to recursively search for dictionaries with 'command' and 'args'
				def _get_nested_mcp_definition(mcp_definition: dict[str, Any] | list) -> dict[str, Any]:

					if isinstance(mcp_definition, dict):

						if 'command' in mcp_definition and 'args' in mcp_definition:
							return mcp_definition

						# Search through all values in the dictionary
						for value in mcp_definition.values():

							if isinstance(value, (dict, list)):

								result = _get_nested_mcp_definition(mcp_definition=value)

								if result:
									return result

					# search through all items in the list
					elif isinstance(mcp_definition, list):

						for item in mcp_definition:

							if isinstance(item, (dict, list)):

								result = _get_nested_mcp_definition(mcp_definition=item)

								if result:
									return result

				# check if any nested dictionary has 'command' and 'args'
				if nested_mcp_definition := _get_nested_mcp_definition(mcp_definition=mcp_definition):
					return nested_mcp_definition

		return

	@classmethod
	def get_mcp_definition_from_string(cls, string: str) -> dict[str, Any]:
		"""
		Returns the MCP definition from a given Markdown definition

		@param string(str): A string containing markdown text
		@return (dict): The MCP definition or its parent container if nested
		"""

		language: str = ''
		in_code_block: bool = False
		code_blocks: list[dict] = []
		current_block: list[str] = []
		lines: list[str] = string.split('\n')

		for line in lines:

			if line.startswith('```'):

				if not in_code_block:

					current_block = []
					in_code_block = True
					language = line[3:].strip()

				else:

					in_code_block = False
					code_blocks.append({
						'language': language,
						'code': '\n'.join(current_block)
					})

			elif in_code_block:

				if line.startswith(('#', '...')):
					continue

				current_block.append(line)

		# handle case where markdown ends without closing code block
		if in_code_block and current_block:
			code_blocks.append({'language': language, 'code': '\n'.join(current_block)})

		for code_block in code_blocks:
			code: str = code_block['code']
			if code.startswith('{'):
				mcp_definition: dict[str, Any] = None
				try:
					mcp_definition = Tool.get_dictionary_from_string(string=code)
				except:
					continue

				# check if the top-level dictionary has 'command' and 'args'
				if 'command' in mcp_definition and 'args' in mcp_definition:
					return mcp_definition

				# helper function to recursively search for dictionaries with 'command' and 'args'
				def _get_nested_mcp_definition(obj: Any, parent: Any = None) -> tuple[dict, Any]:

					if isinstance(obj, dict):

						if 'command' in obj and 'args' in obj:
							return obj, parent

						# search through all values in the dictionary
						for key, value in obj.items():

							if isinstance(value, (dict, list)):

								result, found_parent = _get_nested_mcp_definition(value, obj)

								if result:
									return result, found_parent

					# search through all items in the list
					elif isinstance(obj, list):

						for item in obj:

							if isinstance(item, (dict, list)):

								result, found_parent = _get_nested_mcp_definition(item, obj)

								if result:
									return result, found_parent

					return None, None

				# check if any nested dictionary has 'command' and 'args'
				result, parent = _get_nested_mcp_definition(mcp_definition)

				# return the parent container if it exists, otherwise return the MCP definition itself
				if result:
					return parent if parent else result

		return None

	def __str__(self):
		return f'<Tool name={self.name}>'

	__repr__ = __str__


@dataclass
class MissingArguments(Exception):
	"""
	Used when a tool/function is called without required arguments
	"""
	arguments: list[dict]

	@property
	def argument_names(self) -> list[str]:
		return [argument["name"] for argument in self.arguments]


class RunToolAgain(Exception):
	"""
	Means the tool should be called again by AI but with a different input
	"""

	message: str = None
	run_after_tool_name: str = None  # e.g. `send_email`

	def __init__(self, message: str, run_after_tool_name: str = None):

		self.message = message
		self.run_after_tool_name = run_after_tool_name


class PendingToolResponse(Exception):
	"""
	Pauses the AI's flow until the tool responds. An example of this is email and Slack,
	where AI messages/emails someone, and waits for them to respond
	"""

	external_id: str = None

	def __init__(self, external_id: str):
		self.external_id = external_id


""" Types """

class Dictionary(dict):

	raw: str = None

	def __new__(cls, data: dict[Any, Any]):

		instance = super().__new__(cls, data)
		return instance

	def get(self, key: Any, default: Any = None) -> Any:

		if isinstance(key, tuple):
			return next((super(Dictionary, self).get(_key) for _key in key if _key in self), default)

		return super(Dictionary, self).get(key, default)


if __name__ == '__main__':
	print(Tool.get_dictionary_from_string(string='{"name": `test`}}'))

