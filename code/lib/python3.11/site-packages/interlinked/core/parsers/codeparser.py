import re
import inspect
from typing import Any
from textwrap import dedent
from pydantic import BaseModel

from interlinked.core.ai import Section
from interlinked.core.utilities import Utilities


class CodeParser:
	"""
	[Internal]
	Converts code to `Section` to use with `AI.learn(…)`

	Supported languages:
	- Python
	- Java
	- Swift

	Code parser can be used to provide AI with knowledge about your overall code structure.
	This includes function names, descriptions, properties and their comments, and more.
	Currently, it does not include the actual code content of each function.
	"""

	@classmethod
	def get_section_for_python_class(cls, class_: Any, include_code: bool = False,
									 skip_internal: bool = True, skip_no_description: bool = True) -> Section:
		"""
		Parses a Python class then returns a `Section`

		@param class_(Any): A Python class
		@param include_code(bool): Whether to include the code under each function. Generally, not recommended.
								   Instead, use `Knowledge.search(…)`, get the `knowledge.external_id`, then the code
		@param skip_internal(bool): Whether to skip internal/private functions and properties
		@param skip_no_description(bool): Whether to skip variables with no description
		"""

		if include_code:
			raise NotImplementedError('Including code is not supported yet with Java')

		lines, _ = inspect.getsourcelines(class_)
		section: Section = Section(title=class_.__name__)

		if class_.__doc__:
			section.content.append(dedent(class_.__doc__))

		section.content.append(f'This class can be imported via `from {class_.__module__} import {class_.__name__}`.')

		# add variables
		def get_description_for_annotation_name(annotation_name: str) -> str:
			"""
			Returns the description for a given class variables (annotation)
			"""

			description: list[str] = []
			annotation_line_index: int = None

			for line_index, line in enumerate(lines):

				# check if the variable is in the line (basic assumption: var_name is used directly).
				if line.strip().startswith((f'{annotation_name} ', f'{annotation_name}: ')):

					annotation_line_index = line_index
					break

			# if the variable line number is found, collected documentation lines
			if annotation_line_index is None:
				return None

			for line_index in range(annotation_line_index - 1, -1, -1):

				stripped_line = lines[line_index].strip()

				if stripped_line.startswith('#'):
					description.insert(0, stripped_line.removeprefix('# '))

				else:
					break

			if not description:
				return None

			# join the description lines into a single string
			return '\n'.join(description).strip()

		for annotation_name, annotation_class in class_.__annotations__.items():

			if skip_internal and annotation_name.startswith('_'):
				continue

			if annotation_name.startswith('__'):
				continue

			# convert the class name
			annotation_class_name: str = str(annotation_class).replace('typing.', '').replace('<class \'', '').replace('\'>', '')

			# e.g. `ForwardRef(…)` -> …
			annotation_class_name = re.sub(r"ForwardRef\('(\w+)'\)", r'\1', annotation_class_name)

			# e.g. `Optional[str]` -> `str | None`
			# TODO: `Optional[list[float]]` should be `list[float] | None`
			if 'Optional[' in annotation_class_name:

				pattern: str = re.compile(r'Optional\[(.*?)\]')

				while pattern.search(annotation_class_name):
					annotation_class_name = pattern.sub(r'\1 | None', annotation_class_name)

			subsection: Section = Section()
			subsection.title = f'Variable: {annotation_name}:{annotation_class_name}'

			if annotation_description := get_description_for_annotation_name(annotation_name=annotation_name):
				subsection.content.append(annotation_description)

			elif skip_no_description and annotation_name.isupper():
				continue

			section.append_subsection(subsection=subsection)

		defined_members: set[str] = set(class_.__dict__.keys())

		for name, member in inspect.getmembers(class_):

			# skip internal methods
			if skip_internal and (name.startswith('_') and name != '__init__'):
				continue

			# skip
			if name not in defined_members:
				continue

			if (is_function := inspect.isfunction(member)) or (is_method := inspect.ismethod(member)):

				subsection: Section = Section()

				if name == '__init__':
					subsection.title = f'Init: {class_.__name__}'

				else:

					return_type: str = member.__annotations__.get('return', None)
					return_type = str(return_type).replace('typing.Self', class_.__name__)
					return_type = return_type.replace('<class \'', '').replace('\'>', '')
					return_type = return_type.replace('collections.abc.', '')
					return_type = return_type.replace('typing.', '')
					return_type = return_type.replace('[\'', '[').replace('\']', ']')

					name = f'{name}->{return_type}'

					subsection.title = f'Function: {name}' if is_function else f'Classmethod: {name}'

				subsection.external_id = f'from {class_.__module__} import {class_.__name__}:{class_.__name__}.{name}'

				if member.__doc__:
					subsection.content.append(cls.get_formatted_docstring(dedent(member.__doc__).strip()))

				section.append_subsection(subsection=subsection)

		return section

	@classmethod
	def get_section_for_java(cls, content: str, include_code: bool = False,
							 skip_internal: bool = True, skip_no_description: bool = True) -> Section:
		"""
		Parses a Java file then returns a `Section`

		@param class_(Any): A Java file content
		@param include_code(bool): Whether to include the code under each function. Generally, not recommended.
								   Instead, use `Knowledge.search(…)`, get the `knowledge.external_id`, then the code
		@param skip_internal(bool): Whether to skip internal/private functions and properties
		@param skip_no_description(bool): Whether to skip variables with no description
		"""

		if include_code:
			raise NotImplementedError('Including code is not supported yet with Java')

		# `javalang` is unable to parse some code
		# to temporarily mitigate this issue, we remove the content
		# of each function
		lines: list[str] = content.splitlines()
		prestart_index: int = None
		start_index: int = None

		for line_index, line in enumerate(lines):

			if not start_index and (' class ' not in line and ' interface ' not in line) and line.strip().startswith(('public', 'private', 'void', 'protected')):

				if line.strip().endswith('{'):

					start_index = line_index
					prestart_index = None

				else:
					prestart_index = line_index

				continue

			elif prestart_index and start_index is None and line.strip().endswith('{'):

				start_index = prestart_index
				prestart_index = None
				continue

			if start_index is not None:

				if line == '    }' or line == '}':
					start_index = None

				else:
					lines[line_index] = None

		content = '\n'.join([line for line in lines if line is not None])

		def _get_documentation_for_node(node: Any) -> str:

			is_private: bool = 'private' in node.modifiers or 'protected' in node.modifiers
			documentation: str = ''

			if node.documentation:
				documentation = re.sub(r'^\W+\* ', '', node.documentation, flags=re.MULTILINE).replace('/**', '').replace('*/', '')
				documentation = documentation.replace('<p>', '')

			if is_private and not 'Internal' in documentation:
				documentation = f'[Internal]\n{documentation}'

			return documentation.strip()

		try:
			import javalang

		except ImportError:

			Utilities.install_package('javalang')
			import javalang

		section: Section = Section(title='')
		method_dict: dict[str, Section] = {}

		for _, node in javalang.parse.parse(content):

			if isinstance(node, javalang.tree.ClassDeclaration):

				section.title = node.name
				section.content = [_get_documentation_for_node(node=node)]

			elif isinstance(node, javalang.tree.MethodDeclaration):

				method_name = node.name
				return_type: str = node.return_type.name if node.return_type else 'null'

				if return_type:

					# if it's a list, get the sub-type
					# e.g. `List<Knowledge>`
					if return_type == 'List' and node.return_type.arguments and node.return_type.arguments[0].type:
						return_type = f'{return_type}<{node.return_type.arguments[0].type.name}>'

					method_name = f'{method_name}->{return_type}'

				is_function: bool = 'static' not in node.modifiers
				method_key = f'Function: {method_name}' if is_function else f'Classmethod: {method_name}'

				# count parameters for this method
				parameter_count: int = len(node.parameters) if node.parameters else 0

				if method_key not in method_dict:

					subsection = Section(title=method_key)

					if node.documentation:
						subsection.content.append(_get_documentation_for_node(node=node))

					method_dict[method_key] = {
						'subsection': subsection,
						'parameter_count': parameter_count
					}

				else:

					# only replace if this method has more parameters
					if parameter_count > method_dict[method_key]['parameter_count']:

						subsection = Section(title=method_key)

						if node.documentation:
							subsection.content.append(_get_documentation_for_node(node=node))

						method_dict[method_key] = {
							'subsection': subsection,
							'parameter_count': parameter_count
						}

			elif isinstance(node, javalang.tree.FieldDeclaration):

				subsection: Section = Section()
				subsection.title = f'Variable: {node.declarators[0].name}:{node.type.name}'

				if node.documentation:

					# print(node.documentation)
					# print('----')
					subsection.content = [_get_documentation_for_node(node=node)]
					# subsection.content += [f'@param {parameter.name}({parameter.type.name}' for parameter in node.parameters]

				section.append_subsection(subsection=subsection)

		for method_key in method_dict:
			method_dict[method_key] = method_dict[method_key]['subsection']

		for subsection in method_dict.values():
			section.append_subsection(subsection=subsection)

		return section

	@classmethod
	def get_section_for_swift(cls, content: str, include_code: bool = False,
							  skip_internal: bool = True, skip_no_description: bool = True) -> Section:
		"""
		Parses a Swift file then returns a `Section`

		@param content(Any): A Swift file
		@param include_code(bool): Whether to include the code under each function. Generally, not recommended.
								   Instead, use `Knowledge.search(…)`, get the `knowledge.external_id`, then the code
		@param skip_internal(bool): Whether to skip internal/private functions and properties
		@param skip_no_description(bool): Whether to skip variables with no description
		"""

		if include_code:
			raise NotImplementedError('Including code is not supported yet with Java')

		section: Section = Section()
		current_subsection: Section = section
		current_documentation: list[str] = []

		# return early if the entire file is commented out
		if (_content := content.strip()) and _content.startswith('/*') and _content.endswith('*/'):
			return section

		open_bracket_count: int = 0
		block_count = 0
		lines: list[str] = content.splitlines()

		def get_description_for_class_name(annotation_line_index: int) -> str:
			"""
			Returns the description for a given class or function
			"""

			description: list[str] = []
			previous_line_index: str = next(index for index in range(annotation_line_index - 1, -1, -1) if not lines[index].strip().startswith('@'))

			if lines[previous_line_index].strip().startswith('*'):

				for index in range(previous_line_index - 1, -1, -1):

					stripped_line = lines[index].strip()

					if stripped_line.startswith('/*'):
						break

					description.insert(0, re.sub(r'^(/\*+|\*+/)', '', lines[index]))

			else:

				for index in range(annotation_line_index - 1, -1, -1):

					stripped_line = lines[index].strip()

					if not stripped_line.startswith(('/*', '//')):
						break

					description.insert(0, re.sub(r'^/+\W', '', stripped_line))

			# join the description lines into a single string
			return '\n'.join(description).strip() if description else None

		def get_description_for_annotation_name(annotation_line_index: int) -> str:
			"""
			Returns the description for a given class variables (annotation)
			"""

			description: list[str] = []

			for line_index in range(annotation_line_index - 1, -1, -1):

				stripped_line = lines[line_index].strip()

				if stripped_line.startswith('//'):
					description.insert(0, re.sub(r'^[/]+\W', '', lines[line_index].strip()))

				else:
					break

			if not description:
				return None

			# join the description lines into a single string
			return '\n'.join(description).strip()

		# skip comments
		in_comment_block: bool = False

		for line_index, line in enumerate(lines):

			line_stripped: str = line.strip()

			if line_stripped.startswith('/*'):

				in_comment_block = True
				continue

			elif line_stripped.startswith('/'):
				continue

			elif line_stripped.startswith('*') and in_comment_block:

				in_comment_block = False
				continue

			if in_comment_block:
				continue

			# classes
			# we currently skip nested structs/classes
			if class_matches := re.findall(r'(struct|class|protocol) (.*?)(?:\W|\:|\W+{)', line_stripped):

				class_match: tuple = class_matches[0]

				# skip if function
				if '->' not in line_stripped and not re.findall(r'\bvar|let\b', line_stripped):

					class_type, class_name = class_match[0], class_match[1]

					subsection = Section(title=f'{class_type.title()}: {class_name}')

					# get description
					if description := get_description_for_class_name(annotation_line_index=line_index):
						subsection.content = [description]

					section.append_subsection(subsection)
					current_subsection = subsection
					continue

			# enum cases
			if current_subsection.title and current_subsection.title.startswith('Enum') and \
			   (case_matches := re.findall(r'^case ([A-Za-z0-9_]+)(.+)$', line_stripped)):

				case_match: list[tuple] = case_matches[0]

				# e.g. `pause`, `(messages: […])`
				enum_name, enum_arguments = case_match[0], case_match[1]

				subsection: Section = Section(title=f'Case: {enum_name}')

				if description := get_description_for_annotation_name(annotation_line_index=line_index):
					subsection.content = [description]

				current_subsection.append_subsection(subsection)
				continue

			if variable_matches := re.findall(r'^(?:weak|)?(private |public |internal |open |)(?:static |)(let|var) ([A-Za-z0-9_]+): (.+)$', line_stripped.split('{')[0].split('=')[0].strip()):

				if block_count > 1:
					continue

				variable_match: list[tuple] = variable_matches[0]

				# e.g. public/private, var/let, variableName, String?
				variable_scope, variable_name, variable_type = variable_match[0], variable_match[2], variable_match[3]

				subsection: Section = Section(title=f'Variable: {variable_name}:{variable_type}')

				if description := get_description_for_annotation_name(annotation_line_index=line_index):
					subsection.content = [description]

				current_subsection.append_subsection(subsection)

			# functions + init
			function_matches: list[str] = re.findall(r'(private |public |internal |)(class|static|) func ([A-Za-z0-9_]+)', line_stripped)

			if not function_matches:
				function_matches = re.findall(r'(required |)(convenience |private |public |internal |) (\binit\b)', line_stripped)

			if function_matches:

				function_match: list[tuple] = function_matches[0]
				function_type, is_classmethod, function_name = function_match[0], len(function_match[1]) > 0, function_match[2]

				# get arguments + return type
				signature_lines: list[str] = []
				for _line_index in range(line_index, len(lines)):

					_line: str = lines[_line_index]
					signature_lines.append(_line)

					if _line.strip().endswith('{'):

						signature_line: str = ' '.join([signature_line.strip() for signature_line in signature_lines]).removesuffix('{').strip()

						# e.g. `public func functionName(argument1: Int) -> String` -> `functionName(argument1: Int) -> String`
						signature_line = signature_line.split(function_name)[-1]

						return_type: str = None

						if '->' in signature_line:

							signature_line, return_type = signature_line.rsplit('->', 1)
							function_name = f'{function_name}->{return_type.strip()}'

						block_count += 1
						break

				title: str = None

				if function_name == 'init':
					title = f'Init: {current_subsection.title.split(": ")[-1]}'

				else:
					title = f'Classmethod: {function_name}' if is_classmethod else f'Function: {function_name}'

				subsection: Section = Section(title=title)

				# get description
				if description := get_description_for_class_name(annotation_line_index=line_index):
					subsection.content = [description]

				current_subsection.append_subsection(subsection)

			# adjust block count based on `{` and `}`
			block_count += line.count('{')
			block_count -= line.count('}')

		return section

	""" Utilities """

	@classmethod
	def get_formatted_docstring(cls, docstring: str) -> str:
		"""
		Formats a docstring by cleaning up multi-line parameter descriptions
		
		@param docstring(str): The raw docstring to format
		"""

		if not docstring:
			return docstring
			
		line_index: int = 0
		formatted_lines: list[str] = []
		lines: list[str] = docstring.split('\n')
		
		while line_index < len(lines):

			line: str = lines[line_index]
			
			# check if this line starts a parameter description
			if line.strip().startswith('@param '):

				# start building the parameter line
				param_line = line.strip()
				line_index += 1
				
				# continue collecting continuation lines for this parameter
				while line_index < len(lines):

					next_line: str = lines[line_index].strip()
					
					# if next line is empty, another @param, or doesn't
					# look like a continuation, stop
					if (not next_line or next_line.startswith('@') or
						(next_line and not next_line[0].islower() and not next_line[0].isdigit())):
						break
					
					# this is a continuation line, add it to the parameter
					if next_line:
						param_line += ' ' + next_line

					line_index += 1
				
				formatted_lines.append(param_line)
				continue

			else:
				formatted_lines.append(line)
				line_index += 1
		
		return '\n'.join(formatted_lines)



if __name__ == '__main__':

	from interlinked.core.ai import AI, Observation
	# print(CodeParser.get_section_for_python_class(class_=Observation))
	# print(CodeParser.get_section_for_java(content=open('/Users/lopez/Documents/GitHub/interlinked-java/src/main/java/com/apple/interlinked/Template.java', 'r').read()))
	# print(CodeParser.get_section_for_java(content=open('/Users/lopez/Documents/GitHub/interlinked-java/src/main/java/com/apple/interlinked/ObservationStreamCallback.java', 'r').read()))
	# print(CodeParser.get_section_for_java(content=open('/Users/lopez/Documents/GitHub/interlinked-java/src/main/java/com/apple/interlinked/Response.java', 'r').read()))
	# print(CodeParser.get_section_for_java(content=open('/Users/lopez/Documents/GitHub/interlinked-java/src/main/java/com/apple/interlinked/Observation.java', 'r').read()))
	print(CodeParser.get_section_for_java(content=open('/Users/lopez/Documents/GitHub/interlinked-java/src/main/java/com/apple/interlinked/Knowledge.java', 'r').read()))
	# print(CodeParser.get_section_for_java(content=open('/Users/lopez/Documents/GitHub/interlinked-java/src/main/java/com/apple/interlinked/Utilities.java', 'r').read()))
	# print(CodeParser.get_section_for_java(content=open('/Users/lopez/Documents/GitHub/interlinked-java/src/main/java/com/apple/interlinked/AI.java', 'r').read()))
