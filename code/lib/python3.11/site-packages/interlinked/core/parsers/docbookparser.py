import re
import logging
from typing import Iterator
from bs4 import BeautifulSoup, Tag, ProcessingInstruction

from interlinked.core.ai import Section

logger = logging.getLogger(__name__)


class DocBookParser:
	"""
	Converts DocBook XML files to `Section`
	"""

	# tags to treat as blocks of text
	TEXT_TAGS: set[str] = {

		'para',
		'bibliomixed'
		'bibliography',
	}

	# tags to treat as tables
	TABLE_TAGS: set[str] = {

		'table',
		'informaltable'
	}

	# tags to treat as sections
	SECTION_TAGS: set[str] = {

		'section',
		'chapter', # chapters included from other documents may appear under sections
	}

	@classmethod
	def get_section_for_docbook(cls, content: str) -> Section:
		"""
		Parses a given a DocBook XML, then returns a `Section`

		@param content(str): DocBook XML
		@return (Section): DocBook XML as a Section
		"""

		beautiful_soup: BeautifulSoup = BeautifulSoup(content, 'xml')

		# remove unused top-level `xml-model` tag
		for tag in list(beautiful_soup.contents):

		    if isinstance(tag, ProcessingInstruction):
		        tag.extract()

		tree: str = beautiful_soup.contents

		if not tree:
			return Section()

		# get the first tag
		tree = tree[0]

		chapter_number: str = 1
		appendix_letter: str = 'A'

		title: str = ''
		subtitle: str = ''
		subsections: list[Section] = []
		section_content: list[str] = []

		for child in tree.children:

			if child.name == 'chapter':

				subsections.append(cls.get_section_for_top_level(tag=child, number=chapter_number))
				chapter_number += 1

			elif child.name == 'preface':

				# Prefaces are not numbered
				subsections.append(cls.get_section_for_top_level(tag=child, number=0))

			elif child.name == 'appendix':

				subsections.append(cls.get_section_for_top_level(tag=child, number=appendix_letter))
				assert appendix_letter != 'Z', 'Appendix letter overflow'
				appendix_letter = chr(ord(appendix_letter) + 1)

			elif child.name == 'info':

				title = cls._get_tag_title(child)
				if subtitle_tag := child.find('subtitle'):
					section_content = [subtitle_tag.get_text(strip=True)]

		return Section(title=title, external_id=tree.attrs['xml:id'], content=section_content, subsections=subsections)

	@classmethod
	def _get_tag_title(cls, tag: Tag) -> str:

		if title_tag := tag.find('title'):
			return title_tag.get_text(strip=True).replace('\n', ' ')

		return ''

	@classmethod
	def _strip_whitespace(cls, string: str) -> str:
		return re.sub(r'\s+', ' ', string).strip()

	@classmethod
	def _get_clean_text(cls, tag: Tag) -> str:
		return cls._strip_whitespace(tag.get_text())

	@classmethod
	def get_markdown_for_table(cls, tag: Tag) -> Iterator[str]:
		"""
		Converts a given HTML table to Markdown format

		@param table(Tag|str): a BeautifulSoup table tag or HTML string
		@return (str): a Markdown table
		"""

		for row_index, row in enumerate(tag.find_all('row')):

			row_contents: list[str] = [cls._get_clean_text(tag=column_tag) for column_tag in row.find_all('entry')]

			# Skip rows only containing whitespace
			if not any([row_content.strip() for row_content in row_contents]):
				continue

			# | col1 | col2 | col3 |
			yield f'| {" | ".join(row_contents)} |'

			# generate separator row after the header, assumed to be first row
			# | --- | --- | --- |
			if row_index == 0:
				yield f'| {" | ".join(["---"] * len(row_contents))} |'

	@classmethod
	def get_section_for_table(cls, tag: Tag) -> Section:

		title: str = f'Table: {cls._get_tag_title(tag=tag)}'
		content: list[str] = list(cls.get_markdown_for_table(tag=tag))

		return Section(title=title, external_id=tag.attrs.get('xml:id', ''), content=content)

	@classmethod
	def get_content_for_para(cls, tag: Tag) -> Iterator[str]:

		for child in tag.children:

			if child.name in cls.TABLE_TAGS:
				yield from cls.get_markdown_for_table(tag=child)

			elif child.name == 'para':
				yield from cls.get_content_for_para(tag=child)

			else:
				yield cls._get_clean_text(tag=child)

	@classmethod
	def get_section_for_section(cls, tag: Tag, section_numbers: list[int], is_numbered: bool = True) -> Section:

		title: str = None

		if is_numbered:
			title = f'Section {".".join([str(section_number) for section_number in section_numbers])}: {cls._get_tag_title(tag=tag)}'

		else:
			title = cls._get_tag_title(tag=tag)

		subsections: list[Section] = []
		subsection_index = 1
		content: list[str] = []

		for child in tag.children:

			# chapters included from other documents may appear under sections. Treat these as normal sections.
			if child.name == 'section' or child.name == 'chapter':

				subsections.append(cls.get_section_for_section(tag=child, section_numbers=section_numbers + [subsection_index], is_numbered=is_numbered))
				subsection_index += 1

			elif child.name in cls.TEXT_TAGS:
				content.extend(cls.get_content_for_para(tag=child))

			elif child.name in cls.TABLE_TAGS:
				subsections.append(cls.get_section_for_table(tag=child))

		return Section(title=title, external_id=tag.attrs['xml:id'], content=content, subsections=subsections)

	@classmethod
	def get_section_for_top_level(cls, tag: Tag, number: int | str) -> Section:

		if tag.name == 'chapter':
			title = f'Chapter {number}: {cls._get_tag_title(tag=tag)}'

		elif tag.name == 'preface':
			title = cls._get_tag_title(tag=tag)

		elif tag.name == 'appendix':
			title = f'Appendix {number}: {cls._get_tag_title(tag=tag)}'

		subsections: list[Section] = []
		subsection_index: int = 1
		content: list[str] = []

		for child in tag.children:

			if child.name in cls.SECTION_TAGS:

				subsections.append(cls.get_section_for_section(tag=child, section_numbers=[number, subsection_index]))
				subsection_index += 1

			elif child.name in cls.TEXT_TAGS:
				content.extend(cls.get_content_for_para(tag=child))

			elif child.name in cls.TABLE_TAGS:
				subsections.append(cls.get_section_for_table(tag=child))

		return Section(title=title, external_id=tag.attrs['xml:id'], content=content, subsections=subsections)


if __name__ == '__main__':
	print(DocBookParser.get_section_for_docbook(content=open('specification.xml')))
