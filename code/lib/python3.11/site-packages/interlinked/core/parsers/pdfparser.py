"""
[Internal/not ready for use yet]
brew install poppler
"""

import re
import logging
from io import BytesIO
from typing import Any

from interlinked import AI, Section
from interlinked.core.utilities import Utilities
from interlinked.core.clients.ollamaclient import OllamaClient

logger = logging.getLogger(__name__)


TEMPLATE: str =  \
'''Given the PDF page, your task is to extract all of the titles.

Headers are typically in bold and vary in sizes (similar to headers in HTML). You must be very concise.

You MUST respond in this JSON format:
[{"title": …, "level": "h1"}, {"title": …, "level": "h2"}, …]

The JSON format must be correct'''


FOOTER_TEMPLATE: str =  \
'''We are parsing PDF files and are looking to extract relevant data only. Given the PDF page, your task is to extract all of the footers.

Footers may contain the page title and page number

You MUST respond in this JSON format:
[{"title": …, "level": "h1"}, {"title": …, "level": "h2"}, …]

The JSON format must be correct'''


class PDFParser:
	"""
	Converts a given PDF to `Section`
	"""

	@classmethod
	def get_section_for_pdf(cls, content: bytes, client: Any = None) -> Section:
		"""
		Asks AI to extract the structure from a PDF then returns a `Section`
		"""

		try:

			from PIL import Image
			from PyPDF2 import PdfReader
			from pdf2image import convert_from_path

		except ModuleNotFoundError as error:

			Utilities.install_package(name='pypdf2 pdf2image Pillow')

			from PIL import Image
			from PyPDF2 import PdfReader
			from pdf2image import convert_from_path

		# read the PDF then iterate over each page
		pdf_reader: PdfReader = PdfReader(stream=content)
		section_map: list[tuple[int, Section]] = []

		for page_index, page in enumerate(pdf_reader.pages):

			image: Any = convert_from_path(content, dpi=200, first_page=page_index + 1, last_page=page_index + 1)[0]

			# convert the page to an image, then ask AI
			# to extract the headers and their levels
			page_bytes_io: BytesIO = BytesIO()
			image.save(page_bytes_io, format='PNG')

			page_bytes: bytes = page_bytes_io.getvalue()
			observation: Observation = AI.ask(template=TEMPLATE, files=[page_bytes], client=client)

			if not observation.response_as_dictionary:
				logger.info(f'no titles in page {page_index + 1}. treating as part of the Section content')

			elif isinstance(observation.response_as_dictionary, dict):
				raise Exception(f'could not parse PDF. model responded with an invalid format: {observation.response_as_dictionary}')

			else:

				page_text: str = page.extract_text().replace(' ', '')
				current_page_text: str = page_text

				for title_level_index, title_level in enumerate(observation.response_as_dictionary):

					title: str = title_level.get('title').replace('\n', '').strip()
					level: int = int(str(title_level.get('level').replace('h', '')))

					content_start_index: int = cls.get_index_for_title(title=title, text=current_page_text)

					# get the index of the next title to make sure we stop there
					next_title: str = observation.response_as_dictionary[title_level_index + 1].get('title').strip() if title_level_index + 1 < len(observation.response_as_dictionary) else None
					content_end_index: int = cls.get_index_for_title(title=next_title, text=current_page_text) if next_title else None

					# the content starts where the title ends but before the next title
					section_content: str = current_page_text[content_start_index:content_end_index].strip()
					section: Section = Section(title=title, content=[section_content])

					if not section_map:
						section_map.append((level, section))

					else:

						section_map_reversed: list = section_map[:]
						section_map_reversed.reverse()

						previous_section: Section = next((level_section[1] for level_section in section_map_reversed if level_section[0] < level), None)

						if previous_section:
							previous_section.append_subsection(subsection=section)

						elif section_map:
							section_map[0][1].append_subsection(subsection=section)

						section_map.append((level, section))

				current_page_text = current_page_text[content_end_index:]

		return section_map[0][1] if section_map else None

	@classmethod
	def get_index_for_title(cls, title: str, text: str) -> int:
		"""
		Returns the start index of a title in a given text

		e.g.
		`title = ''`

		@param title(str): a title
		"""
		index: int = re.search(title, text, flags=re.IGNORECASE | re.MULTILINE)

		if not index:
			index = re.search(title, text.replace(title.replace(' ', '').replace(' ', ''), title),
							  flags=re.IGNORECASE | re.MULTILINE)

		return index.start() if index else None


if __name__ == '__main__':

	from interlinked.core.clients.openaiclient import OpenAIClient
	print(PDFParser.get_section_for_pdf(content='file.pdf'))