import re
from bs4 import BeautifulSoup, Tag

from interlinked.core.ai import Section
from interlinked.core.parsers.htmlparser import HTMLParser
from interlinked.core.parsers.imageparser import ImageParser


class QuipParser(HTMLParser):
	"""
	Converts Pages pages to `Section` to use with `AI.learn(…)`
	"""

	@classmethod
	def get_section_for_html(cls, content: str, include_style: bool = False) -> Section:
		"""
		Parses HTML then returns a `Section`

		@param content(str): The document HTML (from `QuipClient.get_thread(…)`)
		@param include_style(bool): (Internal) Preserves styles, such as bold
		@return (Section): a Section for the document
		"""

		beautiful_soup: BeautifulSoup = BeautifulSoup(content, 'html.parser')

		# check to see if this document is empty
		# when creating a Quip doc, the default title and placeholder have `default-content` class
		# we check if all the document has is just those placeholders
		top_level_tags: list[Tag] = [child for child in beautiful_soup.children if child.name is not None]
		default_content_tags: list[Tag] = beautiful_soup.find_all(class_='default-content')

		if len(top_level_tags) == len(default_content_tags) or not ''.join([tag.get_text() for tag in top_level_tags if tag not in default_content_tags]).strip():
			return Section()

		# make sure all `prettyprint` classes are `pre`, so they're converted to codeblocks
		for tag in beautiful_soup.find_all(class_='prettyprint'):

			tag.name = 'pre'

			# Quip wraps each line inside of prettyprint with `<code>`
			# we unwrap all of these tags, so when `<pre>` is parsed in `HTMLParser`,
			# it will be one string (with multiple lines) instead
			for code_tag in tag.find_all('code'):
				code_tag.unwrap()

		# lists (`ul`) are wrapped with a div, unwrap, so we can read the `ul` element in HTMLParser
		# e.g. quip-apple.com/ElRgAaaTbxmi -> Enum -> Examples
		for tag in beautiful_soup.find_all('div', attrs={'data-section-style': True}):

			# replace all `ul` elements that have `data-section-style='6'` with an `ol`
			if tag.get('data-section-style') == '6':

				for ul_tag in tag.find_all('ul'):
					ul_tag.name = 'ol'

			tag.unwrap()

		# quip lists often have invalid-nested tags
		for improperly_nested_ul in beautiful_soup.find_all(['ul', 'ol']):
			previous_sibling = improperly_nested_ul.find_previous_sibling()
			
			# check if the previous sibling is indeed a <li>
			if previous_sibling and previous_sibling.name == 'li':
				previous_sibling.append(improperly_nested_ul)

		# sometimes Quip lists URLs inside code as `<a … data-nolink="true"`.
		# convert it to `p` with just the URL
		for tag in beautiful_soup.find_all('a', attrs={'data-nolink': 'true'}):

			previous_sibiling_tag: Tag = tag.find_previous_sibling()
			p_tag: Tag = beautiful_soup.new_tag('p')
			p_tag.string = tag['href']

			if previous_sibiling_tag and previous_sibiling_tag.name == 'code':

				previous_sibiling_tag.string = f'{previous_sibiling_tag.string.strip()} {p_tag.string}'
				tag.decompose()

			else:
				tag.replace_with(p_tag)

		# convert images to sections
		for tag in beautiful_soup.find_all('img'):

			src: str = tag.get('src')

			if '/blob/' not in src:
				continue

			# if Config.current.is_development:

			# 	src = src.removeprefix('/blob/')
			# 	thread_id, blob_id = src.split('/', 1)

			# 	from interlinked.core.clients.quipclient import QuipClient

			# 	blob: Any = QuipClient.shared.get_blob(thread_id=thread_id, blob_id=blob_id)
			# 	content_disposition = blob.info().get('Content-Disposition')

			# 	file_name: str = content_disposition.split('"')[-2] if content_disposition else None
			# 	blob_bytes: bytes = blob.read()

			# 	print(ImageParser.get_section_for_image(content=blob_bytes))

			# convert the image to a link, which we'll then use to parse
			tag.name = 'a'
			tag['href'] = src
			tag.string = tag.get('alt', 'image')

			# images are wrapped with divs (`data-section-style`)
			# but since we've unwrapped those divs, the image should be rewrapped but in a paragraph
			# to match the Quip format and to be parsed correctly
			# if the parent is beautiful soup (the doc itself), then the tag has no direct parent tag
			if tag.parent == beautiful_soup:
				tag.wrap(beautiful_soup.new_tag('p'))

		# prefix `<control>` with their actual values
		# controls are used in E92F to @ or reference another E92F
		for tag in beautiful_soup.find_all('control'):
			tag.replace_with(tag.get_text())

		# if we're including style, preserve empty lines
		if include_style:

			for tag in beautiful_soup.find_all('p', class_='line'):

				if tag.get_text() in {' ', '​'}:
					tag.string = '\n'

		return HTMLParser.get_section_for_html(content=str(beautiful_soup), include_style=include_style)


if __name__ == '__main__':

	from interlinked.core.clients.quipclient import QuipClient, Thread
	thread: Thread = QuipClient.shared.get_thread(id='4YboAkjys8rg')
	print(QuipParser.get_section_for_html(content=thread.html))
