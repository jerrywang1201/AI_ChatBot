import re
from bs4 import BeautifulSoup, Tag

from interlinked.core.ai import Section


class HTMLParser:
	"""
	Converts HTML to `Section`
	"""

	@classmethod
	def get_markdown_for_table(cls, table: Tag|str, skip_empty: bool = True) -> str:
		"""
		Converts a given HTML table to Markdown format

		@param table(Tag|str): a BeautifulSoup table tag or HTML string
		@param skip_empty(bool): whether to skip fully empty rows/columns
		@return (str): a Markdown table
		"""

		if isinstance(table, str):
			table = BeautifulSoup(table, 'html.parser').find_all('table')[0]

		row_tags: list[Tag] = table.find_all('tr')

		# contains columns and rows
		# e.g. `[['Column 1', 'Column 2', ''], ['1', 'Row 1', ''], ['2', 'Row 2', '']`
		columns_rows: list[list[str]] = [[cell.get_text().strip() for cell in row_tag.find_all(['th', 'td'])] for row_tag in row_tags]

		if skip_empty:

			# skip rows that are fully empty
			columns_rows = [row for row in columns_rows if any(cell for cell in row)]

			# skip columns that are fully empty
			columns_rows = list(zip(*columns_rows))
			columns_rows = [column for column in columns_rows if any(cell for cell in column)]

			# if we have no data after filtering rows/columns
			if not columns_rows:
				return ''

			# transpose back to original shape
			columns_rows = list(zip(*columns_rows))

		# create header row and separator row based on the first row (table headers)
		header_row: list[str] = [f'| {" | ".join(row)} |' for row in columns_rows[:1]]
		separator_row: list[str] = [f'| {" | ".join(["---" for _ in row])} |' for row in columns_rows[:1]]

		# create content rows
		content_rows: list[str] = [f'| {" | ".join(row)} |' for row in columns_rows[1:]]

		# remove new lines from content (since Markdown does not support new lines in tables)
		content_rows = [row.replace('\n', ' ') for row in content_rows]

		return '\n'.join(header_row + separator_row + content_rows)

	@classmethod
	def get_section_for_html(cls, content: str, include_style: bool = False) -> Section:
		"""
		Parses HTML then returns a `Section`

		@param content(str): the HTML to convert
		@param include_style(bool): whether to preserve style (e.g. *bold*)
		"""

		html: str = content
		html = html.replace(' ', ' ').replace('​', '</br>').replace('</br>', '\n')
		html = html.replace('<br/>', '\n')

		beautiful_soup: BeautifulSoup = BeautifulSoup(html, 'html.parser')

		# remove unused tags
		for tag in beautiful_soup(['script', 'style']):
			tag.extract()

		# convert codeblocks from `pre` to an actual div, so they are formatted properly
		# and each code line is on its own line, instead of everything on one line
		for tag in set(beautiful_soup.find_all('pre')):

			new_tag: Tag = beautiful_soup.new_tag('div')

			tag_string: str = '\n'.join(tag.strings).strip()
			new_tag.string = f'```\n{tag_string}\n```'
			tag.replace_with(new_tag)

		for tag in set(beautiful_soup.find_all('code')):

			tag_string: str = '\n'.join(tag.strings).strip()
			tag.replace_with(f'`{tag_string}`')

		# convert `<a>` to string with the URL
		# e.g. `<a href="…">lorem</a>` -> `lorem (lorem.apple.com)`
		for tag in beautiful_soup.find_all('a'):

			url: str = tag.get('href', '').strip('/')
			tag_text: str = tag.get_text()

			# only append the URL to the text if the text isn't already a URL
			# e.g. `<a href="interlinked.apple.com">interlinked</a>` -> `interlinked (interlinked.apple.com)`
			# e.g. `<a href="interlinked.apple.com">interlinked.apple.com</a>` -> `interlinked.apple.com`
			if url.replace('mailto:', '') not in tag_text:
				tag.replace_with(f'[{tag_text}]({url})')

			else:
				tag.replace_with(tag_text)

		def _get_markdown_for_list_tag(list_tag: Tag, level: int = 0) -> list[str]:
			"""
			Converts a given `ul` or `ol` tag to Markdown. Supports nested tags

			@param list_tag(Tag): A `ul` or `ol` tag
			@param level(int): (Optional) The nested level
			"""

			import copy

			markdown_text: list[str] = []

			# 1. go over each `li`
			# 2. get the text, convert it to `- text`
			# 3. repeat for nested `li`
			for li_tag_index, li_tag in enumerate(list_tag.find_all('li', recursive=False)):

				li_tag_copy = copy.deepcopy(li_tag)

				# remove all ul and ol elements from the copy
				for nested_list_tag in li_tag_copy.find_all(['ul', 'ol']):
				    nested_list_tag.extract()

				li_text: str = li_tag_copy.get_text()
				
				# add the list item to the Markdown content
				prefix: str = f'{level + li_tag_index + 1}.' if list_tag.name == 'ol' else '-'
				markdown_text += [('    ' * level) + f'{prefix} {li_text}\n']

				# recursively process nested lists
				if ul_tag := li_tag.find('ul'):
					markdown_text += _get_markdown_for_list_tag(list_tag=ul_tag, level=level + 1)

				elif ol_tag := li_tag.find('ol'):
					markdown_text += _get_markdown_for_list_tag(list_tag=ol_tag, level=level + 1)

			return markdown_text

		# replace all lists with Markdown
		for list_tag in beautiful_soup.find_all(['ul', 'ol'], recursive=False):

			markdown_text: list[str] = _get_markdown_for_list_tag(list_tag)

			# recursively process nested lists
			if list_tag.find(['ul', 'ol']):
				markdown_text += _get_markdown_for_list_tag(list_tag=list_tag.find(['ul', 'ol']), level=1)

			previous_tag: Tag = list_tag

			for _markdown_text in markdown_text:

				new_tag: Tag = beautiful_soup.new_tag('p')
				new_tag.string = _markdown_text

				previous_tag.insert_after(new_tag)
				previous_tag = new_tag

			list_tag.decompose()

		# if there are remaining `li` (e.g. invalid `li` elements not in `ul` or `ol`),
		# prefix `<li>` with `- …`
		for tag in beautiful_soup.find_all('li'):

			new_tag: Tag = beautiful_soup.new_tag('p')
			new_tag.string = f'- {" ".join(tag.stripped_strings)}'
			tag.replace_with(new_tag)

		# prefix `<control>` with their actual values
		# controls are used in E92F to @ or reference another E92F
		for tag in beautiful_soup.find_all('control'):
			tag.replace_with(tag.get_text())

		# find all lines that have just bold text and treat them as headers
		# e.g. `<p><b>Summary</b></p>`
		for tag in beautiful_soup.find_all(lambda tag: tag.name == 'p' and tag.b and not tag.find_all(lambda inner_tag: inner_tag != tag.b)):

			tag_text: str = tag.b.get_text().strip()

			if not tag_text:
				continue

			# if the bold text has any tags or has text outside of the bold, skip,
			# since there's a lower chance it's a header
			# e.g. `<p><b>Lorem</b> Ipsum</p>`
			if len(tag.b.find_all()) or tag.get_text() != tag_text:
				continue

			# if the text has too many words or first word is not capitalized,
			# there's a chance it's not a header
			# e.g. `to:\n…` (from `cm-peri-sw-guide.md`)
			if len(tag_text.split()) >= 6 or not tag_text[0].isupper():
				continue

			# e.g. `<p><b>Summary</b></p>` -> `<h5>Summary</h5>`
			new_tag: Tag = beautiful_soup.new_tag('h5')
			new_tag['id'] = tag.get('id')
			new_tag.string = tag_text
			tag.replace_with(new_tag)

		# convert table elements to Markdown format, which render much better than if we were to run just `.get_text()`
		for tag in beautiful_soup.find_all('table'):
			new_tag: Tag = beautiful_soup.new_tag('p')
			new_tag.string = cls.get_markdown_for_table(table=tag)
			tag.replace_with(new_tag)

		# convert bold to *bold* if include_style is set
		if include_style:

			header_tags_names: list[str] = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']			
			b_tags: list[Tag] = beautiful_soup.find_all('b')
			b_tags = [b_tag for b_tag in b_tags if not b_tag.find_parents(header_tags_names)]

			for tag in b_tags:

				tag_string: str = ' '.join(tag.strings).strip()
				tag.replace_with(f'**{tag_string}**')

		# get all header tags (e.g. h1, h2, h3, …)
		top_level_tags: list[Tag] = [tag for tag in beautiful_soup.find_all() if tag.name.startswith('h') and tag.name[-1].isnumeric()]

		# if the document has no headers, add an empty one so we can pick it up later
		# e.g. `<p>Lorem</p>` -> `<h1></h1> <p>Lorem</p>`
		if not top_level_tags:

			top_level_tag: Tag = beautiful_soup.new_tag('h1')
			beautiful_soup.insert(0, top_level_tag)
			top_level_tags = [top_level_tag]

		# find the lowest tag and treat it as top-level. most documents should be h1 (`1`)
		top_level: int = min(cls.get_tag_level(tag=tag) for tag in top_level_tags)

		# create a section for the first top-level section. most documents should have just one
		# unless they have multiple h1 tags
		if top_level > 0 and (first_tag := beautiful_soup.find(name=f'h{top_level}')):

			# if we have a sibling, it means we have another top-level tag (multiple `h1`s)
			root_section, next_tag = cls.get_section_for_tag(tag=first_tag, level=top_level, include_style=include_style)

			# set root_section (e.g. h1) as the parent of all first-level subsections (e.g. h2s)
			for subsection in root_section.subsections:
				subsection.parent = root_section

			# keep iterating over other top-level tags
			while next_tag:

				next_level: int = cls.get_tag_level(tag=next_tag)

				if next_level == top_level:

					section, next_tag = cls.get_section_for_tag(tag=next_tag, level=top_level, include_style=include_style)

					# set this top-level section (e.g. h2) as the parent of all second-level subsections (e.g. h3s)
					for subsection in section.subsections:
						subsection.parent = section

					# only append the subsection if it has content
					if section.title or section.content or section.subsections:
						root_section.append_subsection(subsection=section)

				else:
					next_tag = next_tag.find_next_sibling(name=f'h{top_level}')

			# if root section has no content with only one subsection, and that subsection has the same title,
			# treat the subsection as root
			# e.g. quip-apple.com/e. the title is `Creating Subscriptions` (or `None`) with no content,
			# and the subsection is also `Creating Subscriptions`
			if not root_section.content and len(root_section.subsections) == 1 and  \
				(not root_section.title or (root_section.subsections[0].title and root_section.subsections[0].title.lower() == root_section.title.lower())):
				root_section = root_section.subsections[0]

			return root_section

		return None

	@classmethod
	def get_tag_level(cls, tag: Tag) -> int:
		"""
		Returns the level of a given header tag.
		Can also be used to determine if a tag is a header (by checking level > 0)

		e.g. `<h1>` -> `1`
		@param tag(Tag): a header tag
		@return (int): the level of the tag
		"""
		return int(tag.name[1:]) if tag and tag.name.startswith('h') and tag.name[-1].isnumeric() else 0

	@classmethod
	def get_section_for_tag(cls, tag: Tag, level: int, include_style: bool) -> tuple[Section, Tag]:
		"""
		Creates and returns a `Section` for a given header tag (e.g. `h1`)

		@return (tuple): a section, the next header tag
		"""

		content: list[str] = []
		subsections: list[Section] = []
		external_id: str = tag.get('id')
		title: str = (tag.get_text().strip() or None) if cls.get_tag_level(tag=tag) > 0 else None

		# keep iterating over the next tag under this header/section
		next_tag: Tag = tag.find_next_sibling()

		while next_tag:

			next_level: int = cls.get_tag_level(tag=next_tag)

			# convert some `<p>` tags to headers
			# e.g. `<p>Summary:</p>`
			if next_tag.name == 'p':

				next_tag_text: str = next_tag.get_text().strip()

				# if the text has too many words, there's a chance it's not a header
				# - or if the tag has any nested tags, skip, since it's less likely that it's intended to be a header
				# - or if the first letter is not uppercase
				if next_tag_text and next_tag_text.endswith(':') and  \
				   len(next_tag_text.split()) <= 1 and not next_tag.find_all() and next_tag_text[0].isupper():

					tag_level: int = cls.get_tag_level(tag=tag)

					# if the current tag is not a header, treat the next tag as the top-level header (h1)
					if tag_level == 0:
						next_level = 1

					# h5 is the max we set/look for across the code
					# we won't increase the level past that
					elif tag_level == 5:
						next_level = 5

					# this means the current tag is `h1`…`h4`
					else:
						next_level += 1

					next_tag.name = f'h{next_level}'

			# - if this header (e.g. h2) has no content
			# - if the next tag is also header, same level (h2)
			# - and has too many words, treat the next tag as contents
			# 	of the current tag (e.g. E92F/e)
			elif next_level > 0 and level == next_level and not content:

				if len(next_tag.get_text().split()) >= 20:
					next_tag.name = 'p'

			if next_level and next_level > level:

				subsection, next_tag = cls.get_section_for_tag(tag=next_tag, level=next_level, include_style=include_style)

				# set this subsection as the parent of each nested subsection
				for nested_subsection in subsection.subsections:
					nested_subsection.parent = subsection

				# only append the subsection if it has content
				if subsection.title or subsection.content or subsection.subsections:
					subsections.append(subsection)

			elif next_tag.name in {'p', 'div'}:

				# accumulate content from all paragraphs in this section
				tag_text: str = next_tag.get_text()

				# if we're including styles, preserve spaces
				# this allows nested markdown lists
				# e.g. `- …\n    - …\n- …`
				if not include_style:
					tag_text = tag_text.strip()

				if (tag_text and tag_text not in content) or include_style:
					content.append(tag_text)

				next_tag = next_tag.find_next_sibling()

			elif next_tag.name == 'img':

				alt_text: str = next_tag.get('alt')

				if alt_text:
					content.append(alt_text)

				next_tag = next_tag.find_next_sibling()

			# reached a new header/section
			elif next_level and next_level <= level:

				# return the last sibling, so it can be a starting point for the next section
				return Section(title=title, external_id=external_id, content=content, subsections=subsections), next_tag

			else:
				next_tag = next_tag.find_next_sibling()

		return Section(title=title, external_id=external_id, content=content, subsections=subsections), None


if __name__ == '__main__':
	print(HTMLParser.get_section_for_html(content=''' '''.replace('\n', '').replace('\t', '')))