import re
import markdown2
from bs4 import BeautifulSoup, Tag, NavigableString

from interlinked.core.ai import Section
from interlinked.core.parsers.htmlparser import HTMLParser


class MarkdownParser(HTMLParser):
    """
    Converts Markdown documents to `Section` to use with `AI.learn(…)`
    """

    @classmethod
    def get_section_for_markdown(cls, content: str, remove_badges: bool = True) -> Section:
        """
        Parses a given a Markdown document, then returns a `Section`
        """

        # there's a bug in fenced-code-blocks where if there's a language right after ```,
        # it treats every variable in the code block as a new line
        # to workaround this issue, we remove the language from the code block
        # e.g. ````python\n…` -> ````\n…`
        content = re.sub(r'`{3,4}([A-Za-z0-9\-_]+)\n', '```\n', content, flags=re.MULTILINE)
    
        # remove badges (e.g. rio in github.pie.apple.com/Product-Security/sealtooth/blob/main/README.md)
        if remove_badges:
             content = re.sub(r'\[!\[.*?\]\(.*?\)\]\(.*?\)', '', content)

        # the extras prevent code from being treated as text
        # e.g. if a code block has `# Lorem`, it will get converted to `<h1>Lorem</h1>`
        # this option prevents that issue
        html: str = markdown2.markdown(content.strip(), extras={'fenced-code-blocks': True, 'middle-word-em': False})
        beautiful_soup: BeautifulSoup = BeautifulSoup(html, 'html.parser')

        # replace `strong` tags with `b` since HTMLParser treats (some) `b` tags
        # as headers
        for tag in beautiful_soup.find_all('strong'):
            tag.name = 'b'

        # unwrap divs so we can parse the inner tags (e.g. `div` with an `h1`, like the Interlinked readme)
        # unless the `div` only has text. We make this exception because HTMLParser expects
        # the html to contain text within either `p` or `div`
        for tag in beautiful_soup.find_all('div'):

            if not (len(tag.contents) == 1 and isinstance(tag.contents[0], NavigableString)):
                tag.unwrap()

        # replace `..` in URLs to other files
        # e.g. `../../README.md` ->  `README.md`
        for tag in beautiful_soup.find_all('a'):

            url: str = tag.get('href', '')
            url = re.sub(r'\.+/|', '', url)

            tag['href'] = url

        # add an `id` attr to every header with a direct link to the section
        for tag in beautiful_soup.find_all(['h1', 'h2', 'h3', 'h4', 'h5', 'h6']):
            tag['id'] = tag.text.strip().replace(' ', '-').replace(',', '').lower()

        return HTMLParser.get_section_for_html(content=str(beautiful_soup))


if __name__ == '__main__':

    with open('../workflows/knowledge/benchmarks/markdown/rpi/cm-peri-sw-guide.md') as file:

        for section in MarkdownParser.get_section_for_markdown(content=file.read()).get_all():
            print(section)