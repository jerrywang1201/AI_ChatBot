import logging
from docutils import nodes
from bs4 import BeautifulSoup, Tag
from docutils.parsers.rst import roles
from docutils.core import publish_parts
from docutils.utils import SystemMessage
from docutils.parsers.rst import Directive, directives

from interlinked.core.ai import Section
from interlinked.core.parsers.htmlparser import HTMLParser

logger = logging.getLogger(__name__)


class CustomDirective(Directive):

	option_spec: dict = {}
	has_content: bool = True
	optional_arguments: int = 0
	required_arguments: int = 0
	final_argument_whitespace: bool = False

	def run(self) -> list:
		return []


class TabsDirective(Directive):

	has_content = True
	
	def run(self):

		raw_node = nodes.raw('', '</div>', format='html')
		self.state.nested_parse(self.content, self.content_offset, raw_node)
		return [raw_node, nodes.raw('', '</div>', format='html')]


class CodeTabDirective(Directive):

	has_content = True
	required_arguments = 1
	optional_arguments = 1

	def run(self):

		# e.g. `py`
		language: str = self.arguments[0]

		# e.g. `Torch`
		title: str = self.arguments[1] if len(self.arguments) > 1 else None

		# the content of the tab itself (the code)
		content = '\n'.join(self.content)
		html: str = None

		if title:
			html = f'<h5>{title} ({language})</h5><div>```\n{content}\n```</div>'

		else:
			html = f'<div>```\n{content}\n```</div>'

		return [nodes.raw('', html, format='html')]


def text_role(role, rawtext, text, lineno, inliner, options={}, content=[]):
	return [nodes.Text(text)], []

def link_role(role, rawtext, text, lineno, inliner, options={}, content=[]):

	if '<' in text:

		text, link = text.split('</', 1) if '</' in text else text.split('<', 1)
		link: str = link.rstrip('>').strip()
		return [nodes.Text(f'[{text.strip()}](/{link})')], []

	return [nodes.Text(f'[{text}](/{text})')], []

def code_role(role, rawtext, text, lineno, inliner, options={}, content=[]):
	return [nodes.Text(f'`{text}`')], []


roles.register_local_role('ref', text_role)
roles.register_local_role('doc', link_role)
roles.register_local_role('py:mod', code_role)
roles.register_local_role('py:meth', code_role)
roles.register_local_role('py:func', code_role)
roles.register_local_role('py:data', code_role)
roles.register_local_role('guilabel', text_role)
roles.register_local_role('py:class', code_role)
directives.register_directive('tabs', TabsDirective)
directives.register_directive('toctree', CustomDirective)
directives.register_directive('contents', CustomDirective)
directives.register_directive('code-tab', CodeTabDirective)


class RestructuredParser(HTMLParser):
	"""
	Converts ReStructured files to `Section` to use with `AI.learn(â€¦)`
	"""

	@classmethod
	def get_section_for_restructured(cls, content: str) -> Section:
		"""
		Parses a given `rst` document, then returns a `Section`
		"""

		html_parts: dict[str, str] = []

		try:
			html_parts = publish_parts(source=content, writer_name='html', settings_overrides={'syntax_highlight': 'none'})

		except SystemMessage as message:

			logger.error('could not parse section')
			return Section()

		html: str = html_parts['html_body']
		beautiful_soup: BeautifulSoup = BeautifulSoup(html, 'html.parser')

		# by default, docutils wraps the content with a `document`
		# to match HTMLParser's structure, we'll unwrap so the first element is the header
		beautiful_soup.find('div', class_='document').unwrap()

		# headers and content is wrapped with `<div class="section"`
		# to match HTMLParser's structure, we'll unwrap the `div`
		{tag.unwrap() for tag in beautiful_soup.find_all('div', class_='section')}

		# replace `strong` tags with `b` since HTMLParser treats (some) `b` tags
		# as headers
		for tag in beautiful_soup.find_all('strong'):
			tag.name = 'b'

		# add an `id` attr to every header with a direct link to the section
		for tag in beautiful_soup.find_all(['h1', 'h2', 'h3', 'h4', 'h5', 'h6']):
			tag['id'] = tag.text.strip().replace(' ', '-').replace(',', '').lower()

		return HTMLParser.get_section_for_html(content=str(beautiful_soup))


if __name__ == '__main__':

	with open('../workflows/knowledge/benchmarks/rst/apple-internal/coreflow/benchmarking.rst') as file:

		for section_index, section in enumerate(RestructuredParser.get_section_for_restructured(content=file.read()).get_all()):
			print(f'{section_index}.', section.full_content)
