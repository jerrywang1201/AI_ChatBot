import re
import logging
from typing import Any
from urllib.parse import urlparse
from atlassian.errors import ApiPermissionError
from bs4 import BeautifulSoup, Tag, NavigableString

from interlinked.core.ai import Section
from interlinked.core.parsers.htmlparser import HTMLParser
from interlinked.core.clients.confluenceclient import ConfluenceClient, Page

logger = logging.getLogger(__name__)


class ConfluenceParser(HTMLParser):
    """
    Converts Confluence pages to `Section` to use with `AI.learn(â€¦)`

    TODO:
    - Fix a bug where list in confluence.sd.apple.com/display/REDTEAM/Red+Team+and+Secure+Design+Home+Page
      is rendered on the same line
    """

    @classmethod
    def get_section_for_html(cls, content: str, page: Page) -> Section:
        """
        Parses a given a Confluence document html, then returns a `Section`

        @param content(str): The HTML from a Confluence page (from `ConfluenceClient(â€¦).get_page(â€¦).html`)
        @param page(Page): The Confluence page itself, which is used for relative links (from `ConfluenceClient(â€¦).get_page(â€¦)`)
        """

        url_parsed: Any = urlparse(page.url) if page else None
        beautiful_soup: BeautifulSoup = BeautifulSoup(content, 'html.parser')

        # convert banners into a header with content
        # e.g. `confluence.sd.apple.com/pages/viewpage.action?pageId=2050673148`
        for tag in beautiful_soup.find_all('ac:structured-macro', attrs={'ac:name': 'banner'}):

            # banners are wrapped with `<p>` tags
            # unwrap, so we can parse the header/description in `HTMLParser`
            if tag.parent.name == 'p':
                tag.parent.unwrap()

            # the header parameter is sometimes after the description (but both are inside the banner)
            # convert them to `<h1>â€¦</h1><p>â€¦</p>`
            header_tag: Tag = tag.find('ac:parameter', attrs={'ac:name': 'title'})
            description_tag: Tag = tag.find('ac:parameter', attrs={'ac:name': 'description'})

            previous_tag: Tag = tag

            if header_tag:

                # TODO: is this the right header level?
                # should we determine which header level to choose based on the previous header?
                new_header_tag: Tag = beautiful_soup.new_tag('h1')
                new_header_tag.string = header_tag.text

                previous_tag.insert_before(new_header_tag)
                previous_tag = new_header_tag

            if description_tag:

                new_description_tag: Tag = beautiful_soup.new_tag('p')
                new_description_tag.append(BeautifulSoup(description_tag.get_text(separator='<br>'), 'html.parser'))

                previous_tag.insert_after(new_description_tag)

            # delete the banner tag since we replaced it with two tags:
            # header + description
            if previous_tag != tag:
                tag.decompose()

        # convert info boxes into paragraphs
        # e.g. "Contact us" in `confluence.sd.apple.com/pages/viewpage.action?pageId=2050673148`
        for tag in beautiful_soup.find_all('ac:structured-macro', attrs={'ac:name': 'info'}):

            # the header parameter is sometimes after the description (but both are inside the banner)
            # convert them to `<h1>â€¦</h1><p>â€¦</p>`
            header_tag: Tag = tag.find('ac:parameter', attrs={'ac:name': 'title'})

            # remove icon
            if icon_tag := tag.find('ac:parameter', attrs={'ac:name': 'icon'}):
                icon_tag.decompose()

            previous_tag: Tag = tag

            if header_tag:

                # TODO: is this the right header level?
                # should we determine which header level to choose based on the previous header?
                new_header_tag: Tag = beautiful_soup.new_tag('h1')
                new_header_tag.string = header_tag.text

                previous_tag.insert_before(new_header_tag)
                previous_tag = new_header_tag

            if tag.text:

                new_description_tag: Tag = beautiful_soup.new_tag('p')
                new_description_tag.append(BeautifulSoup(tag.get_text(separator='<br>'), 'html.parser'))

                previous_tag.insert_after(new_description_tag)

            # delete the banner tag since we replaced it with two tags:
            # header + description
            if previous_tag != tag:
                tag.decompose()

        # convert code to code blocks
        for tag in beautiful_soup.find_all('ac:structured-macro', attrs={'ac:name': 'code'}):

            # replace the code tag itself with `pre`, which will then be converted to ``` in `QuipSource`
            code_tag: Tag = tag.find('ac:plain-text-body')

            # if the code tag is empty
            if not code_tag:
                continue

            code_tag.name = 'pre'
            tag.replace_with(code_tag)

        # remove table of content (e.g. FAQ in confluence.sd.apple.com/display/SEAR/SEAR+Sponsorship+Program)
        # as the content is likely already answered in the same document
        for tag in beautiful_soup.find_all('ac:structured-macro', attrs={'ac:name': 'toc'}):
            tag.decompose()

        # remove links to inline comments (e.g. ðŸ“£ icon)
        # they only contain the icon + link, no text
        for tag in beautiful_soup.find_all('ac:structured-macro', attrs={'ac:name': 'talk'}):
            tag.decompose()

        # confluence wraps some elements with `ac:*`, unwrap so we can parse the elements directly
        # e.g. `<p>`
        for tag in beautiful_soup.find_all(['ac:layout', 'ac:layout-section', 'ac:layout-cell']):
            tag.unwrap()

        # remove strikethrough text as it is considered archived/deprecated
        for tag in beautiful_soup.find_all(['s']):
            tag.extract()

        # replace `ac:link` that point to another page in the space, with an actual `a`
        for tag in beautiful_soup.find_all(['ac:link']):

            if ri_page_tag := tag.find('ri:page'):

                # some links may have a custom space name. otherwise, use this page's space name
                space_name: str = ri_page_tag.get('ri:space-key') or page.space_name
                title: str = ri_page_tag.get('ri:content-title')

                a_tag: Tag = beautiful_soup.new_tag('a', href=f'https://{url_parsed.netloc}/display/{space_name}/{title.replace(" ", "+")}')
                a_tag.string = title

                tag.replace_with(a_tag)

            elif ri_user_tag := tag.find('ri:user'):

                # e.g. 9999999999ae99999999999ae9c99
                user_key: str = ri_user_tag.get('ri:userkey')

                try:
                    user_details: dict[str, Any] = ConfluenceClient.shared.get_user_details_by_userkey(userkey=user_key)

                    if user_details:

                        # replace with the person's actual name
                        span_tag: Tag = beautiful_soup.new_tag('span')
                        span_tag.string = user_details.get('displayName', 'Unknown Person')
                        tag.replace_with(span_tag)

                except ApiPermissionError as error:
                    logger.warning(f'skipping user tag. could not fetch person information ({user_key=})')

            elif ri_user_tag := tag.find('ri:attachment'):

                file_name: str = ri_user_tag.get('ri:filename')

                span_tag: Tag = beautiful_soup.new_tag('span')
                span_tag.string = file_name
                tag.replace_with(span_tag)

            elif tag.get('ac:anchor'):
                logger.warning('skipping anchor links. not implemented yet')

            # if there's a type we haven't implemented yet, raise an exception
            # ignore any tags that are empty
            elif len(list(tag.children)) > 0:
                logger.warning(f'skipping tag. not implemented yet ({tag})')
                # raise NotImplementedError(tag)

        # headers
        for tag in beautiful_soup.find_all(['h1', 'h2', 'h3', 'h4', 'h5', 'h6']):

            tag_text: str = tag.text.strip()

            # delete headers that are empty
            # Confluence docs can have many header tags with no content
            if not tag_text:

                tag.decompose()
                continue

        # convert tabs into headers with content
        for tag in beautiful_soup.find_all('ac:structured-macro', attrs={'ac:name': 'auitabs'}):

            for tab_tag in tag.find_all(attrs={'ac:name': 'auitabspage'}):
                cls.unwrap_rich_text_body_tag(tag=tab_tag, parent_tag=tag, page=page, beautiful_soup=beautiful_soup)

            # delete the containing tag now that we've replaced it with a header and body/content
            tag.decompose()

        # e.g. `> â€¦ and older` in `confluence.sd.apple.com/display/allOSSystemsInternals/Debugging+XPC+issues`
        for tag in beautiful_soup.find_all('ac:structured-macro', attrs={'ac:name': 'expand'}):

            # `or tag` handles nested tags where the first tag has no previous sibiling
            # e.g. the first item under `Shipped Releases` in confluence.sd.apple.com/pages/viewpage.action?pageId=23749558
            cls.unwrap_rich_text_body_tag(tag=tag, parent_tag=tag.previous_sibling or tag, level=6, page=page, beautiful_soup=beautiful_soup)
            tag.decompose()

        # e.g. `How to register ___ in ___` table in `seg-confluence.csg.apple.com/pages/viewpage.action?spaceKey=CAD&title=Snap+Design+FAQ`
        for tag in beautiful_soup.find_all('ac:structured-macro', attrs={'ac:name': 'multiexcerpt'}):

            for tab_tag in tag.find_all(attrs={'ac:name': 'panel'}):
                cls.unwrap_rich_text_body_tag(tag=tab_tag, parent_tag=tag, level=6, page=page, beautiful_soup=beautiful_soup)

            tag.decompose()

        # "Recent space activity" and "Space contributors" are always empty (they are loaded async)
        for tag in beautiful_soup.find_all('ac:structured-macro', attrs={'ac:name': 'recently-updated'}) +  \
                   beautiful_soup.find_all('ac:structured-macro', attrs={'ac:name': 'pagetreesearch'}) +  \
                   beautiful_soup.find_all('ac:structured-macro', attrs={'ac:name': 'contributors'}):
            tag.decompose()

        # e.g. `How to get ___ library read path` panel in `seg-confluence.csg.apple.com/pages/viewpage.action?spaceKey=CAD&title=Snap+Design+FAQ`
        for tag in beautiful_soup.find_all('ac:structured-macro', attrs={'ac:name': 'panel'}):

            cls.unwrap_rich_text_body_tag(tag=tag, parent_tag=tag, level=6, page=page, beautiful_soup=beautiful_soup)
            tag.decompose()

        # convert tasks to checkboxes
        for tag in beautiful_soup.find_all('ac:task-list'):
            tag.unwrap()

        # find any tables in root-level and wrap them with `<p>`
        # since HTMLParser requires elements to be in a `<p>` tag
        for tag in beautiful_soup.find_all('table'):
            tag.wrap(beautiful_soup.new_tag('p'))

        # e.g.
        # <ac:task>
        #    <ac:task-id>9</ac:task-id>
        #    <ac:task-status>complete</ac:task-status>
        #    <ac:task-body><span>Lorem</span></ac:task-body>
        # </ac:task>
        # to `- [X] Lorem`
        for tag in beautiful_soup.find_all(['ac:task']):

            is_task_complete: bool = (task_status_tag := tag.find('ac:task-status')) and task_status_tag.text == 'complete'
            task_text: str = None

            if task_body_tag := tag.find('ac:task-body'):
                task_text = task_body_tag.text

            if task_text:

                new_tag: Tag = beautiful_soup.new_tag('p')
                new_tag.string = f'- [{"X" if is_task_complete else ""}] {task_text}'
                tag.replace_with(new_tag)

        # unwrap blockquotes and keep the nested tags (e.g. `<p>`)
        # e.g. blockquote from confluence.sd.apple.com/display/allOSSystemsInternals/Debugging+XPC+issues
        for tag in beautiful_soup.find_all('blockquote'):
            tag.unwrap()

        # headers
        if page:

            for tag in beautiful_soup.find_all(['h1', 'h2', 'h3', 'h4', 'h5', 'h6']):

                # add an `id` attr to every header with a direct link to the section
                # e.g. `confluence.sd.apple.com/pages/viewpage.action?pageId=4231566308#SayHellotoSwiftCharts!-GettingStartedwithSwiftCharts`
                tag['id'] = f'{page.title.replace(" ", "")}-{tag.text.strip().replace(" ", "")}'

        return HTMLParser.get_section_for_html(content=str(beautiful_soup))

    @classmethod
    def unwrap_rich_text_body_tag(cls, tag: Tag, parent_tag: Tag, level: int = 1, page: Page = None, beautiful_soup: Any = None):
        """
        [Internal]
        Unwraps tags with `title` and `ac:rich-text-body` in a way that maintains structure

        e.g.
        - `> â€¦ and older` in `confluence.sd.apple.com/display/allOSSystemsInternals/Debugging+XPC+issues`
        -
        """

        # find the header and content
        header_tag: Tag = tag.find('ac:parameter', attrs={'ac:name': 'title'})
        body_tag: Tag = tag.find('ac:rich-text-body')

        if not body_tag:

            logger.error('could not find ac:rich-text-body')
            return

        previous_tag: Tag = parent_tag
        header_text: str = header_tag.text.strip() if header_tag else ''

        section: Section = cls.get_section_for_html(content=str('\n'.join([str(content_tag) for content_tag in body_tag.contents])), page=page)

        # add the header first (as long as the section doesn't have the same exact section title)
        # e.g. `FAQ` tab and `FAQ header inside of the tab in `confluence.sd.apple.com/display/SEAR/SEAR+Sponsorship+Program`
        if header_text and not (section.title and section.title.strip() == header_text.strip()):

            header_tag.name = f'h{level}'
            header_tag.string = header_tag.text.strip()

            parent_tag.insert_before(header_tag)
            previous_tag = header_tag

        # convert titles and subsections to `<h[1-6]>` tags
        previous_tag.insert_after(BeautifulSoup(section.to_html(), 'html.parser'))
        body_tag.decompose()


if __name__ == '__main__':

    page: Page = ConfluenceClient.shared.get_page(id='6281934474')
    print(ConfluenceParser.get_section_for_html(content=page.html, page=page))
