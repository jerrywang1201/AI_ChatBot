import logging
from typing import Any


from interlinked.core.utilities import Utilities
from interlinked.core.singleton import SingletonMeta
from interlinked.core.clients.basevectorstoreclient import BaseVectorStoreClient

logger = logging.getLogger(__name__)

try:
	from pymilvus import MilvusClient as BaseMilvusClient
	from pymilvus import DataType

except ModuleNotFoundError:

	logger.section('installing pymilvus')
	Utilities.install_package('pymilvus')

	from pymilvus import MilvusClient as BaseMilvusClient
	from pymilvus import DataType


class MilvusClient(BaseMilvusClient, BaseVectorStoreClient, metaclass=SingletonMeta):

	collection_names: set[str] = set()

	def __init__(self, *args, **kwargs):
		"""
		Initializes MilvusClient. See full arguments [here](https://github.com/milvus-io/pymilvus/blob/master/pymilvus/milvus_client/milvus_client.py)
		"""
		super(MilvusClient, self).__init__(*args, **kwargs)

	def create_collection(self, name: str, size: int) -> None:
		"""
		Creates an index if it doesn't exist already

		@param name(str): the name of the collection
		@param size(int): the vector size (varies based on model)
		"""
		super().create_collection(collection_name=name, dimension=size,
								  enable_dynamic_field=True, auto_id=True)

	def delete_collection(self, name: str) -> None:
		"""
		Deletes an index

		@param name(str): the name of the collection
		"""
		super().drop_collection(collection_name=name)

	def get_has_collection(self, name: str) -> bool:
		"""
		Returns whether a given index exists

		@param name(str): the name of the collection
		@return (bool): True if contain else False
		"""
		return super().has_collection(collection_name=name)

	def insert(self, embedding: list[float], payload: dict[str, Any], collection_name: str) -> list[int]:
		"""
		Adds an embedding to a given collection

		@param embedding(float): the embedding
		@param payload(str): the string/text content used to generate the embedding
		@param collection_name(str): the name of the collection to store the knowledge in
		@return (list[int]): List of the newly-generated IDs of the inserted entities
		"""
		data: dict[str, Any] = {'payload': payload, 'vector': embedding}
		return super().insert(collection_name=collection_name, data=data)['ids'][0]

	def upsert(self, embedding: list[float], payload: dict[str, Any], collection_name: str) -> str:
		"""
		Adds an embedding to a given index

		@param embedding(float): the embedding
		@param payload(str): the string/text content used to generate the embedding
		@param collection_name(str): the name of the index to store the knowledge in
		@return (str): the newly-generated ID of the point/embedding
		"""
		data: dict[str, Any] = {'payload': payload, 'vector': embedding}
		super().upsert(collection_name=collection_name, data=data)

	def update(self, id: str, embedding: list[float], payload: dict[str, Any], collection_name: str) -> None:
		"""
		Update an embedding to a given collection

		@param id(str): the name of the ID key to use for finding the document
		@param embedding(float): the embedding
		@param payload(str): the string/text content used to generate the embedding
		@param collection_name(str): the name of the index to store the knowledge in
		"""
		data: dict[str, Any] = {'payload': payload, 'vector': embedding}
		super().upsert(collection_name=collection_name, data=data)
