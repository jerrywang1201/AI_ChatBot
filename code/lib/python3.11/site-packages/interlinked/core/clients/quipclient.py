import logging
import requests
from time import sleep
from typing import Any, Optional
from datetime import datetime, timedelta
from requests.exceptions import HTTPError
from pydantic import BaseModel, Field, ConfigDict

from interlinked.core.config import Config
from interlinked.core.singleton import SingletonMeta

logger = logging.getLogger(__name__)


class Blob(BaseModel):

	name: str
	content: bytes


class Thread(BaseModel):

	# internal field
	model_config = ConfigDict(arbitrary_types_allowed=True)

	id: str
	html: str | None = None
	title: str | None = None
	created_at: datetime | None = None
	updated_at: datetime | None = None

	sharing: Optional[dict] = None
	expanded_user_ids: list[str] | None = None

	# document, spreadsheet
	type: str = 'document'

	# [internal]
	client: 'QuipClient' = Field(default=None, exclude=True)

	@property
	def is_shared(self) -> bool:
		"""
		Returns whether this thread is shared
		"""
		return self.sharing is not None

	""" Spreadsheet """

	def _get_sheet(self, index: int = None, name: str = None) -> 'Tag':
		"""
		[Internal]
		Returns the Tag of a specific Sheet within this Spreadsheet document

		Use `index` or `name`.

		@param index(int): (Optional) The index of the sheet to return
		@param name(str): (Optional) The name of the sheet to return
		@return (Tag): A `BeautifulSoup` tag
		"""

		if index is None and not name:
			index = 0

		if not self.html:
			thread: Thread = (self.client or QuipClient.shared).get_thread(id=self.id)
			self.html = thread.html

		from bs4 import BeautifulSoup
		beautiful_soup: BeautifulSoup = BeautifulSoup(self.html, 'html.parser')

		if index is not None:
			elements: list = list(beautiful_soup.find_all('table'))
			return elements[index]

		return beautiful_soup.select_one(f'table[title="{name}"]')

	""" Editing """

	def append(self, content: str | list, format: str = 'markdown', section_id: str = None,
			   sheet_index: int = None, sheet_name: str = None) -> None:
		"""
		Appends text or HTML to this `Thread`/document

		**How to use**
		```python

		from interlinked.core.clients.quipclient import QuipClient, Thread

		quip_client: QuipClient = QuipClient(token='…')
		thread: Thread = QuipClient.get_thread(id='ElRgAaaTbxmi')

		# for documents
		thread.append(content='New text')

		# for spreadsheets
		thread.append(content=['Column 1 value', 'Column 2 value', '…'])
		```

		@param content(str|list): The new HTML, Markdown, or list of strings (if this is a spreadsheet) to add
		@param format(str): (Optional) Any of `['markdown', 'html']`
		@param section_id(str): (Optional) (For documents) The ID of the section to modify (e.g. `temp:C…`)
		@param sheet_index(int): (Optional) (For Spreadsheets) The index of the sheet to append to (e.g. `1`)
		@param sheet_name(str): (Optional) (For Spreadsheets) The name of the sheet to append to (e.g. `Sheet2`)
		"""

		if self.type == 'spreadsheet':

			format = 'html'

			if not isinstance(content, list):
				content = [content]

			if not section_id:
				sheet: 'Tag' = self._get_sheet(index=sheet_index, name=sheet_name)
				section_id = sheet.find_all('tr')[-1].get('id')

			content = f'<tr>{"".join([f"<td>{row}</td>" for row in content])}</tr>'

		self._edit(content=content, location='AFTER_SECTION', format=format, section_id=section_id)

	def _edit(self, content: str, location: str = 'APPEND', format: str = 'markdown',
			  section_id: str = None) -> None:
		"""
		[Internal]
		Edits a Quip `Thread`/document

		**How to use**
		```python

		from interlinked.core.clients.quipclient import QuipClient

		quip_client: QuipClient = QuipClient(token='…')
		thread: Thread = QuipClient.get_thread(id='ElRgAaaTbxmi')
		thread._edit(content='New text', location='APPEND', section_id='temp:C:XFL33df5493cdd14040b06c86cda')
		```

		[Full Documentation ›](https://quip.com/dev/automation/documentation/current#operation/editDocument)

		@param thread_id(str): The ID of the Quip document (e.g. `ElRgAaaTbxmi` from `quip-apple.com/ElRgAaaTbxmi`)
		@param content(str): The new HTML or Markdown content to replace with
		@param location(str): (Optional) Any of `['APPEND', 'PREPEND', 'AFTER_SECTION', 'BEFORE_SECTION', 'REPLACE_SECTION', 'DELETE_SECTION']`
		@param format(str): (Optional) Any of `['markdown', 'html']`
		@param section_id(str): (Optional) The ID of the section to modify (e.g. `temp:C…`)
		"""

		LOCATIONS: dict[str, int] = {
			'APPEND': 0, 'PREPEND': 1,
			'AFTER_SECTION': 2, 'BEFORE_SECTION': 3,
			'REPLACE_SECTION': 4, 'DELETE_SECTION': 5
		}

		post_data: dict[str, Any] = {

			'format': format,
			'content': content,
			'thread_id': self.id,
			'location': LOCATIONS[location],
		}

		if section_id:
			post_data['section_id'] = section_id.replace(';', '_') if section_id else section_id

		(self.client or QuipClient.shared)._fetch_json('threads/edit-document', post_data=post_data)


class Folder(BaseModel):
	# internal field
	model_config = ConfigDict(arbitrary_types_allowed=True)

	id: str
	title: str
	color: str | None = None

	children_raw: list[dict[str, str | int | bool]]

	client: 'QuipClient' = None

	@property
	def children(self) -> list[Any]:
		"""
		Returns a list of folders/threads
		"""

		children: list[Folder | Thread] = []

		for child_raw in self.children_raw:

			# child_raw is structured like this: `{'thread_id': '…'}` or `{'folder_id': '…'}`
			# get either `thread_id` or `folder_id` and ignore any other key (e.g. `{…, 'restricted': True}`)
			child_type, child_id = next(((key, value) for key, value in child_raw.items() if key in {'thread_id', 'folder_id'}), (None, None))

			# skip restricted children
			if child_raw.get('restricted'):
				logger.info(f'skipping restricted {child_type.removesuffix("_id")}… (id={child_id})')
				continue

			if child_type == 'folder_id':
				children.append((self.client or QuipClient.shared).get_folder(id=child_id))

			else:
				children.append((self.client or QuipClient.shared).get_thread(id=child_id))

		return children

	@property
	def flattened_threads(self) -> list[Thread]:
		"""
		Returns a list of all threads in this folder and nested folders
		"""

		threads: list[Thread] = []

		for child in self.children:

			if isinstance(child, Folder):
				threads += child.flattened_threads
				continue

			threads.append(child)

		return threads


class QuipClient(metaclass=SingletonMeta):
	BASE_URL: str = 'https://platform.quip-apple.com'

	def __init__(self, token: str = None, base_url: str = None):
		"""
		Initializes this client

		@param token(str): your Quip access token (can be obtained from quip-apple.com/dev/token)
		@param base_url(str): (optional) the Quip hostname
		"""

		self.token = token or Config.current.QUIP_ACCESS_TOKEN
		self.base_url = base_url or self.BASE_URL

	@SingletonMeta.Shared
	def shared(cls) -> 'QuipClient':
		return cls(shared=True)

	def get_has_access(self, id: str, dsid: int) -> bool:
		"""
		Checks if a given DSID has access to a Quip document/folder

		@param id(str): the ID of the Quip document/folder
		@param dsid(str): the DSID of the person
		"""

		from interlinked.core.clients.appledirectoryclient import AppleDirectoryClient

		thread: Thread = None

		try:
			thread = self.get_thread(id=id)

		except HTTPError as error:

			if error.response.status_code in {401, 403}:
				logger.error(f'no access to thread to check access ({id=})')
				return False

			logger.error(f'could not check access to thread ({id=})')
			raise error

		if thread.is_shared:
			return True

		# get the user's email
		email: str = AppleDirectoryClient.shared.get_user_by_dsid(dsid=dsid).mail.value

		users: list[dict] = self._fetch_json('users/', post_data={'ids': ','.join(thread.expanded_user_ids)})

		# if any of the users matches the email, then the person has access
		users_emails: list[str] = []

		for user in users.values():

			for user_email in user.get('emails', []):

				# quip's API sometimes returns a str and sometimes a dict
				if isinstance(user_email, str):
					users_emails.append(user_email)

				else:
					users_emails.append(user_email.get('address'))

		if email in users_emails:
			return True

		return False

	def get_is_folder(self, id: str) -> bool:
		"""
		Checks if a given DSID has access to a Quip document/folder

		@param id(str): the ID of the Quip document/folder
		@param dsid(str): the DSID of the person
		"""

		try:
			self.get_folder(id=id)

		except Exception as exception:

			if 'Invalid folder id' in str(exception):
				return False

			else:
				raise exception

		return True

	def get_folder(self, id: str) -> Folder:
		"""
		Returns a Quip `Folder`

		@param id(str): the ID of the folder (e.g. `0njxOgk8b7xu`)
		@return (Folder): a folder
		"""

		folder: dict[str, Any] = self._fetch_json(f'folders/{id}')
		folder['id'] = folder['folder']['id']
		folder['title'] = folder['folder']['title']
		folder['color'] = folder['folder'].get('color')
		del folder['folder']

		folder['children_raw'] = folder['children']
		del folder['children']

		return Folder(**folder, client=self)

	def get_thread(self, id: str) -> Thread:
		"""
		Returns a Quip `Thread`

		@param id(str): the ID of the thread (e.g. `0njxOgk8b7xu`)
		@return (Thread): a thread
		"""

		thread: dict[str, Any] = self._fetch_json(f'threads/{id}')

		thread['id'] = thread['thread']['id']
		thread['type'] = thread['thread']['type']
		thread['title'] = thread['thread']['title']
		thread['sharing'] = thread['thread'].get('sharing')
		thread['expanded_user_ids'] = thread['expanded_user_ids']
		thread['created_at'] = datetime.fromtimestamp(thread['thread']['created_usec'] / 1_000_000.0)
		thread['updated_at'] = datetime.fromtimestamp(thread['thread']['updated_usec'] / 1_000_000.0)

		del thread['thread']

		return Thread(**thread, client=self)

	def create_thread(self, title: str, content: str, member_ids: list[str] = None,
					  format: str = 'markdown', type: str = 'document') -> Thread:
		"""
		Creates a Quip `Thread`/document, or spreadsheet

		@param title(str): the title of the thread
		@param content(str): the content of the thread
		@param member_ids(list): A list of Quip person IDs or folder IDs to add the `Thread` to
		@param format(str): (Optional) The format of the thread (html or markdown)
		@param type(str): (Optional) Any of `['document', `spreadsheet`]`
		@return (Thread): a thread
		"""

		post_data: dict[str, Any] = {

			'type': type,
			'title': title,
			'format': format,
			'content': content,
			'member_ids': ', '.join(member_ids) if member_ids else None
		}
		thread: dict[str, Any] = self._fetch_json('threads/new-document', post_data=post_data)

		thread['id'] = thread['thread']['id']
		thread['type'] = thread['thread']['type']
		thread['title'] = thread['thread']['title']
		thread['sharing'] = thread['thread'].get('sharing')
		thread['expanded_user_ids'] = thread['expanded_user_ids']
		thread['created_at'] = datetime.fromtimestamp(thread['thread']['created_usec'] / 1_000_000.0)
		thread['updated_at'] = datetime.fromtimestamp(thread['thread']['updated_usec'] / 1_000_000.0)

		del thread['thread']

		return Thread(**thread, client=self)

	def find_thread(self, query: str, limit: int = 10, only_match_titles: bool = False) -> list[Thread]:
		"""
		Finds a Quip `Thread`/document

		@param query(str): the search query
		@param limit(int): (optional) limit the number of results
		@param only_match_titles(bool): (optional) limit search to titles for faster search
		@return (list): a list of threads
		"""

		params: dict[str, Any] = {
			'query': query,
			'limit': limit,
			'only_match_titles': only_match_titles,
		}
		raw_threads: list[dict] = self._fetch_json('threads/search', params=params)

		threads: list[Thread] = []

		for raw_thread in raw_threads:
			raw_thread['id'] = raw_thread['thread']['id']
			raw_thread['type'] = raw_thread['thread']['type']
			raw_thread['title'] = raw_thread['thread']['title']
			raw_thread['sharing'] = raw_thread['thread'].get('sharing')
			raw_thread['expanded_user_ids'] = raw_thread.get('expanded_user_ids')
			raw_thread['created_at'] = datetime.fromtimestamp(raw_thread['thread']['created_usec'] / 1_000_000.0)
			raw_thread['updated_at'] = datetime.fromtimestamp(raw_thread['thread']['updated_usec'] / 1_000_000.0)

			del raw_thread['thread']
			threads.append(Thread(**raw_thread, client=self))

		return threads

	def get_recent_threads(self, count: int = 3, max_updated_usec: int = None, include_hidden: bool = False) -> Thread:
		"""
		Returns recent Quip `Thread`(s), similar to the Quip website and app

		@param count(int): Maximum number of `Thread` to return
		@param include_hidden(bool): Include hidden threads
		@return (list): a list of `Thread`
		"""

		params: dict[str, Any] = {

			'count': count,
			'include_hidden': include_hidden,
			'max_updated_usec': max_updated_usec or (datetime.now() - timedelta(hours=12)).timestamp()
		}

		raw_threads: list[dict] = self._fetch_json(f'threads/recent', params=params)
		threads: list[Thread] = []

		for thread in raw_threads.values():
			thread['id'] = thread['thread']['id']
			thread['type'] = thread['thread']['type']
			thread['title'] = thread['thread']['title']
			thread['sharing'] = thread['thread'].get('sharing')
			thread['expanded_user_ids'] = thread['expanded_user_ids']
			thread['created_at'] = datetime.fromtimestamp(thread['thread']['created_usec'] / 1_000_000.0)
			thread['updated_at'] = datetime.fromtimestamp(thread['thread']['updated_usec'] / 1_000_000.0)

			del thread['thread']

			threads.append(Thread(**thread, client=self))

		return threads

	def get_blob(self, thread_id: str, blob_id: str) -> Blob:
		"""
		Downloads a file from a thread
		"""

		headers: dict[str, str] = {'Authorization': f'Bearer {self.token}'}
		proxies: dict[str, str] = {'https': Config.current.PROXY_URL} if Config.current.PROXY_URL else {}

		url: str = f'{thread_id}/{blob_id}' if '/' not in blob_id else blob_id
		response = requests.get(f'{self.base_url}/1/blob/{url}',
								headers=headers, proxies=proxies)

		if not response.ok:
			logger.error(response.text)

		response.raise_for_status()

		content_disposition: str = response.headers.get('Content-Disposition')
		file_name: str = content_disposition.split('"')[-2] if content_disposition else None

		return Blob(name=file_name, content=response.content)

	def _fetch_json(self, path: str, post_data: dict[str, Any] = None, params: dict[str, Any] = None,
					_retry_count: int = 0, **args) -> dict[str, Any]:
		"""
		Overrides Quip's `_fetch_json` to add support for proxy
		"""

		if post_data:

			post_data = {key: value for key, value in post_data.items() if value is not None or isinstance(value, int)}

			# quip requires some values to be encoded
			for key, value in post_data.items():

				if isinstance(value, int):
					post_data[key] = str(value)

				elif isinstance(value, bytes):
					continue

				else:
					post_data[key] = value.encode('utf-8')

		headers: dict[str, str] = {}
		proxies: dict[str, str] = {'https': Config.current.PROXY_URL} if Config.current.PROXY_URL else {}

		if self.token:
			headers['Authorization'] = f'Bearer {self.token}'

		try:
			response = requests.request('GET' if not post_data else 'POST', f'{self.base_url}/1/{path}',
										data=post_data, params=params, headers=headers, proxies=proxies, timeout=30)

		except (requests.exceptions.ReadTimeout, requests.exceptions.ConnectionError) as exception:

			if _retry_count <= 4:

				logger.warning('request timed out. trying again…')

				sleep(_retry_count + 2)
				return self._fetch_json(path=path, post_data=post_data, params=params, _retry_count=_retry_count + 1, **args)

			else:

				logger.error('request timed out too many times')
				raise exception

		if response.status_code == 400:
			raise Exception(response.json())

		elif response.status_code == 429:

			logger.warning('rate limit. trying again…')
			sleep(_retry_count + 60)
			return self._fetch_json(path=path, post_data=post_data, params=params, _retry_count=_retry_count + 1, **args)

		elif response.status_code in {500, 502, 503, 504}:

			logger.warning(f'request returned {response.status_code}. trying again…')
			sleep(_retry_count + 2)
			return self._fetch_json(path=path, post_data=post_data, params=params, _retry_count=_retry_count + 1, **args)

		response.raise_for_status()
		return response.json()


if __name__ == '__main__':
	print(QuipClient.shared.get_folder(id='3zRrOYXTTSiR').children)
	print(QuipClient.shared.get_thread(id='bSEjA6pLOfvs'))
	print(QuipClient.shared.get_has_access(id='Xb3bABDwjmv0', dsid=2319733545))
	print(QuipClient.shared.get_blob(thread_id='JUP9AARzKjC', blob_id='fzLysPcPgycd8TPGK6HdTw'))
