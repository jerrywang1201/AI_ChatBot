import asyncio
from contextlib import AsyncExitStack
from typing import Any, Optional, TYPE_CHECKING

if TYPE_CHECKING:
    from interlinked.core.applet import Applet

from interlinked.core.utilities import Utilities

try:
    from mcp.types import CallToolResult
    from mcp.client.sse import sse_client
    from mcp.server.fastmcp import FastMCP
    from mcp.client.stdio import stdio_client
    from mcp import ClientSession, StdioServerParameters

except (ModuleNotFoundError, ImportError):

    Utilities.install_package('mcp')

    from mcp.types import CallToolResult
    from mcp.client.sse import sse_client
    from mcp.server.fastmcp import FastMCP
    from mcp.client.stdio import stdio_client
    from mcp import ClientSession, StdioServerParameters


class MCPClient:
    """
    [Internal/Preview]
    Internal client for calling tools in MCP servers
    """

    url: str = None
    auth: dict[str, dict] = None
    command: str = None
    arguments: list[str] = None
    environment_variables: dict[str, Any] = None

    is_connected: bool = False
    session: ClientSession = None
    exit_stack: AsyncExitStack = None

    AUTH_METHODS: set[str] = {'A3'}

    def __init__(self, command: str = None, arguments: list[str] = None,
                 environment_variables: dict[str, Any] = None, url: str = None,
                 auth: dict = None):

        self.url = url
        self.auth = auth
        self.command = command
        self.arguments = arguments
        self.exit_stack = AsyncExitStack()
        self.environment_variables = environment_variables

        # create a single event loop for all sync methods
        self._loop = asyncio.new_event_loop()

    """ Connection """

    async def connect(self) -> None:
        """
        Connects to an MCP server using either stdio or SSE
        """

        # connect using SSE client
        if self.url:

            auth_headers = self.get_auth_headers(self.auth)
            streams = await self.exit_stack.enter_async_context(sse_client(self.url, headers=auth_headers))
            self.session = await self.exit_stack.enter_async_context(ClientSession(streams[0], streams[1]))

        # connect using stdio client
        else:

            server_params = StdioServerParameters(command=self.command, args=self.arguments, env=self.environment_variables)
            stdio_transport = await self.exit_stack.enter_async_context(stdio_client(server_params))

            self.stdio, self.write = stdio_transport
            self.session = await self.exit_stack.enter_async_context(ClientSession(self.stdio, self.write))

        await self.session.initialize()
        self.is_connected = True

    async def disconnect(self) -> None:
        """
        Clean up resources
        """
        self.is_connected = False
        await self.exit_stack.aclose()

    """ Tools """

    async def get_tools(self) -> 'Tool':
        """
        Returns a list of available tools from the server
        """
        return (await self.session.list_tools()).tools

    async def run_tool(self, name: str, arguments: dict[str, Any]) -> CallToolResult:
        """
        Runs an MCP tool, then returns the result
        """
        return await self.session.call_tool(name, arguments)

    """ Resources """

    async def get_resources(self) -> 'Tool':
        """
        Returns a list of available resources from the server
        """
        return (await self.session.list_resources()).resources

    async def get_resource(self, path: str) -> tuple[Any, str]:
        """
        Returns a Resource
        """
        return (await self.session.read_resource(path))

    """ Prompts """

    async def get_prompts(self) -> 'Tool':
        """
        Returns a list of available prompts from the server
        """
        return (await self.session.list_prompts()).prompts

    """ Synchronous """

    def connect_sync(self) -> None:
        """
        Connects to an MCP server
        """
        asyncio.set_event_loop(self._loop)
        self._loop.run_until_complete(self.connect())

    def disconnect_sync(self) -> None:
        """
        Clean up resources
        """
        asyncio.set_event_loop(self._loop)
        self._loop.run_until_complete(self.disconnect())
        self._loop.close()

    def get_tools_sync(self) -> 'Tool':
        """
        Returns a list of available tools from the server
        """
        asyncio.set_event_loop(self._loop)
        return self._loop.run_until_complete(self.get_tools())

    def run_tool_sync(self, name: str, arguments: dict[str, Any]) -> CallToolResult:
        """
        Runs an MCP tool
        """
        asyncio.set_event_loop(self._loop)
        return self._loop.run_until_complete(self.run_tool(name, arguments))

    def get_resources_sync(self) -> 'Tool':
        """
        Returns a list of available resources from the server
        """
        asyncio.set_event_loop(self._loop)
        return self._loop.run_until_complete(self.get_resources())

    def get_resource_sync(self, path: str) -> tuple[Any, str]:
        """
        Returns a Resource
        """
        asyncio.set_event_loop(self._loop)
        return self._loop.run_until_complete(self.get_resource(path))

    def get_prompts_sync(self) -> 'Tool':
        """
        Returns a list of available prompts from the server
        """
        asyncio.set_event_loop(self._loop)
        return self._loop.run_until_complete(self.get_prompts())


    """ Context Manager Support """

    async def __aenter__(self):
        """Async context manager entry"""

        await self.connect()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit"""

        await self.disconnect()

    def __enter__(self):
        """Sync context manager entry"""

        self.connect_sync()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Sync context manager exit"""

        self.disconnect_sync()


    """ Factory Methods """

    @classmethod
    def from_applet(cls, applet: 'Applet', transport: str = 'stdio', **kwargs) -> 'MCPClient':
        """
        Factory method to create MCPClient from Applet

        @param applet: The Applet instance to create client for
        @param transport: Transport type ('stdio' or 'sse')
        @param kwargs: Additional configuration options
        @return: Configured MCPClient instance
        """

        import os
        import json

        current_directory_path: str = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
        server_path = os.path.join(current_directory_path, 'interlinked', 'ui', 'mcp_server.py')
        server_path = os.path.normpath(server_path)

        env_vars = {'BUNDLE_ID': applet.bundle_id}

        if applet.api_key:
            env_vars['API_KEY'] = applet.api_key

        if applet.base_url:
            env_vars['BASE_URL'] = applet.base_url

        if kwargs:
            env_vars['FUNCTION_KWARGS'] = json.dumps(kwargs)

        if transport == 'stdio':
            return cls(command='python3', arguments=[server_path], environment_variables=env_vars)

        elif transport == 'sse':

            env_vars.update({
                'MCP_TRANSPORT': 'sse',
                'HOST': kwargs.get('host', '0.0.0.0'),
                'PORT': str(kwargs.get('port', 3000))
            })

            return cls(command='python3', arguments=[server_path, '--sse'], environment_variables=env_vars)

        else:
            raise ValueError(f'Unsupported transport: {transport}')

    def get_auth_headers(self, auth_config: dict) -> Optional[dict[str, str]]:
        """
        Get auth headers based on defined config.
        Currently only one "auth method" (e.g. "A3") is expected, but this can be extended later if needed.
        """

        if not auth_config:
            return None

        auth_method = list(auth_config.keys())[0]

        if auth_method not in self.AUTH_METHODS:
            raise ValueError(f'Unrecognized auth method for MCPClient: {auth_method}')

        auth_config = auth_config[auth_method]

        if auth_method == 'A3':

            app_id = auth_config.get('appId')
            app_pw = auth_config.get('appPassword')
            expected_a3_configs = {'otherApp', 'context', 'app_id_header_name', 'token_header_name'}

            try:

                other_app_id = auth_config['otherApp']
                context_str = auth_config['context']
                app_id_header_name = auth_config['app_id_header_name']
                token_header_name = auth_config['token_header_name']
                context_header_name = auth_config.get('context_header_name')

            except KeyError:
                raise ValueError(f'MCPClient missing required A3 config(s): {expected_a3_configs - auth_config.keys()}')

            token = Utilities.get_a3_token(context_str, other_app_id, app_id, app_pw)
            a3_headers = {
                app_id_header_name: str(app_id),
                token_header_name: token
            }

            if context_header_name:
                a3_headers[context_header_name] = context_str

            return a3_headers


def main():

    client = MCPClient(command='python3', arguments=['/private/tmp/weather/weather.py'])
    client.connect_sync()
    mcp_tools = client.get_tools_sync()
    print(mcp_tools)
    print(client.run_tool_sync(name=mcp_tools[0].name, arguments={'state': 'CA'}))


if __name__ == '__main__':
    main()
