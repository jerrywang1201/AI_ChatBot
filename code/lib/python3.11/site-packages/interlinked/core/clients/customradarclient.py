import logging
from time import sleep
from typing import Any
from radarclient import RadarClient as BaseRadarClient
from radarclient.exceptions import ObjectNotFoundException
from radarclient import ClientSystemIdentifier, AuthenticationStrategyAppToApp,  \
                        AuthenticationStrategySPNego, RetryPolicy, Radar, Component,  \
                        RateLimitPolicy, KeywordAssociation, Attachment as BaseAttachment,  \
                        response_code_is_success

from interlinked.core.config import Config
from interlinked.core.utilities import Utilities
from interlinked.core.singleton import SingletonMeta
from interlinked.core.classes import ExternalItem, RadarPlaceholder

logger = logging.getLogger(__name__)


class Attachment(BaseAttachment):
    """
    Radar attachment from a locally stored URL
    (instead of a dynamically generated URL)
    """

    def __init__(self, file_name: str, file_id: str, *args, **kwargs):

        super(Attachment, self).__init__(*args, **kwargs)

        # keep RadarClient's naming convention
        self.fileName = file_name
        self.fileId = file_id

    def configure_download_request(self, request):

        super(Attachment, self).configure_download_request(request)
        request.add_header('X-Attachment-File-Key', self.fileId)


class RadarClient(BaseRadarClient, metaclass=SingletonMeta):
    """
    Interact with Radar
    """

    SYSTEM_IDENTIFIER: ClientSystemIdentifier = ClientSystemIdentifier('Interlinked', '1.0')
    RADAR_ADDITIONAL_FIELDS: list[str] = ['lastModifiedAt', 'duplicateOfProblemID', 'history', 'componentID']

    authentication_strategy: Any = None

    def __init__(self):

        if Config.current.is_development:
            self.authentication_strategy = AuthenticationStrategySPNego()

        elif Config.current.RADAR_IDMS_APP_CONTEXT:

            self.authentication_strategy = AuthenticationStrategyAppToApp(
                application_id=Config.current.IDMS_APP_ID,
                application_password=Config.current.IDMS_APP_PASSWORD,
                radar_app_to_app_context=Config.current.RADAR_IDMS_APP_CONTEXT,
                person_dsid=Config.current.DSID)

        if self.authentication_strategy:
            super(RadarClient, self).__init__(self.authentication_strategy, RadarClient.SYSTEM_IDENTIFIER,
                                              retry_policy=RetryPolicy(), rate_limit_policy=RateLimitPolicy())

        else:
            logger.critical('did not initialize Radar integration')

    @SingletonMeta.Shared
    def shared(cls) -> 'RadarClient':
        return cls(shared=True)

    """ Radars """

    def get_item_for_radar_id(self, id: int | str, fetch: bool = True, additional_fields: list[str] = None) -> ExternalItem:
        """
        Returns an `ExternalItem` for a given ID
        """

        if isinstance(id, str):
            id = int(id.rsplit('/', 1)[-1])

        if not fetch:
            radar: RadarPlaceholder = RadarPlaceholder({'id': id, 'client': self})

        else:

            if not additional_fields:
                additional_fields = self.RADAR_ADDITIONAL_FIELDS

            radar: Radar = self.radar_for_id(id, additional_fields=additional_fields)

            if not radar:
                raise ObjectNotFoundException(404, radar, 'Not Found')

        return ExternalItem(item=radar, type=ExternalItem.TYPE_RADAR)

    def get_items_for_criteria(self, criteria: dict[str, Any], **kwargs) -> list[ExternalItem]:
        """
        Returns a list of `ExternalItem` for a given criteria

        @param criteria(dict): Check `radarclient` for this
        @param fetch(bool): if False, the items won't be fetched (useful when you only need the item to update it)
        @param extra_queries(bool): get additional fields and queries
        @param only_fields(list): only fetch given fields (significantly reduces time)
        @return (list): a list of ExternalItem or None
        """

        return [ExternalItem(item=radar, type=ExternalItem.TYPE_RADAR) for radar in self.find_radars(request_data=criteria, **kwargs)]

    def get_items_for_query_id(self, query_id: int, additional_fields: list[str] = None) -> list[ExternalItem]:
        """
        Returns a list of `ExternalItem` for a given radar query ID
        """

        if not additional_fields:
            additional_fields = ['lastModifiedAt']

        if isinstance(query_id, str):
            query_id = int(query_id.rsplit('/', 1)[-1])

        return [ExternalItem(item=radar, type=ExternalItem.TYPE_RADAR) for radar in self.radars_for_query(query_id=query_id, additional_fields=additional_fields)]

    def create_item(self, title: str, description: str, component_id: int, classification: str = 'Task', reproducible: str = 'Not Applicable') -> ExternalItem:
        """
        Creates a new Radar

        @param title(str): title of the radar
        @param description(str): description of the radar
        @param component_id(int): The id of the radar component to assign radar to. (Use get_components_by_name to get component Id)
        @param classification(str): Classification of the radar. Any of the following: [Security, Crash/Hang/Data Loss, Power, Performance, UI/Usability, Serious Bug, Feature (New), Enhancement, Task, Other Bug]
        @param reproducible(str): The reproducibility of the radar. Any of the following: [Always, Sometimes, Rarely, Unable, I Didnâ€™t Try, Not Applicable]
        """

        radar_data = { 'title': title, 'description': description, 'classification': classification, 'reproducible': reproducible }

        if component_id:
            radar_data['component'] = { 'id': component_id }

        else:
            logger.error(f'Component is mandatory for creating a problem.', exc_info=True)
            return None

        try:
            return self.create_radar(request_data=radar_data)

        except TimeoutError as error:
            return self.create_radar(request_data=radar_data)

    """ Components """

    @Utilities.dynamic
    def get_components_by_name(self, name: str, version: str = None, _retry_count: int = 0) -> list[Component]:
        """
        Finds a radar component by a given name/query

        @param name(str): name (can be partial)
        @param version(str): version (can be partial + optional)
        @return (list): a list of Component(s)
        """

        request_data = {'name': name, 'isClosed': False}

        if version:
            request_data['version'] = version

        try:
            return self.find_components(request_data=request_data,
    									additional_fields=['isDropBox', 'isRestricted', 'isClosed'])
        except TimeoutError as error:

            return self.find_components(request_data=request_data,
                                        additional_fields=['isDropBox', 'isRestricted', 'isClosed'])

    """ Permissions """

    def get_permissions_for(self, dsid: int, ids: list[str]) -> dict[str, list]:
        """
        Returns a dictionary of permissions for a given DSID

        @param dsid(int): a person's DSID
        @param ids(list): a list of radar IDs (numeric part-only as str; without rdar://)
        @return (dict): access type dict of the following format:

        ```
        {
            'read': ['123456789', ...],
            'read_write': ['123456789', ...],
            'no_access': ['123456789', ...]
        }
        ```

        The `read` key translates to Radar's `Read-only` value
        The `read_write` key translates to Radar's `Super User`, `Assignable`, `Owner`, `Administrator`, `Reassignable (Full)`, and `Reassignable (Tree-limited)` values
        The `no_access` key translates to Radar's `No Privilege` values
        """

        url = self.webservice_url_for_path_components('security', dsid, 'problems', ','.join(ids))

        request = self.request_for_json_url(url=url)

        response_status, response_data = self.send_request(request)

        if not response_code_is_success(response_status):

            logger.error(f'get_radar_access_permissions_for failed. response_data: {response_data}', exc_info=True)
            return None

        # create the return dict
        read: list = []
        read_write: list = []
        no_access: list = []

        for result in response_data:

            id: int = result.get('problemID', '')
            privilege: str = result.get('privilege')

            if privilege in ['Read-only']:
                read.append(id)

            elif privilege in ['Super User', 'Assignable', 'Owner', 'Administrator', 'Reassignable (Full)', 'Reassignable (Tree-limited)']:
                read_write.append(id)

            elif privilege == 'No Privilege':
                no_access.append(id)

        return_dict: dict = {

            'read': read,
            'read_write': read_write,
            'no_access': no_access,
        }

        return return_dict

    def get_accessible_ids_for(self, dsid: int, ids: list[str]) -> list[str]:
        """
        A shortcut for `get_permissions_for` that only returns external IDs
        that are accessibly by a DSID

        @param dsid(int): a person's DSID
        @param ids(list): a list of radar IDs (numeric part-only as str; without rdar://)
        @return (list)
        """

        if not ids:
            return []

        return_list: list[str] = []
        ids = list(set([str(id).split('/')[-1] for id in ids]))

        for _ids in Utilities.split_by_chunks(full_list=ids, chunk_size=300):

            permissions_dict: dict[str: list] = self.get_permissions_for(dsid=dsid, ids=_ids)
            return_list += permissions_dict.get('read', []) + permissions_dict.get('read_write', [])

        return return_list


if __name__ == '__main__':
    print(RadarClient.shared.get_item_for_radar_id(id='1234'))