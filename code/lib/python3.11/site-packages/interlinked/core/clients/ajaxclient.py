import re
import json
import base64
import random
import logging
import requests
from typing import Any
from time import sleep, time
from collections.abc import Iterator
from requests.adapters import HTTPAdapter, Retry

from interlinked.core.tool import Tool
from interlinked.core.config import Config
from interlinked.core.utilities import Utilities
from interlinked.core.clients.baseaiclient import BaseAIClient, AIModel, AIClientResponse, ToolCall, File

logger = logging.getLogger(__name__)


class AJAXClient(BaseAIClient):
	"""
	Client to interact with Ajax/AFM
	"""

	APP_ID: int = 191000

	ROLE_USER: str = 'ROLE_USER'
	ROLE_TOOL: str = 'ROLE_TOOL'
	ROLE_SYSTEM: str = 'ROLE_SYSTEM'
	ROLE_ASSISTANT: str = 'ROLE_ASSISTANT'

	# how long, in seconds, this client should wait for responses
	TIMEOUT: int = 300

	# the maximum of times to retry if there are network errors
	MAX_RETRIES: int = 4

	# [Advanced] how long the A3 token should last, in milliseconds
	A3_TOKEN_EXPIRY: int = 27000000

	# [Advanced] the default number of top most probable tokens to consider during generation
	TOP_P: int = 1

	# the default temperature, which controls how creative AI should be in its responses (typically, in the range of 0.0 to 1.0)
	TEMPERATURE: float = 0.6

	# [Advanced] reduces the likelihood of repetitive responses (typically, in the range of 0.0-2.0)
	FREQUENCY_PENALTY: float = 1.0

	# your A3 app ID (from idms.apple.com)
	# set via `AJAXClient(app_id=…)`
	app_id: int = None

	# your A3 app password (from idms.apple.com)
	# set via `AJAXClient(…, app_password=…)`
	app_password: str = None

	# the user's A3 DSID
	dsid: int = None

	# your Notary token (alternative to daw authentication)
	# set via `AJAXClient(…, notary_token=…)`
	notary_token: str = None

	# the default options/hyperparameters to pass to the Ajax API
	options: dict[str, Any] = None

	# [Internal] whether to use Orchestrators
	use_orchestrators: bool = False

	# [Internal] the A3 token generated when ruuning in production
	a3_token: str = None

	# [Internal] A3 token expiration time
	expiration_time: int = None

	def __init__(self, model_name: str = None, embedding_model_name: str = None, daw_token: str = None,
				 notary_token: str = None, base_url: str = None, app_id: str = None, app_password: str = None,
				 use_orchestrators: bool = False, dsid: int = None, options: dict[str, Any] = None):
		"""
		Initializes this AI client to use with `AI.ask(…, client=AJAXClient(…))`

		@param model_name(str): (optional) The default model name to use to chat
		@param embedding_model_name(str): (optional) The default model name to use to embeddings
		@param daw_token(str): (optional) Useful if you want to pass requests to Ajax on behalf of a user (e.g. a user using your web interface)
		@param notary_token(str): (optional) If you'd like to use Notary authentication (alternative to A3)
		@param base_url(str): (optional) If you host your own Ajax models (e.g. ControlPlane), use this to change the hostname/URL
		@param app_id(int): (optional) If you'd like to use A3 authentication (you can also set this via the `INTERLINKED_IDMS_APP_ID` environment variable)
		@param app_password(str): (optional) If you'd like to use A3 authentication (you can also set this via the `INTERLINKED_IDMS_APP_PASSWORD` environment variable)
		@param use_orchestrators(bool): (optional) Whether to use the Orchestrators API by default
		@param dsid(int): (optional) If you'd like to use A3 authentication, this would be DSID of the user interacting with AI
		@param options(dict): (optional) Any default options you'd like to set for the model
		"""

		# prefix `base_url` if it doesn't have `https://…`
		if base_url and not base_url.startswith('http'):
			base_url = f'https://{base_url}'

		self.app_id = app_id or Config.current.IDMS_APP_ID
		self.app_password = app_password or Config.current.IDMS_APP_PASSWORD

		self.dsid = dsid
		self.use_orchestrators = use_orchestrators
		self.model_name = model_name or 'afm-plus-150b-instruct-latest'
		self.base_url = base_url or 'https://api.afm.aiml.apple.com'
		self.embedding_model_name = embedding_model_name or 'text-embedding-002'

		self.configure_session()

		self.daw_token = daw_token
		self.notary_token = notary_token

		self.options = {**{

			'n': 1,
			'logprobs': 0,
			'top_p': self.TOP_P,
			'temperature': self.TEMPERATURE,
			'frequency_penalty': self.FREQUENCY_PENALTY,
		}, **(options or {})}

	def configure_daw_token(self) -> str:
		"""
		[Internal]
		Returns an DAW token (used in local development)
		"""

		self.daw_token = Utilities.get_apple_connect_token(app_id=self.APP_ID)

	def get_notary_token(self) -> str:
		"""
		Returns a Notary token using notarycli
		"""

		if self.notary_token:
			return self.notary_token

		self.notary_token = Utilities.get_notary_token()
		return self.notary_token

	def get_a3_token(self, dsid: str) -> str:
		"""
		Returns an A3 token
		"""

		current_time: int = int(time() * 1000)

		if self.a3_token and current_time < (self.expiration_time + self.A3_TOKEN_EXPIRY):
			return self.a3_token

		self.a3_token = Utilities.get_a3_token(context=Config.current.AJAX_IDMS_APP_CONTEXT,
									  		   other_app_id=AJAXClient.APP_ID, app_id=self.app_id,
									  		   app_password=self.app_password, dsid=dsid)
		self.expiration_time = current_time
		return self.a3_token

	def get_auth_headers_and_cookies(self, dsid: int = None) -> tuple[dict[str, Any], dict[str, Any]]:
		"""
		[Internal]
		Returns authentication headers and cookies based on the configured authentication method
		"""

		headers = {'Content-Type': 'application/json'}
		cookies = None

		# DAW token for development
		if Config.current.is_development or self.daw_token:

			if self.daw_token is None:
				self.configure_daw_token()

			cookies = {'acack': self.daw_token}

		elif self.notary_token is not None:

			headers['Authorization'] = f'Bearer {self.get_notary_token()}'
			headers['Authorizer'] = 'notary'

		# A3 authentication (production)
		else:

			dsid = dsid or self.dsid or Config.current.DSID

			headers['X-A3-Person-Id'] = str(dsid)
			headers['X-A3-Other-App'] = str(Config.current.IDMS_APP_ID)
			headers['X-A3-Context'] = Config.current.AJAX_IDMS_APP_CONTEXT
			headers['Authorization'] = f'Bearer {self.get_a3_token(dsid=dsid)}'

		return headers, cookies

	def configure_session(self) -> None:
		"""
		[Internal]
		Configures the session
		"""

		self.session = requests.session()

		retry: Retry = Retry(total=8, backoff_factor=1, connect=1, status_forcelist=[502, 503, 504])
		self.session.mount('https://', HTTPAdapter(pool_connections=20, pool_maxsize=20, max_retries=retry))

	def get_models(self, dsid: int = None) -> list[AIModel]:
		"""
		Returns a list of `AIModel` containing models available

		@param dsid(int): (Optional) Only required by the Ajax API if you are creating a web app
						  where users interact with these model
		"""

		dsid = dsid or self.dsid or Config.current.DSID
		headers, cookies = self.get_auth_headers_and_cookies(dsid=dsid)

		try:
			response = self.session.get(f'{self.base_url}/v1/models', headers=headers, cookies=cookies, timeout=4)

		except requests.exceptions.ReadTimeout:

			sleep(1)
			return self.get_models(dsid=dsid)

		if not response.ok:
			logger.error(response.text)

		response.raise_for_status()

		# TODO: ability to filter models instead of hardcoding `/chat`
		ai_models: list[AIModel] = []

		for raw_ai_model in response.json().get('models'):

			endpoints: list[str] = raw_ai_model.get('endpoints', [])

			if not any('chat' in endpoint for endpoint in endpoints):
				continue

			ai_model: AIModel = AIModel(name=raw_ai_model.get('id'), description=raw_ai_model.get('description'),
										supports_stream=any('stream' in endpoint for endpoint in endpoints), raw=raw_ai_model)
			ai_models.append(ai_model)

		return ai_models

	def get_token_count(self, input: str, model_name: str = None,
						dsid: int = None, _retry_count: int = 0) -> int:
		"""
		Returns the number of tokens for a given input string

		@param input(str): an input string
		@param model_name(str): the name of the model to use (default is `self.model_name`)
		@param dsid(int): (Optional) Only required by the Ajax API if you are creating a web app
						  where users interact with these model
		@return (int): the number of tokens
		"""

		if not model_name:
			model_name = self.model_name

		data: dict[str, Any] = {

			'input': input,
			'model': model_name,
		}

		dsid = dsid or self.dsid or Config.current.DSID
		headers, cookies = self.get_auth_headers_and_cookies(dsid=dsid)

		try:
			response = self.session.post(f'{self.base_url}/v1/tokens',
										 data=json.dumps(data), headers=headers,
										 cookies=cookies, timeout=15)

		except (requests.exceptions.ReadTimeout, requests.exceptions.ConnectionError) as exception:

			if _retry_count <= self.MAX_RETRIES:

				logger.warning('request timed out. trying again…')

				# unsure if needed, but an attempt to workaround timeouts, where requests get stuck
				# even after retrying
				if _retry_count > 4:
					self.configure_session()

				sleep(_retry_count + 5)
				return self.get_token_count(input=input, model_name=model_name, dsid=dsid, _retry_count=_retry_count + 1)

			else:

				logger.error('request timed out too many times')
				raise exception

		if response.status_code in {502, 503, 504, 429} or  \
			(response.status_code == 500 and 'Exceeds maximum queue size' in response.text) or  \
			(response.status_code == 500 and 'previous candidate not a prefix of current candidate' in response.text) and  \
			_retry_count <= self.MAX_RETRIES:

			sleep(_retry_count + 1)
			return self.get_token_count(input=input, model_name=model_name, dsid=dsid, _retry_count=_retry_count + 1)

		# 401s or "Invalid Session Id" are returned when AppleConnect session expires locally
		elif ((response.status_code == 401 and _retry_count < 3) or (response.status_code == 500 and 'Invalid Session Id' in response.text) and Config.current.is_development):

			if Config.current.is_development:
				self.configure_daw_token()

			return self.get_token_count(input=input, model_name=model_name, dsid=dsid, _retry_count=_retry_count + 1)

		if not response.ok:
			logger.error(f'{response.text=}, {input=}')

		response.raise_for_status()
		return response.json().get('length')

	def get_embedding(self, input: str|list, model_name: str = None, dsid: int = None) -> list[float] | list[list[float]]:
		"""
		Returns embeddings for a given input string or a list of strings, images, and videos

		@param input(str|list): The text/string (or list of bytes) you would like to generate embedding for
		@param model_name(str): (optional) The name of the model to use
		"""

		model_name = model_name or self.embedding_model_name

		data: dict[str, Any] = {

			'model': model_name,
		}

		if isinstance(input, str):

			input = self.get_clean_text(text=input)
			data['input'] = [input]

		elif isinstance(input, list):
			data['input'] = input

		else:
			raise Exception('get_embedding(input=…) accepts string or a list')

		dsid = dsid or self.dsid or Config.current.DSID
		headers, cookies = self.get_auth_headers_and_cookies(dsid=dsid)

		try:
			response = self.session.post(f'{self.base_url}/v2/embeddings',
										 data=json.dumps(data), headers=headers,
										 cookies=cookies, timeout=self.TIMEOUT)

		except (requests.exceptions.ReadTimeout, requests.exceptions.ConnectionError) as exception:

			sleep(1)
			return self.get_embedding(input=input, model_name=model_name, dsid=dsid)

		if response.status_code in {502, 503, 429} or (response.status_code == 500 and 'Exceeds maximum queue size' in response.text):

			sleep(1)
			return self.get_embedding(input=input, model_name=model_name, dsid=dsid)

		elif (response.status_code == 500 and 'Invalid Session Id' in response.text) and Config.current.is_development:

			self.configure_daw_token()
			return self.get_embedding(input=input, model_name=model_name, dsid=dsid)

		if not response.ok:
			logger.error(f'{response.text} ({input=})')

		response.raise_for_status()

		if isinstance(input, list):
			return [embedding['val'] for embedding in response.json().get('data')]

		return response.json().get('data')[0]['val']

	def get_response(self, messages: str|list[dict], tools: list[Tool] = None, model_name: str = None,
					 temperature: float = None, stream: bool = False, format_: str = None, dsid: int = None,
					 _retry_count: int = 0, **kwargs) -> AIClientResponse | Iterator[AIClientResponse]:
		"""
		Returns chat response for a list of messages

		@param messages(str|list): messages or string
		@param tools(list): If you are looking to give AI access to call Python functions autonomously,
							pass a list of Python functions
		@param model_name(str): the name of the model to use
		@param temperature(float): (Optional) the temperature to use (creativeness)
		@param stream(bool): (Optional) If set, a generator that yields `AIClientResponse` will be returned
		@param dsid(int): (Optional) Only required by the Ajax API if you are creating a web app
						  where users interact with these model
		@return (AIClientResponse): a response
		"""

		if not model_name:
			model_name = self.model_name

		messages = messages if isinstance(messages, list) else [{'role': 'ROLE_USER', 'content': messages}]
		logger.debug(messages[-1].get('content'))

		# temporary. for convenience/to help with adoption, if we detect
		# that users are using the default model, and are using images,
		# we'll auto-switch to a model that supports images
		if model_name == 'afm-text-30b-instruct-latest' and any(message.get('contents') for message in messages):
			model_name = 'afm-multimodal-mm1-30b-instruct-latest'

		options: dict[str, Any] = self.options.copy()

		if tools:
			options['tools'] = [tool.to_dict(client=self) for tool in tools]

		if temperature is not None:
			options['temperature'] = temperature

		if stream:
			return self.get_response_stream(messages=messages, model_name=model_name, options=options, dsid=dsid,
											format_=format_, **kwargs)

		dsid = dsid or self.dsid or Config.current.DSID
		headers, cookies = self.get_auth_headers_and_cookies(dsid=dsid)

		should_retry: bool = False
		data: dict[str, Any] = None

		if self.use_orchestrators:

			data = {

				'model': model_name,
				'messages': messages,
				'session_id': kwargs.get('session_id'),
				'orchestrator': kwargs.get('orchestrator'),
			}

		else:

			data = {

				'options': options,
				'model': model_name,
				'messages': messages,
			}

			if format_ == 'json':
				options['response_format'] = {'type': 'json_object'}

		try:
			url: str = f'{self.base_url}/v1/orchestrators/completions' if self.use_orchestrators else f'{self.base_url}/v1/chat/completions'

			response = self.session.post(url, data=json.dumps(data), headers=headers,
										 cookies=cookies, timeout=self.TIMEOUT)

		except (requests.exceptions.ReadTimeout, requests.exceptions.ConnectionError) as exception:

			if _retry_count <= self.MAX_RETRIES:

				logger.warning('request timed out. trying again…')

				# unsure if needed, but an attempt to workaround timeouts, where requests get stuck
				# even after retrying
				if _retry_count > 4:
					self.configure_session()

				sleep(_retry_count + 5)
				return self.get_response(messages=messages, tools=tools, model_name=model_name, temperature=temperature, stream=stream,
										 format_=format_, dsid=dsid, _retry_count=_retry_count + 1, **kwargs)

			else:

				logger.error('request timed out too many times')
				raise exception

		if response.status_code in {502, 503, 504, 429} or  \
			(response.status_code == 500 and 'Exceeds maximum queue size' in response.text) or  \
			(response.status_code == 500 and 'the model has no generations' in response.text) or  \
			(response.status_code == 500 and 'previous candidate not a prefix of current candidate' in response.text):

			if _retry_count <= self.MAX_RETRIES:

				sleep(_retry_count + 1)
				should_retry = True

			else:
				logger.error(f'attempted to reach Ajax too many times due to a model error ({response.status_code}, {response.text})')

		# 401s or "Invalid Session Id" are returned when AppleConnect session expires locally
		elif (response.status_code == 401 and _retry_count < 3) or (response.status_code == 500 and 'Invalid Session Id' in response.text):

			if Config.current.is_development:

				self.configure_daw_token()
				should_retry = True

			else:
				raise Exception('Your AppleConnect/DAW token is expired, or you do not have "API access"'
								' to Foundation Models in Access Manager. Please request access or try again with a new token')

		# 500 "The model has no generations"
		elif response.status_code == 500 and '"code":13' in response.text and _retry_count < 3:

			sleep(_retry_count + 1)
			return self.get_response(messages=messages, tools=tools, model_name=model_name, temperature=temperature, stream=stream,
									 format_=format_, dsid=dsid, _retry_count=_retry_count + 1, **kwargs)

		elif not response.ok:

			logger.error(f'{response.text=}, {json.dumps(messages)=}')

			# temporary check
			if not should_retry and format_:

				should_retry = True
				format_ = None

		# try again in case of a tracked error above
		if should_retry:
			return self.get_response(messages=messages, tools=tools, model_name=model_name, temperature=temperature, stream=stream,
									 format_=format_, dsid=dsid, _retry_count=_retry_count + 1, **kwargs)

		# raise an exception if the user does not have access to the API
		if response.status_code == 401 and 'Person ID not in the authorized groups' in response.text:
			raise Exception('Could not reach the Ajax API. Do you have access to the API? If not,'
							' try interlinked.apple.com/documentation?page=Start here\nor use other models via'
							' interlinked.apple.com/documentation?page=Google AI')

		elif response.status_code == 400:
			raise Exception(f'400 Error: {response.json().get("message")}')

		response.raise_for_status()

		messages: list[dict] = response.json().get('messages')

		if not messages:
			raise Exception('no `messages` in `response`')

		return self.get_ai_client_response_for_message(message=messages[0])

	def get_response_stream(self, messages: str|list[dict], model_name: str, options: dict[str, Any],
							format_: str = None, dsid: int = None, _retry_count: int = 0, **kwargs) -> Iterator[AIClientResponse]:
		"""
		[Internal]
		To use streaming, please use `AI.ask(…, stream=True)` or `AJAXClient().get_response(…, stream=True)`

		Calls Ajax's /chat/completions/stream endpoint and returns raw JSON response
		"""

		data: dict[str, Any] = {

			'options': options,
			'model': model_name,
			'messages': messages,
		}

		if format_ == 'json':
			options['response_format'] = {'type': 'json_object'}

		dsid = dsid or self.dsid or Config.current.DSID
		headers, cookies = self.get_auth_headers_and_cookies(dsid=dsid)

		with self.session.post(f'{self.base_url}/v1/chat/completions/stream', data=json.dumps(data),
							   headers=headers, cookies=cookies, timeout=self.TIMEOUT, stream=True) as response:
			if not response.ok:
				# check if we have a specific error message
				try:
					response_data = json.loads(response.content)
				except json.JSONDecodeError:
					pass
				else:
					if error := response_data.get('error'):
						# raise an exception if the user does not have access to the API
						if 'Person ID not in the authorized groups' in error:
							raise Exception('To use Ajax models, please request "API access" to'
											' "Foundation Models" in [Access Manager](https://accessmanager.apple.com)')

						raise Exception(error)

				# raise a generic exception
				response.raise_for_status()


			for line in response.iter_lines():

				partial = json.loads(line)

				delta: dict[str, Any] = partial.get('result').get('delta')

				# there is a server-side bug where delta can be empty
				if not delta:
					continue

				message: dict[str, Any] = delta[0]
				yield self.get_ai_client_response_for_message(message=message)

	def get_completion(self, prompt: str, model_name: str = None, temperature: float = 0.6,
					   dsid: int = None, _retry_count: int = 0, stream: bool = False, **kwargs) -> AIClientResponse:
		"""
		Returns a completion for a given text/code

		@param prompt(str): a text prompt/code to complete
		@param model_name(str): the name of the model to use
		@param temperature(float): the temperature to use (creativeness)
		@param stream(bool): (Optional) [Not supported yet] Whether the response should be streamed chunk by chunk. When set, this function will return an
							 iterator that yields an `AIClientResponse`, which has the word/chunk (e.g. `observation.content`)
		@return (AIClientResponse): a response (the completion will be in `.content`)
		"""

		if not model_name:
			model_name = self.model_name

		# TODO: streaming completions is not supported yet
		if stream:
			raise NotImplementedError('Streaming completions is not yet supported in AJAXClient. Please use OllamaClient instead')

		options: dict[str, Any] = self.options.copy()

		if temperature is not None:
			options['temperature'] = temperature

		data: dict[str, Any] = {

			'prompt': prompt,
			'options': options,
			'model': model_name,
		}

		dsid = dsid or self.dsid or Config.current.DSID
		headers, cookies = self.get_auth_headers_and_cookies(dsid=dsid)

		try:
			response = self.session.post(f'{self.base_url}/v1/completions',
										 data=json.dumps(data), headers=headers,
										 cookies=cookies, timeout=self.TIMEOUT)

		except (requests.exceptions.ReadTimeout, requests.exceptions.ConnectionError) as exception:

			if _retry_count <= self.MAX_RETRIES:

				logger.warning('request timed out. trying again…')

				# unsure if needed, but an attempt to workaround timeouts, where requests get stuck
				# even after retrying
				if _retry_count > 4:
					self.configure_session()

				sleep(_retry_count + 5)
				return self.get_completion(prompt=prompt, model_name=model_name, temperature=temperature, dsid=dsid,
										   _retry_count=_retry_count + 1, **kwargs)

			else:

				logger.error('request timed out too many times')
				raise exception

		if response.status_code in {502, 503, 504, 429} or  \
			(response.status_code == 500 and 'Exceeds maximum queue size' in response.text) or  \
			(response.status_code == 500 and 'previous candidate not a prefix of current candidate' in response.text) and  \
			_retry_count <= self.MAX_RETRIES:

			sleep(_retry_count + 1)
			return self.get_completion(prompt=prompt, model_name=model_name, temperature=temperature, dsid=dsid,
									   _retry_count=_retry_count + 1, **kwargs)

		# 401s or "Invalid Session Id" are returned when AppleConnect session expires locally
		elif (response.status_code == 401 and _retry_count < 3) or (response.status_code == 500 and 'Invalid Session Id' in response.text):

			if Config.current.is_development:

				self.configure_daw_token()
				return self.get_completion(prompt=prompt, model_name=model_name, temperature=temperature, dsid=dsid,
										   _retry_count=_retry_count + 1, **kwargs)

			else:
				raise Exception('Your AppleConnect/DAW token is expired, or you do not have "API access" to'
								' Foundation Models in Access Manager. Please request access or try again with a new token')

		elif not response.ok:
			logger.error(f'{response.text=}, {prompt=}')

		if response.status_code == 400:
			raise Exception(f'400 Error: {response.json().get("message")}')

		response.raise_for_status()
		response_json: dict[str, Any] = response.json()
		completions: list[str] = response_json['completions']

		return AIClientResponse(raw=response_json, content=completions[0]['text'] if completions else None)

	""" Utilities """

	def get_ai_client_response_for_message(self, message: dict[str, Any]) -> AIClientResponse:
		"""
		[Internal]
		Converts a raw response message to `AIClientResponse`

		@param message(dict): e.g. `{'role': 'ROLE_USER', 'content': 'Lorem ipsum'}`
		@return (AIClientResponse): a response
		"""

		contents: list[dict] = message.get('contents')
		content: str = next(_content.get('text') for _content in contents if 'text' in _content) if contents else message.get('content')

		if content:

			# replace tokens
			for match in re.findall(r'<code_start>.*?<code_end>', content, re.DOTALL | re.MULTILINE):

				# e.g. `<code_start>code</code_end>` -> `code`
				match_text: str = match.removeprefix('<code_start>').removesuffix('<code_end>')
				match_text = match_text.replace(';', ';\n')

				if '\n' in match_text:

					# remove any unnecessary white space around each line (except tabs)
					match_text = '\n'.join([line.strip(' \n\r') for line in match_text.split('\n')])
					match_text = f'```{match_text}```'

				else:
					match_text = f'`{match_text}`'

				content = content.replace(match, match_text)

			# if the response still included `<code_end>` for some reason
			content = content.replace('<code_start>', '`').replace('<code_end>', '`')

			content = content.replace('Copy code\n', '\n')
			content = content.replace('As a language model, ', '')
			content = content.replace('As an AI language model, ', '')
			content = content.replace(', but as an AI language model', '')

		# ensure that we have `tool_calls`
		if 'tool_calls' not in message:
			message['tool_calls'] = []

		invalid_tool_call_prefixes: set[str] = {'<executable_start> ```function\n', '<executable_start>\n', '```javascript\n',
												'```python\n', '```function\n', '```json\n', 'function_call: '}

		invalid_tool_call_prefix: str = next((prefix for prefix in invalid_tool_call_prefixes if content and prefix in content), None)
		is_likely_tool_call: bool = invalid_tool_call_prefix and content and all(keyword in content for keyword in {'"name"', '"arguments"'})

		# there's a bug where the model responds with the tool call in `content` instead of `tool_calls`
		if content and is_likely_tool_call:

			# e.g. `<executable_start>`
			function_call_raw: list[str] = re.findall(rf'{invalid_tool_call_prefix}(.*?)$', content, flags=re.MULTILINE)

			if not function_call_raw:
				logger.error(f'could not find function calls {content=!r}')

			else:

				function_calls: list[dict]|dict[str, Any] = None

				# remove `<executable_end>` and ```` suffix (if any)
				function_call_raw: str = function_call_raw[0].replace('<executable_end>', '')
				function_call_raw = function_call_raw.strip().removesuffix('```')

				try:
					function_calls = Tool.get_dictionary_from_string(string=function_call_raw)

				except Exception as exception:
					logger.error(f'the model responded with an invalid function call {content=!r}')

				# if the call is a dict, convert it to a list, so we can iterate
				# over all calls below
				if isinstance(function_calls, dict):
					function_calls = [function_calls]

				if isinstance(function_calls, list):

					for function_call in function_calls:

						# match the same structure and types as a response
						# this includes `function['arguments']`, which is currently an encoded JSON in responses
						raw_tool_call: dict[str, Any] = {'id': f'{function_call.get("name")}_{random.randint(10000, 99999)}',
														 'function': {**function_call, **{'arguments': json.dumps(function_call.get('arguments', '{}'))}},
														 'type': 'TOOL_TYPE_FUNCTION'}

						message['tool_calls'].append(raw_tool_call)

				del message['content']
				content = None

		# sometimes, responses include a function but the `arguments`
		# argument is missing, so we add it ourselves
		for raw_tool_call in message.get('tool_calls'):

			if 'function' in raw_tool_call and 'arguments' not in raw_tool_call.get('function', {}):
				raw_tool_call['function']['arguments'] = '{}'

		tool_calls: list[ToolCall] = [ToolCall(id=raw_tool_call.get('id'), name=raw_tool_call.get('function', {}).get('name'),
											   raw_arguments=raw_tool_call.get('function', {}).get('arguments')) for raw_tool_call in message.get('tool_calls')]

		# parse file responses
		files: list[File] = []

		if contents:

			for raw_file in [_content for _content in contents if 'image' in _content]:

				file: File = File(raw=raw_file)

				if image_dict := raw_file.get('image'):

					if url := image_dict.get('url'):

						# convert into bytes
						if url.startswith('data:'):

							url = url.removeprefix('data:')
							file.content_type, file_content = url.split(';', 1)
							file.content = base64.b64decode(file_content.removeprefix('base64,'))

				files.append(file)

		return AIClientResponse(raw=message, content=content, tool_calls=tool_calls, files=files)

	def get_clean_text(self, text: str) -> str:
		"""
		[Internal]
		Cleans a given text before passing it to Ajax
		"""

		# e.g. `${::-j}` or `$%7b%3a%3a-j%7d`
		text = re.sub(r'\${::-.*}|\$%7b%3a%3a.*%7d', '', text, flags=re.IGNORECASE | re.MULTILINE)

		# e.g. `jndi` (log4j), which causes requests to fail
		text = re.sub(r'\$\{[a-z]+\:.*\}|%24%7B[a-z]+%3A.*%7D|\$%7B[a-z]+\:.*(%7D|\})', '', text, flags=re.IGNORECASE | re.IGNORECASE)

		# e.g. `<!DOCTYPE [<!ENTITY passwd SYSTEM "file:///etc/passwd">`
		text = text.replace('<!DOCTYPE', '<DOCTYPE')

		return text

	def create_message(self, role: str, content: str, files: list[str|bytes] = None, **kwargs) -> dict[str, Any]:
		"""
		Creates a message that matches the format used by Ajax

		@param role(str): the value of any of the `ROLE_` properties
		@param content(str): the text content of the message
		@param files(list): a list of file paths or bytes
		"""

		message: dict[str, Any] = {'role': role}

		if files:

			contents: list[dict] = []

			for file in files:

				# path
				if isinstance(file, str):

					file_base64: str = self.encode_file(path=file)

					# audio
					if file.endswith('wav'):
						contents.append({'audio': {'url': f'data:audio/wav;base64,{file_base64}'}})

					# image
					else:
						contents.append({'image_url': f'data:image/png;base64,{file_base64}'})

				# bytes
				else:
					contents.append({'image_url': f'data:image/png;base64,{self.encode_bytes(bytes_=file)}'})

			contents.append({'text': content})
			message['contents'] = contents

		else:
			message['content'] = content

		# if this is a message from a tool/function, add the tool arguments
		if role == self.ROLE_TOOL:

			message['name'] = kwargs['name']
			message['tool_call_id'] = kwargs['tool_call_id']

		return message

	""" AJAX-specific functions """

	def get_orchestrators(self, dsid: int = None) -> list[dict]:
		"""
		Returns a list of orchestrators

		@param dsid(int): (Optional) Only required by the Ajax API if you are creating a web app
						  where users interact with these model
		"""

		dsid = dsid or self.dsid or Config.current.DSID
		headers, cookies = self.get_auth_headers_and_cookies(dsid=dsid)

		try:
			response = self.session.get(f'{self.base_url}/v1/orchestrators', headers=headers, cookies=cookies, timeout=4)

		except requests.exceptions.ReadTimeout:

			sleep(1)
			return self.get_orchestrators()

		response.raise_for_status()
		return response.json().get('orchestrators')


if __name__ == '__main__':
	AJAXClient().get_orchestrators()

