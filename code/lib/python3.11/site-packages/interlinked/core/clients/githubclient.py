import re
import os
import time
import base64
import logging
import requests
from typing import Any, Optional
from urllib.parse import urlparse
from pydantic import BaseModel, ConfigDict, Field

from interlinked.core.config import Config
from interlinked.core.utilities import Utilities
from interlinked.core.singleton import SingletonMeta

logger = logging.getLogger(__name__)


class Blob(BaseModel):
	"""
	Represents a file in a GitHub repository
	"""

	# [internal]
	model_config = ConfigDict(arbitrary_types_allowed=True)

	sha: str
	mode: str

	url: str
	path: str

	# the size of the file
	size: Optional[int] = None
	type: str

	# [internal]
	client: 'GitHubClient' = Field(default=None, exclude=True)
	repository: 'Repository' = Field(default=None, exclude=True)

	@property
	def name(self):
		return os.path.basename(self.path)
	
	@property
	def content(self) -> str|bytes:
		"""
		Returns the contents of this file
		"""

		if self.type == 'tree':
			raise Exception

		response: dict[str, Any] = self.client.session.get(f'{self.client.base_url}/repos/{self.repository.owner_name}/{self.repository.name}/contents/{self.path}')

		if not response.ok:
			logger.error(f'could not get file: {response.text}')

		response.raise_for_status()
		raw_content: dict[str, Any] = response.json()

		if raw_content.get('encoding') == 'base64':
			return base64.b64decode(raw_content.get('content'))

		return raw_content.get('content')


class Release(BaseModel):
	"""
	Represents a GitHub repository release
	"""

	# [internal]
	model_config = ConfigDict(arbitrary_types_allowed=True)

	id: int
	name: str
	body: str
	draft: bool
	tag_name: str
	created_at: str
	prerelease: bool
	published_at: str
	
	# URLs
	url: str
	html_url: str
	assets_url: str
	
	# Author information
	author: dict[str, Any]
	
	# [internal]
	client: 'GitHubClient' = Field(default=None, exclude=True)
	repository: 'Repository' = Field(default=None, exclude=True)


class Repository(BaseModel):
	"""
	Represents a GitHub repository
	"""

	# [internal]
	model_config = ConfigDict(arbitrary_types_allowed=True)

	name: str
	owner_name: str

	is_private: bool
	default_branch_name: str

	# raw representation of this repository
	raw: dict | None

	# [internal]
	client: 'GitHubClient' = Field(default=None, exclude=True)

	@property
	def branches(self) -> dict:

		response = self.client.session.get(f'{self.client.base_url}/repos/{self.owner_name}/{self.name}/branches')
		
		if not response.ok:
			response.raise_for_status()

		branch_raw: dict[str, Any] = response.json()
		return branch_raw

	@property
	def releases(self) -> list[Release]:
		"""
		Returns a list of all releases for this repository
		"""
		response = self.client.session.get(f'{self.client.base_url}/repos/{self.owner_name}/{self.name}/releases')

		if not response.ok:
			logger.error(f'could not get releases: {response.text}')
			
		response.raise_for_status()
		
		releases_data = response.json()

		return [Release(**release_data, client=self.client, repository=self) for release_data in releases_data]

	@property
	def collaborators(self) -> list[dict]:
		"""
		Returns a list of all collaborators for this repository with their permissions
		"""

		headers: dict[str, Any] = {}

		if self.client.token:
			headers = self.client.session.headers

		else:

			installations: list[dict] = self.client.get_installations()
			owner_name_lower: str = self.owner_name.lower()

			for installation in installations:

				if installation['account']['login'].lower() != owner_name_lower:
					continue

				installation_id = installation['id']
				break

			# if no installation, it means the app is not installed
			if not installation_id:
				raise HTTPError(403, 'No access. The GitHub app is not installed to the organization')

				
			token = self.client.get_installation_access_token(installation_id)
			headers = {

				'Authorization': f'token {token}',
				'Accept': 'application/vnd.github.v3+json',
			}
		
		response = self.client.session.get(f'{self.client.base_url}/repos/{self.owner_name}/{self.name}/collaborators',
										   headers=headers)
		
		if not response.ok:

			logger.error(f'Could not get collaborators: {response.text}')
			response.raise_for_status()
			
		return response.json()

	def get_blobs(self, branch_name: str = 'main', recursive: bool = False) -> list[Blob]:
		"""
		Returns a list of all the blobs (files) in this repository

		@param branch_name(str): (Optional) The name of the branch to get the blobs from
		@param recursive(bool): (Optional) Whether to get all nested files
		"""

		response: dict[str, Any] = self.client.session.get(f'{self.client.base_url}/repos/{self.owner_name}/{self.name}/git/ref/heads/{branch_name}')

		if not response.ok:
			logger.error(f'could not get files: {response.text}')

		response.raise_for_status()
		raw_branch = response.json()

		# use the SHA to get the repo's tree recursively
		commit_sha: str = raw_branch['object']['sha']
		response = self.client.session.get(f'{self.client.base_url}/repos/{self.owner_name}/{self.name}/git/trees/{commit_sha}?recursive={recursive}')

		if not response.ok:
			logger.error(f'could not get blobs: {response.text}')

		response.raise_for_status()
		raw_blobs: dict[str, Any] = response.json()
		return [Blob(**blob_raw, client=self.client, repository=self) for blob_raw in raw_blobs.get('tree') if blob_raw.get('type') == 'blob']


class GitHubClient(metaclass=SingletonMeta):
	"""
	A client to interact with GitHub via a
	[Personal Access Token](https://github.pie.apple.com/settings/tokens) or as a [GitHub App](https://github.pie.apple.com/settings/apps)

	To get contents of a repository:
	```from interlinked.core.clients.githubclient import GitHubClient, Repository

	github_client: GitHubClient = GitHubClient(token='…')
	repository: Repository = github_client.get_repository(owner_name='interlinked', name='interlinked')

	for blob in repository.get_blobs(branch_name='main', recursive=True):
		print(blob.path)
	```

	To get the releases of a repository:
	```from interlinked.core.clients.githubclient import GitHubClient, Repository

	github_client: GitHubClient = GitHubClient(token='…')
	repository: Repository = github_client.get_repository(owner_name='interlinked', name='interlinked')

	for release in repository.releases:
		print(release.name)
	```
	"""

	base_url: str = None
	session: requests.Session = None

	token: str = None
	app_id: int = None
	app_private_key: int = None
	installation_id: int = None

	def __init__(self, token: str = None, app_id: int = None,
				 app_private_key: str = None, base_url: str = None):
		"""
		Initializes this client

		@param token(str): (Optional) Your Personal Access Token
		@param app_id(int): (Optional) If using a GitHub App, the app's ID
		@param app_private_key(int): (Optional) If using a GitHub App, the app's private key
		@param base_url(str): (Optional) The GitHub instance to use. Defaults to https://api.github.pie.apple.com
		"""

		# prefix `base_url` if it doesn't have `http://…`
		if base_url and not base_url.startswith('http'):
			base_url = f'http://{base_url}'

		self.app_id = Config.current.GITHUB_APP_ID
		self.token = token or Config.current.GITHUB_TOKEN
		self.private_key = Config.current.GITHUB_PRIVATE_KEY
		self.base_url = base_url or 'https://api.github.pie.apple.com'

		self.session = requests.Session()

		if self.token:

			self.session.headers.update({
				'Authorization': f'token {self.token}',
				'Accept': 'application/vnd.github.v3+json'
			})

		elif self.private_key:

			self.session.headers.update({
				'Accept': 'application/vnd.github.v3+json',
				'Authorization': f'Bearer {self.create_jwt()}',
			})

		else:
			raise Exception('A token or private_key is needed to authenticate')

	@SingletonMeta.Shared
	def shared(cls) -> 'GitHubClient':
		return cls(shared=True)

	""" Authentication """

	def create_jwt(self) -> str:
		"""
		Create a JWT for GitHub App authentication

		@return: A JWT token string
		"""

		try:
			import jwt

		except ModuleNotFoundError:

			if Config.current.is_development:
				Utilities.install_package('PyJWT')

			else:
				raise

			import jwt

		time_now: int = int(time.time())

		payload: dict[str, Any] = {

			'iat': time_now,
			'iss': self.app_id,

			# JWT is valid for 10 minutes
			'exp': time_now + (10 * 60),
		}

		return jwt.encode(payload, self.private_key, algorithm='RS256')

	def get_installation_access_token(self, installation_id: int = None) -> str:
		"""
		Exchange the JWT for an installation access token for a particular installation ID

		@param installation_id(int): Installation ID of the GitHub App
		@return: An installation access token string
		"""

		response = self.session.post(f'{self.base_url}/app/installations/{installation_id}/access_tokens')

		if not response.ok:
			logger.error(f'could not get installations: {response.text}')

		response.raise_for_status()
		return response.json()['token']

	def make_request(self, method: str, endpoint: str, headers: dict[str, str] = None,
					 data: dict[str, Any] = None, params: dict[str, Any] = None) -> dict:
		"""
		Make a request to the GitHub API

		@param method: The HTTP method to use
		@param endpoint: The API endpoint to target
		@param headers: Additional headers to send with the request
		@param data: Data to send in the body of the request
		@param params: Additional parameters to send in the body of the request
		@return: The JSON response from the API as a dictionary
		"""
		if not headers:
			headers = {}

		full_url = f'{self.base_url}{endpoint}'

		if params:
			response = requests.request(method, full_url, headers=headers, json=data, params=params)

		else:
			response = requests.request(method, full_url, headers=headers, json=data)

		if response.status_code == 204:
			return {'status': 'ok'}

		if not response.ok:
			logging.error(response.text)

		response.raise_for_status()

		return response.json()

	""" Repositories """

	def get_repositories(self, installation_id: int = None, repositories_url: str = None) -> list[Repository]:
		"""
		Get a list of all repositories accessible by a particular installation of the GitHub App

		@param installation_id: The ID of the GitHub App installation
		@return: A list of repository data
		"""

		repositories: list[Repository] = []
		raw_repositories: list[dict] = []

		if installation_id is not None:

			headers: dict[str, str] = {'Authorization': f'token {self.get_installation_access_token(installation_id=installation_id)}'}
			response = self.session.get(f'{self.base_url}/installation/repositories', headers=headers)

			if not response.ok:
				logger.error(f'could not get installations: {response.text}')

			response.raise_for_status()
			raw_repositories = response.json().get('repositories', [])

		elif repositories_url:

			response = self.session.get(repositories_url)

			if not response.ok:
				logger.error(f'could not get installations: {response.text}')

			response.raise_for_status()
			raw_repositories = response.json().get('repositories', [])
	
		for raw_repository in raw_repositories:

			name: str = raw_repository['name']
			owner_name: str = raw_repository['owner']['login']

			repositories.append(Repository(name=name, owner_name=owner_name, is_private=raw_repository['private'],
										   raw=raw_repository, default_branch_name=raw_repository['default_branch'], client=self))

		return repositories

	def get_repository(self, owner_name: str, name: str, installation_id: int = None) -> Repository:
		"""
		Returns a repository given its owner_name and name

		**How to use**
		```python
		from interlinked.core.clients.githubclient import GitHubClient

		repository: Repository = GitHubClient(token='…').get_repository(owner_name='interlinked', name='interlinked')

		# optional: get files and directories
		for blob in repository.get_blobs(branch_name='main', recursive=False):

			# from the `Blob` class in `githubclient.py`
			print(blob.name)
			print(blob.path)
			print(blob.content)
		```
		"""

		# personal token
		if self.token:

			response = self.session.get(f'{self.base_url}/repos/{owner_name}/{name}')
			
			if not response.ok:
				response.raise_for_status()

			raw_repository: dict[str, Any] = response.json()
			return Repository(name=name, owner_name=owner_name, is_private=raw_repository.get('private', True),
							  raw=raw_repository, default_branch_name=raw_repository.get('default_branch'), client=self)

		# app
		else:

			if not installation_id:

				installations: list[dict] = self.get_installations()
				owner_name_lower: str = owner_name.lower()

				for installation in installations:

					if installation['account']['login'].lower() != owner_name_lower:
						continue

					installation_id = installation['id']
					break

			# if no installation, it means the app is not installed
			if not installation_id:
				raise Exception('No access. The GitHub app is not installed to the organization')

			repositories: list[dict] = self.get_repositories(installation_id=installation_id)

			for repository in repositories:

				if repository.name == name:
					return repository

			return None

	""" GitHub App """

	def get_installation_id(self, owner_name: str, repository_name: str) -> int:
		"""
		Get the installation ID for a given repository within an organization

		@param owner_name(str): The name of the organization
		@param repository_name(str): The repository name
		@return (int): The installation ID or None if not found
		"""
		installations = self.get_installations()

		for installation in installations:

			installation_org_login: str = installation['account']['login'].lower()

			if installation_org_login == owner_name.lower():

				repositories: list[Any] = self.get_repositories(installation_id=installation['id'])

				for repository in repositories:

					if repository_name.lower() == repository['name'].lower():
						return installation['id']

		return None

	def get_installations(self) -> list[dict]:
		"""
		Get a list of all installations for this GitHub App

		@return: A list of installation dictionaries
		"""
		response = self.session.get(f'{self.base_url}/app/installations')

		if not response.ok:
			logger.error(f'could not get installations: {response.text}')

		response.raise_for_status()
		return response.json()

	""" Access """

	def get_permission_for(self, user_name: str, owner_name: str, repository_name: str) -> str:
		"""
		Returns permissions for a given username
		"""

		installation_id: int = self.get_installation_id(owner_name=owner_name, repository_name=repository_name)

		# get the SHA of the latest commit for the specified branch to use it in the Trees API
		installation_access_token: str = self.get_installation_access_token(installation_id=installation_id)

		headers: dict[str, str] = {

			'X-GitHub-Api-Version': '2022-11-28',
			'Accept': 'application/vnd.github.v3+json',
			'Authorization': f'token {installation_access_token}',
		}
		return self.make_request('GET', f'/repos/{owner_name}/{repository_name}/collaborators/{user_name}/permission', headers=headers).get('permission')

	def get_user_by_email(self, email: str, owner_name: str = None, repository_name: str = None, installation_id: int = None) -> dict:
		"""
		Search for a GitHub user by email address
		Note: This only works if the user has made their email public
		
		@param email(str): The email address to search for
		@return: User information if found, None otherwise
		"""
		headers = {}
		
		if self.token:
			headers = {

				'Authorization': f'token {self.token}',
				'Accept': 'application/vnd.github+json'
			}

		else:

			if not installation_id:

				installations: list[dict] = self.get_installations()
				owner_name_lower: str = owner_name.lower()

				for installation in installations:

					if installation['account']['login'].lower() != owner_name_lower:
						continue

					installation_id = installation['id']
					break

			token = self.get_installation_access_token(installation_id=installation_id)
			headers = {
				'Authorization': f'token {token}',
				'Accept': 'application/vnd.github.v3+json',
			}

		response = self.make_request('GET', '/search/users', headers=headers, params={'q': f'{email} in:email'})
		
		if response.get('total_count', 0) > 0:
			return response['items'][0]

		return None

	def get_files(self, owner_name: str, repository_name: str, file_extensions: list[str] = ['md', 'rst'], branch: str = 'main') -> list[dict[str, Any]]:
		"""
		Returns a list of all the files in a GitHub repo
		"""

		installation_id: int = self.get_installation_id(owner_name=owner_name, repository_name=repository_name)

		# get the SHA of the latest commit for the specified branch to use it in the Trees API
		installation_access_token: str = self.get_installation_access_token(installation_id=installation_id)

		headers: dict[str, str] = {

			'Accept': 'application/vnd.github.v3+json',
			'Authorization': f'token {installation_access_token}',
		}

		branch_response: dict[str, Any] = self.make_request('GET', f'/repos/{owner_name}/{repository_name}/git/ref/heads/{branch}', headers=headers)
		commit_sha: str = branch_response['object']['sha']

		# use the SHA to get the repo's tree recursively
		tree = self.make_request('GET', f'/repos/{owner_name}/{repository_name}/git/trees/{commit_sha}?recursive=true', headers=headers)

		# go through the tree and collect files with the specified extension
		files = [item for item in tree['tree'] if item['type'] == 'blob' and any(item['path'].endswith(file_extension) for file_extension in file_extensions)]

		return files

	def approve_pull_request(self, id: int, owner_name: str, repository_name: str) -> dict:
		"""
		Approves a pull request

		@param id(int): The ID of the pull request to approve
		@param owner_name(str): The owner/organization name
		@param repository_name: The repository name
		"""

		if self.token:
			headers = self.session.headers

		else:

			installation_access_token = self.get_installation_access_token(self.installation_id)
			headers = {
				'Authorization': f'token {installation_access_token}',
				'Accept': 'application/vnd.github.v3+json',
			}

		data: dict[str, str] = {'event': 'APPROVE'}
		endpoint = f'/repos/{owner_name}/{repository_name}/pulls/{id}/reviews'
		return self.make_request('POST', endpoint, headers=headers, data=data)

	def review_pull_request(self, id: int, owner_name: str, repository_name: str, event: str = 'COMMENT', body: str = '') -> dict:
		"""
		Reviews a GitHub Pull Request with options to approve, comment, or request changes

		@param id(int): Pull Request number
		@param owner_name(str): The owner/organization name
		@param repository_name(str): The repository name
		@param event(str): Review event type ('APPROVE', 'COMMENT', 'REQUEST_CHANGES')
		@param body(str): Review comment text
		@return (dict): The response from the GitHub API
		"""

		if event not in ['APPROVE', 'COMMENT', 'REQUEST_CHANGES']:
			raise ValueError('Event must be one of: APPROVE, COMMENT, REQUEST_CHANGES')

		if self.token:
			headers = self.session.headers

		else:

			installation_access_token = self.get_installation_access_token(self.installation_id)

			headers = {
				'Accept': 'application/vnd.github.v3+json',
				'Authorization': f'token {installation_access_token}',
			}

		data = {'body': body, 'event': event}
		endpoint = f'/repos/{owner_name}/{repository_name}/pulls/{id}/reviews'
		return self.make_request('POST', endpoint, data=data, headers=headers)

	def post_file_comment_to_pull_request(self, id: int, owner_name: str, repository_name: str,
										  path: str, position: int, commit_id: str, comment: str) -> None:
		"""
		Post a comment to a specific file within a pull request

		@param owner_name(str): The owner/organization name
		@param repository_name: The repository name
		@param id: The number of the pull request to comment on
		@param path: The relative path of the file on which to comment
		@param position: The position in the diff to place the comment
		@param commit_id: The SHA of the commit needing a comment
		@param comment: The content of the comment to post
		"""

		if self.token:
			headers = self.session.headers

		else:

			installation_access_token = self.get_installation_access_token(self.installation_id)
			headers = {
				'Authorization': f'token {installation_access_token}',
				'Accept': 'application/vnd.github.v3+json',
			}

		data = {

			'path': path,
			'body': comment,
			'position': position,
			'commit_id': commit_id,
		}
		endpoint = f'/repos/{owner_name}/{repository_name}/pulls/{id}/comments'
		self.make_request('POST', endpoint, headers=headers, data=data)

	def reply_to_pull_request_comment(self, id: int, owner_name: str, repository_name: str, comment_url: str, reply: str) -> dict:
		"""
		Reply to a specific comment on a pull request

		@param id(int): The number of the pull request
		@param owner_name(str): The owner/organization name
		@param repository_name(str): The repository containing the pull request
		@param reply: The content of the reply to post
		"""

		match = re.search(r'#issuecomment-(\d+)', comment_url)

		if not match:

			logger.error(f'Could not extract comment ID from the URL: {comment_url}')
			return {'error': 'Could not extract comment ID'}

		comment_id = match.group(1)

		if self.token:
			headers = self.session.headers

		else:

			installation_access_token = self.get_installation_access_token(self.installation_id)
			headers = {
				'Authorization': f'token {installation_access_token}',
				'Accept': 'application/vnd.github.v3+json',
			}

		data = {'body': reply}

		endpoint = f'/repos/{owner_name}/{repository_name}/pulls/{id}/comments/{comment_id}/replies'

		return self.make_request('POST', endpoint, headers=headers, data=data)

	def post_comment_to_pull_request(self, id: int, owner_name: str, repository_name: str, comment: str) -> dict:
		"""
		Post a comment to a pull request

		@param id(int): The number of the pull request to comment on
		@param owner_name(str): The owner/organization name
		@param repository_name: The repository name
		@param comment: The content of the comment to post
		"""

		if self.token:
			headers = self.session.headers

		else:

			installation_access_token = self.get_installation_access_token(self.installation_id)
			headers = {
				'Accept': 'application/vnd.github.v3+json',
				'Authorization': f'token {installation_access_token}',
			}

		data = {'body': comment}
		endpoint = f'/repos/{owner_name}/{repository_name}/issues/{id}/comments'
		return self.make_request('POST', endpoint, headers=headers, data=data)

	def get_pull_request_changes(self, id: int, owner_name: str, repository_name: str) -> list[dict]:
		"""
		Gets the file changes in a Pull Request

		@param owner_name(str): Organization name
		@param repository_name(str): The repository name
		@param id(int): Pull Request number
		@return (list): List of files changed in the PR with their diff content
		"""

		if self.token:
			headers = self.session.headers

		else:

			token = self.get_installation_access_token(self.installation_id)
			headers = {
				'Authorization': f'token {token}',
				'Accept': 'application/vnd.github.v3+json',
			}

		endpoint = f'/repos/{owner_name}/{repository_name}/pulls/{id}/files'
		pull_request_changes = self.make_request('GET', endpoint, headers=headers)

		commits_endpoint = f'/repos/{owner_name}/{repository_name}/pulls/{id}/commits'
		commits = self.make_request('GET', commits_endpoint, headers=headers)

		for change in pull_request_changes:

			file_path = change.get('filename')
			commit_sha = self.get_commit_sha_for_path(path=file_path, commits=commits)
			change['commit_sha'] = commit_sha

			if patch := change.get('patch'):

				added_line_counter: int = 0
				starting_line_number: int = 0

				for line in patch.split('\n'):

					if line.startswith('@@'):

						# Extract the starting line number for additions from the diff
						hunk_header_match = re.search(r'\+([0-9]+)', line)
						
						if hunk_header_match:

							added_line_counter = 0
							starting_line_number = int(hunk_header_match.group(1))

					elif line.startswith('+') and not line.startswith('++'):  # Ignore diff metadata lines
						added_line_counter += 1

				last_commit_sha = commits[-1]['sha'] if commits else None

				# calculate the ending line number in the final file after all additions
				ending_line_number = starting_line_number + added_line_counter - 1
				change['line_ending_number'] = ending_line_number
				change['commit_sha'] = last_commit_sha

		return pull_request_changes

	def read_comment_from_event(self, event: dict[str, Any]) -> dict[str, Any]:
		"""
		Reads a comment from a webhook event payload

		@param event: The webhook event payload
		@return: The content of the comment
		"""

		if self.token:
			headers = self.session.headers

		else:

			token = self.get_installation_access_token(self.installation_id)
			headers = {
				'Authorization': f'token {token}',
				'Accept': 'application/vnd.github.v3+json',
			}

		comment_url = event.get('comment', {}).get('url', '')
		if not comment_url:
			raise ValueError('No comment URL found in the event payload')

		parsed_url = urlparse(comment_url)
		comment_url_truncated = parsed_url.path

		comment_data = self.make_request('GET', comment_url_truncated, headers=headers)
		return comment_data

	def get_review_comments(self, owner_name: str, repository_name: str, pull_request_id: int,
							sort: str = 'created', direction: str = 'asc', since=None, per_page=100) -> list[dict]:
		"""
		Retrieves a list of review comments for a pull request
		Allows sorting by creation or update time

		@param owner_name(str): The owner/organization name
		@param repository_name: The repository name
		@param pull_request_id(int): The number that identifies the pull request
		@param sort: The property to sort the results by ('created' or 'updated')
		@param direction: The direction to sort results ('asc' or 'desc')
		@param since: Only show results updated after the given time. ISO 8601 format
		@param per_page: Number of items in a page
		@return: A list containing review comment data
		"""

		if self.token:
			headers = self.session.headers

		else:

			token = self.get_installation_access_token(self.installation_id)
			headers = {
				'Authorization': f'token {token}',
				'Accept': 'application/vnd.github.v3+json',
			}

		endpoint = f'/repos/{owner_name}/{repository_name}/pulls/{pull_request_id}/comments'
		params = {

			'sort': sort,
			'per_page': per_page,
			'direction': direction,
		}
		if since is not None:
			params['since'] = since

		review_comments = self.make_request('GET', endpoint, headers=headers)
		return review_comments

	def get_pull_requests(self, repository_name: str, owner_name: str, state: str = 'open', max_count: int = 30) -> list[dict]:
		"""
		Retrieves a list of pull requests for a repository
		By default, returns open pull requests, but can be modified by the state parameter

		@param repository_name(str): The repository name
		@param owner_name(str): The owner/organization name
		@param state(str): The state of the pull requests to return. Can be 'open', 'closed', or 'all'
		@return: A list containing pull request data
		"""

		headers: dict[str, Any] = {}

		if self.token:

			headers = {
				'Authorization': f'token {self.token}',
				'Accept': 'application/vnd.github+json',
			}

		else:

			token = self.get_installation_access_token(self.installation_id)
			headers = {
				'Authorization': f'token {token}',
				'Accept': 'application/vnd.github.v3+json',
			}

		pull_requests = self.make_request('GET', f'/repos/{owner_name}/{repository_name}/pulls?per_page={max_count}&state={state}', headers=headers)
		return pull_requests

	def search_code(self, query: str, max_lines: int = None) -> dict:
		"""
		Search for code across GitHub repositories

		@param query(str): Search query (e.g. 'function in:file language:python org:myorganization')
		@param max_lines(int): The maximum number of lines each search result should have
		@return (dict): Search results
		"""

		headers: dict[str, Any] = {}

		if self.token:

			headers = {

				'Authorization': f'token {self.token}',
				'Accept': 'application/vnd.github+json'
			}

		else:

			token = self.get_installation_access_token(self.installation_id)
			headers = {

				'Authorization': f'token {token}',
				'Accept': 'application/vnd.github.v3+json',
			}

		items = []
		results = self.make_request(method='GET', endpoint='/search/code', params={'q': query},
									headers=headers)

		for result in results['items']:

			item: dict[str, Any] = {

				'sha': result['sha'],
				'name': result['name'],
				'path': result['path'],
				'url': result['html_url'],
				'code_snippet': f''
			}

			# fetch the file content to extract code snippets
			try:

				repo_name = result['repository']['full_name']
				file_path = result['path']

				content_endpoint = f'/repos/{repo_name}/contents/{file_path}'
				content_response = self.make_request('GET', content_endpoint, headers=headers)

				if 'content' in content_response and content_response.get('encoding') == 'base64':

					import base64

					file_content = base64.b64decode(content_response['content']).decode('utf-8')
					lines = file_content.split('\n')

					context_lines: int = 15
					matching_snippets: list[str] = []

					query_terms = query.lower().split()

					for line_index, line in enumerate(lines):

						if any(term in line.lower() for term in query_terms):

							snippet: list[str] = []
							start_line = max(0, line_index - context_lines)
							end_line = min(len(lines), line_index + context_lines + 1)

							for j in range(start_line, end_line):

								line_prefix = '→ ' if j == line_index else '  '
								snippet.append(f'{line_prefix}{j + 1:4d} | {lines[j]}')

							matching_snippets.append('\n'.join(snippet))

					if matching_snippets:

						if len(matching_snippets) > 3:

							item['code_snippet'] = '\n\n...\n\n'.join(matching_snippets[:3])
							item['additional_matches'] = len(matching_snippets) - 3

						else:
							item['code_snippet'] = '\n\n...\n\n'.join(matching_snippets)

					else:

						preview_line_count: int = min(20, len(lines))

						if max_lines is not None:
							preview_line_count = min(max_lines, preview_line_count)

						item['code_snippet'] = '\n'.join([f'  {line_index + 1:4d} | {lines[line_index]}' for line_index in range(preview_line_count)])

						if len(lines) > preview_lines:
							item['code_snippet'] += '\n\n… (file continues)'
				
				item['size'] = content_response.get('size', 0)

			except Exception as exception:
				
				logger.error(f'Exception thrown when searching for code: {exception}. Return empty search result.')

			items.append(item)

		results['items'] = items
		return results

	def get_commit_details(self, owner_name: str, repository_name: str, commit_sha: str) -> dict:
		"""
		Gets detailed information about a specific commit

		@param owner_name(str): GitHub organization
		@param repository_name(str): The repository name
		@param commit_sha(str): The commit SHA hash

		@return (dict): Detailed information about the commit
		"""

		if self.token:

			headers = {
				'Authorization': f'token {self.token}',
				'Accept': 'application/vnd.github+json'
			}

		else:

			token: str = self.get_installation_access_token(self.installation_id)
			headers = {
				'Authorization': f'token {token}',
				'Accept': 'application/vnd.github.v3+json',
			}

		endpoint = f'/repos/{owner_name}/{repository_name}/commits/{commit_sha}'
		response = self.make_request('GET', endpoint=endpoint, headers=headers)

		commit_data = {

			'sha': response.get('sha'),
			'author': {
				'name': response.get('commit', {}).get('author', {}).get('name'),
				'date': response.get('commit', {}).get('author', {}).get('date')
			},
			'committer': {
				'name': response.get('commit', {}).get('committer', {}).get('name'),
				'date': response.get('commit', {}).get('committer', {}).get('date')
			},
			'stats': response.get('stats'),
			'files': response.get('files', []),
			'html_url': response.get('html_url'),
			'parents': response.get('parents', []),
			'message': response.get('commit', {}).get('message'),
		}

		if 'files' in response:

			for file_index, file in enumerate(commit_data['files']):

				if 'status' not in file:

					if file.get('additions', 0) > 0 and file.get('deletions', 0) > 0:
						commit_data['files'][file_index]['status'] = 'modified'

					elif file.get('additions', 0) > 0:
						commit_data['files'][file_index]['status'] = 'added'

					elif file.get('deletions', 0) > 0:
						commit_data['files'][file_index]['status'] = 'deleted'

		return commit_data
	
	def get_commits_in_range(self, owner_name: str, repository_name: str, since: str, until: str) -> list:
		"""
		Get a list of commits made during the given time frame.

		@param owner_name(str): GitHub organization
		@param repository_name(str): The repository name
		@param since(str): A timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ as the start of the search frame
		@param until(str): A timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ as the end of the search frame

		@return (list): List of commits made during the time frame
		"""

		if self.token:

			headers = {
				'Authorization': f'token {self.token}',
				'Accept': 'application/vnd.github+json'
			}

		else:

			token: str = self.get_installation_access_token(self.installation_id)
			headers = {
				'Authorization': f'token {token}',
				'Accept': 'application/vnd.github.v3+json',
			}

		endpoint = f'/repos/{owner_name}/{repository_name}/commits'
		params = {'since': since, 'until': until}
		commits = self.make_request('GET', endpoint=endpoint, headers=headers, params=params)

		return commits
	
	""" Utilities """

	@classmethod
	def parse_repository_url(cls, url: str) -> tuple[str, str]:
		"""
		Parses and extracts the organization and repository_name name from a GitHub repository URL

		@param url: The full URL to the repository.
		@return: A tuple containing (owner name, repository name).
		"""

		if not url.startswith('http'):
			url = f'https://{url}'

		# e.g. `github.pie.apple.com:org_name/repo_name`
		if 'com:' in url:
			url = url.replace('com:', '/')

		parsed_url = urlparse(url)
		path_parts = parsed_url.path.strip('/').split('/')

		if len(path_parts) < 2:
			raise ValueError('URL does not contain enough path information')

		return path_parts[0], path_parts[1]

	def get_commit_sha_for_path(self, path: str, commits: list[dict]) -> Optional[str]:
		"""
		[Internal]
		"""

		# reverse to get the most recent commit first
		for commit in reversed(commits):

			filenames = [file['filename'] for file in commit.get('files', [])]

			if path in filenames:
				return commit['sha']

		return None

	def generate_diff(self, owner_name: str, repository_name: str, pull_request_id: int) -> tuple[dict[str, str], str]:
		"""
		Retrieves and concatenates diffs for all files changed in a pull request into a single string
		that mimics the content of a .patch file

		@param owner_name(str): The owner/organization name
		@param repository_name: The repository name
		@param id: The number of the pull request
		@return: A tuple containing:
			- A dictionary where each key is a file path with its corresponding diff in patch format
			- A string representing the concatenated diff for all files in the style of a .patch file
		"""
		# Get changes for a given pull request
		pull_request_change_details = self.get_pull_request_changes(id=pull_request_id, owner_name=owner_name, repository_name=repository_name)

		file_diffs = {}
		concatenated_diffs = []

		for change in pull_request_change_details:

			diff = change.get('patch')
			file_path = change.get('filename')

			if file_path and diff:

				file_diffs[file_path] = diff
				concatenated_diffs.append(f'diff --git a/{file_path} b/{file_path}\n')
				concatenated_diffs.append(diff)
				concatenated_diffs.append('\n')

		diff_patch = ''.join(concatenated_diffs).strip()

		return file_diffs, diff_patch, pull_request_change_details

	def push_file_to_repo(self, owner_name: str, repository_name: str, branch: str, file_path: str, file_content: str, commit_message: str) -> dict:
		"""
        Pushes a file to a specified branch in a GitHub repository.

        @param owner_name: The owner/organization name of the repository.
        @param repository_name: The name of the repository.
        @param branch: The name of the branch where the file should be pushed.
        @param file_path: The relative path of the file to be pushed.
        @param file_content: The content of the file to be pushed.
        @param commit_message: The commit message for the push.
        @return: A dictionary containing the response from the GitHub API.
        """

		# Get the latest commit SHA for the specified branch
		response = self.session.get(f'{self.base_url}/repos/{owner_name}/{repository_name}/git/refs/heads/{branch}')
		response.raise_for_status()
		latest_commit_sha = response.json()['object']['sha']

		# Get the base tree SHA for the latest commit
		response = self.session.get(f'{self.base_url}/repos/{owner_name}/{repository_name}/git/commits/{latest_commit_sha}')
		response.raise_for_status()
		base_tree_sha = response.json()['tree']['sha']

		# Create a blob for the file content
		blob_data = {
			'content': base64.b64encode(file_content.encode('utf-8')).decode('ascii'),
    		'encoding': 'base64'
		}
		response = self.session.post(f'{self.base_url}/repos/{owner_name}/{repository_name}/git/blobs', json=blob_data)
		response.raise_for_status()
		blob_sha = response.json()['sha']

		# Create a tree with the new blob
		tree_data = [
			{
				'path': file_path,
				'mode': '100644',
				'type': 'blob',
				'sha': blob_sha
			}
		]
		response = self.session.post(f'{self.base_url}/repos/{owner_name}/{repository_name}/git/trees', json={'base_tree': base_tree_sha, 'tree': tree_data})
		response.raise_for_status()
		new_tree_sha = response.json()['sha']

		# Create a new commit with the new tree
		commit_data = {
			'message': commit_message,
			'tree': new_tree_sha,
			'parents': [latest_commit_sha]
		}
		response = self.session.post(f'{self.base_url}/repos/{owner_name}/{repository_name}/git/commits', json=commit_data)
		response.raise_for_status()
		new_commit_sha = response.json()['sha']

		# Update the reference to point to the new commit
		update_ref_data = {
			'sha': new_commit_sha,
			'force': False,
			'expected_sha': latest_commit_sha
		}
		response = self.session.patch(f'{self.base_url}/repos/{owner_name}/{repository_name}/git/refs/heads/{branch}', json=update_ref_data)
		response.raise_for_status()

		return response.json()

if __name__ == '__main__':

	import json
	# print(GitHubClient.shared.get_repository(owner_name='interlinked', name='interlinked'))
	# print(GitHubClient.shared.get_pull_request_changes(id=14, owner_name='interlinked', repository_name='interlinked'))
	# print(GitHubClient.shared.approve_pull_request(id='14', owner_name='Interlinked', repository_name='interlinked-next'))
	# print(len(GitHubClient.shared.get_pull_requests(owner_name='interlinked', repository_name='interlinked', state='all', max_count=100)))
	# print(json.dumps(GitHubClient.shared.get_pull_request_changes(id='18', owner_name='Interlinked', repository_name='interlinked-next')))
	# print(GitHubClient.push_file_to_repo(owner_name='interlinked', repository_name='interlinked', branch='main', file_path='test.txt', file_content='This is a sample file', commit_message='Commit by Github client'))