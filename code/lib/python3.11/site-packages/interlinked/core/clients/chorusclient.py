import json
import logging
import requests
from datetime import datetime
from pydantic import BaseModel
from typing import Any, Optional
from datetime import datetime, timedelta
from requests.adapters import HTTPAdapter, Retry

from interlinked.core.config import Config
from interlinked.core.utilities import Utilities
from interlinked.core.singleton import SingletonMeta
from interlinked.core.clients.appledirectoryclient import AppleDirectoryClient

logger = logging.getLogger(__name__)


class Space(BaseModel):

	id: int|str
	children_raw: list[dict]

	@property
	def pages(self) -> list['Page']:

		pages: list[Page] = []

		for child in self.children_raw:

			# pages have type `1`
			if child.get('type') != 1:
				continue

			pages.append(ChorusClient.shared.get_page(id=child.get('entity_id')))

		return pages


class Page(BaseModel):

	id: int|str
	html: str
	title: str
	created_at: datetime
	changed_at: datetime
	space_id: Optional[int|str] = None
	has_entity_security: Optional[bool] = False


class ChorusClient(metaclass=SingletonMeta):

	APP_CONTEXT: str = 'chorus'
	CHORUS_APP_ID: int = 149958
	BASE_URL: str = 'https://chorus.apple.com'

	app_id: int = None
	app_password: int = None

	def __init__(self, app_id: int = None, app_password: str = None):
		"""
		Initializes this client to interact with Chorus.

		The main purpose of this client is to be used with the `ChorusParser` API
		for parsing Chorus pages and passing them to `AI.learn(…)`

		Chorus requires having A3 authentication turned on, which also requires
		creating an app in IdMS. [Learn more ›](chorus.apple.com/page/9024583)

		@param app_id(int): the ID of your app in IdMS (e.g. 12345)
		@param app_password(int): the password of your app in IdMS (the PROD tab)
		"""

		self.app_id = app_id or Config.current.IDMS_APP_ID
		self.app_password = app_password or Config.current.IDMS_APP_PASSWORD

		self.configure_session()

	@SingletonMeta.Shared
	def shared(cls) -> 'ChorusClient':
		return cls(shared=True)

	def get_a3_token(self) -> str:
		"""
		Returns an A3 token
		"""
		return Utilities.get_a3_token(context=ChorusClient.APP_CONTEXT, other_app_id=self.CHORUS_APP_ID,
									  app_id=self.app_id, app_password=self.app_password)

	def configure_session(self) -> None:
		"""
		[Internal]
		Configures the session
		"""

		self.session = requests.session()

		retry: Retry = Retry(total=8, backoff_factor=1, status_forcelist=[502, 503, 504])
		self.session.mount('https://', HTTPAdapter(pool_connections=20, pool_maxsize=20, max_retries=retry))

	def get_has_access(self, id: int|str, dsid: int, type: str = 'space', skip_sensitive: bool = False) -> bool:
		"""
		Checks if a given DSID has access to a Chorus Space/page

		@param id(str): the ID of the Chorus Space/page
		@param type(str): space or page
		@param dsid(str): the DSID of the person
		@param skip_sensitive(bool): if set, pages with `has_entity_security` will return `False`
		"""

		headers: dict[str, str] = {

			'APPID': str(self.app_id),
			'Accept': 'application/json',
			'idms-a3-token': self.get_a3_token(),
		}

		if type != 'space':

			# get the Space ID from the page
			page: Page = self.get_page(id=id)

			if skip_sensitive and page.has_entity_security:
				return False

			id = page.space_id

		response = self.session.get(f'{self.BASE_URL}/api/v3/space/{id}/members/getAll', headers=headers)
		response.raise_for_status()

		response_json: list[dict[str, Any]] = response.json()

		if any(str(entry.get('dsid')) == str(dsid) for entry in response_json):
			return True

		# check if the DSID is in any of the flattened list of groups
		for entry in response_json:

			if entry.get('type') != 'group':
				continue

			if any(person.dsid == dsid for person in AppleDirectoryClient.shared.get_persons_for_group_dsid(dsid=entry.get('id'), nested=True)):
				return True

		return False

	def get_space(self, id: int|str) -> Space:
		"""
		Returns a Chorus `Space`

		@param id(str): the ID of the Space (e.g. `526694`)
		@return (Space): a Space
		"""

		headers: dict[str, str] = {

			'APPID': str(self.app_id),
			'Accept': 'application/json',
			'idms-a3-token': self.get_a3_token(),
		}

		response = self.session.get(f'{self.BASE_URL}/api/v3/nav-tree/{id}', headers=headers)
		response.raise_for_status()

		response_json: dict[str, Any] = response.json()
		return Space(id=id, children_raw=list(response_json.values()))

	def get_page(self, id: str) -> Page:
		"""
		Returns a Chorus `Page`

		@param id(str): the ID of the page (e.g. `526694`)
		@return (Page): a page
		"""

		headers: dict[str, str] = {

			'APPID': str(self.app_id),
			'Accept': 'application/json',
			'idms-a3-token': self.get_a3_token(),
		}

		response = self.session.get(f'{self.BASE_URL}/api/v3/page/{id}/pageMetaData', headers=headers)
		response.raise_for_status()

		response_json: dict[str, Any] = response.json()
		has_entity_security: bool = response_json.get('hasEntitySecurity')

		response = self.session.get(f'{self.BASE_URL}/api/v3/page/{id}', headers=headers)
		response.raise_for_status()

		response_json: dict[str, Any] = response.json()

		title: str = response_json.get('title')
		body: str = json.loads(response_json.get('body', {}))
		created_at: datetime = datetime.fromtimestamp(response_json.get('created'))
		changed_at: datetime = datetime.fromtimestamp(response_json.get('changed'))

		if not body.get('html') and body.get('adf'):
			raise Exception(f'The page ({id}) is missing an HTML version in Chorus. Please edit the page in Chorus'
							' (without making any edits), save, then try again.')

		return Page(id=id, title=title, has_entity_security=has_entity_security, created_at=created_at,
					changed_at=changed_at, html=f'<h1>{title}</h1><br>{body.get("html")}', space_id=response_json.get('gid'))


if __name__ == '__main__':
	print(ChorusClient.shared.get_page(id=7273526))