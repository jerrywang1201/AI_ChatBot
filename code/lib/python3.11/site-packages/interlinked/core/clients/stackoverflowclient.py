import logging
import requests
from typing import Any
from pydantic import BaseModel
from datetime import datetime, timedelta
from requests.adapters import HTTPAdapter, Retry

from interlinked.core.config import Config
from interlinked.core.utilities import Utilities
from interlinked.core.singleton import SingletonMeta

logger = logging.getLogger(__name__)


class Article(BaseModel):

	id: int
	body: str
	title: str
	created_at: datetime
	last_activity_at: datetime


class StackOverflowClient(metaclass=SingletonMeta):
	"""
	Client for interacting with the internal StackOverflow.
	"""

	api_key: str = None

	def __init__(self, api_key: str = None, base_url: str = None):

		# prefix `base_url` if it doesn't have `https://â€¦`
		if base_url and not base_url.startswith('http'):
			base_url = f'https://{base_url}'

		self.api_key = api_key or Config.current.STACKOVERFLOW_API_KEY
		self.base_url = base_url or 'https://stackoverflow.apple.com'
		self.configure_session()

	@SingletonMeta.Shared
	def shared(cls) -> 'StackOverflowClient':
		return cls(shared=True)

	def configure_session(self) -> None:
		"""
		[Internal]
		Configures the session
		"""

		self.session = requests.session()

		retry: Retry = Retry(total=8, backoff_factor=1, status_forcelist=[502, 503, 504])
		self.session.mount('https://', HTTPAdapter(pool_connections=20, pool_maxsize=20, max_retries=retry))

	def get_articles_ids_for_tags(self, tags: list[str]) -> list[int]:
		"""
		Returns a list of article IDs for a given set of tags

		@param tags(list): a list of tags (e.g. `['help-rubix', 'python']`)
		@return (list): a list of article IDs that have any of the tags
		"""

		proxies: dict[str, str] = {'https': Config.current.PROXY_URL} if Config.current.PROXY_URL else {}

		data: dict[str, Any] = self.session.get(f'{self.base_url}/api/2.3/articles',
											params={'key': self.api_key, 'tagged': ';'.join(tags)}, proxies=proxies).json()
		items: list[dict[str, Any]] = data.get('items', [])

		return [item.get('article_id') for item in items]

	def get_article(self, id: int) -> Article:
		"""
		Returns a StackOverflow article given its ID
		"""

		proxies: dict[str, str] = {'https': Config.current.PROXY_URL} if Config.current.PROXY_URL else {}

		response: Any = self.session.get(f'{self.base_url}/api/2.3/articles/{id}',
										 params={'key': self.api_key, 'filter': 'withbody'}, proxies=proxies)

		if not response.ok:

			logger.error(response.text)
			response.raise_for_status()

		data: dict[str, Any] = response.json()
		items: list[dict[str, Any]] = data.get('items')

		if not items:
			return None

		item: dict[str, Any] = items[0]
		created_at: datetime = datetime.fromtimestamp(item['creation_date'])
		last_activity_at: datetime = datetime.fromtimestamp(item['last_activity_date'])

		return Article(id=id, title=item.get('title'), body=item.get('body'), created_at=created_at,
					   last_activity_at=last_activity_at)


if __name__ == '__main__':
	print(StackOverflowClient.shared.get_article(id=40009))
