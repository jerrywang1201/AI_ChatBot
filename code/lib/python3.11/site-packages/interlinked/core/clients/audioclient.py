import queue
import asyncio
import logging
import threading
from typing import Any, Callable
from pyaudio import PyAudio, paInt16, Stream

from interlinked.core.singleton import SingletonMeta

logger = logging.getLogger(__name__)


class AudioClient(metaclass=SingletonMeta):
	"""
	Use this class to talk to AI and hear AI's responses in realtime.

	Install the following first (skip `audioop-lts` if you are not using Python 3.13 or later):
	```bash
	pip3 install pyaudio audioop-lts
	brew install ffmpeg
	```

	You can access the `.listen()` and `.play()` functions via:
	```python
	from interlinked.core.clients.audioclient import AudioClient

	AudioClient.shared.play(audio_bytes=b'…')
	AudioClient.shared.listen(callback=your_callback_function)
	```

	See the realtime folder in GitHub examples for full examples.
	"""

	# audio
	channels: int = 1
	format: int = paInt16
	audio: PyAudio = None
	chunk_size: int = 1024
	input_rate: int = 24000
	output_rate: int = 24000

	# listening
	is_listening: bool = False
	listening_stream: Stream = None

	# play
	play_thread: Any = None
	is_playing: bool = False
	play_stream: Stream = None

	# internal
	_devices: list[dict] = None

	def __init__(self, input_rate: int = 24000):

		self.audio = PyAudio()
		self._devices = self.get_devices()

		self.play_stream = None
		self.play_thread = None
		self.input_rate = input_rate
		self.play_event = threading.Event()
		self.play_buffer = queue.Queue(maxsize=200)

		self._is_playing = False
		self._stop_playing = False
		self._buffer_lock = threading.Lock()

	@SingletonMeta.Shared
	def shared(cls) -> 'AudioClient':
		return cls()

	""" Listening """

	async def listen(self, callback: Callable, device_name: str = None) -> None:
		"""
		Start continuous audio listening

		@param callback(Callable): Your custom function to call as audio comes through the microphone
		@param device_name(str): (Optional) Pick a custom microphone to listen from
		"""

		if self.is_listening:
			return
		
		input_device_index: int = None

		if device_name:

			input_device_index = next((device['id'] for device in self._devices if device['name'].lower() == device_name.lower()
																				   and device['type'] == 'microphone'), None)

			if input_device_index is None:
				raise Exception(f'"{device_name}" is not connected')

		self.is_listening = True
		self.listening_stream = self.audio.open(format=self.format, channels=self.channels, rate=self.input_rate, input=True,
												frames_per_buffer=self.chunk_size, input_device_index=input_device_index)

		while self.is_listening:

			try:

				data = self.listening_stream.read(self.chunk_size, exception_on_overflow=False)
				await callback(data)
				await asyncio.sleep(0.01)

			except asyncio.CancelledError:
				break

			except Exception as exception:

				logger.error(f'error occured while listening: {exception}')
				break

	def stop_listening(self) -> None:
		"""
		Stop audio listening
		"""

		self.is_listening = False

		self.stop_stream(stream=self.listening_stream)
		self.listening_stream = None

	""" Playing """

	def play(self, audio_bytes: bytes, device_name: str = None) -> None:
		"""
		Plays a given audio

		@param audio_bytes(bytes): The audio to play (from `AI.ask(…, realtime=True)`)
		@param device_name(str): (Optional) Pick a custom speaker to play from
		"""

		output_device_index: int = None

		if device_name:
			output_device_index = next((device['id'] for device in self._devices if device['name'].lower() == device_name.lower()
																					and device['type'] == 'speaker'), None)
			if output_device_index is None:
				raise Exception(f'"{device_name}" is not connected')

		def _keep_playing(output_device_index: int = None) -> None:
			"""
			[Internal]
			Inner function that actually plays the audio in chunks
			"""

			try:

				self.play_stream = self.audio.open(format=self.format, channels=self.channels, rate=self.output_rate,
												   output=True, frames_per_buffer=self.chunk_size, output_device_index=output_device_index)
				self._is_playing = True

				while not self._stop_playing:

					try:

						audio_chunk = self.play_buffer.get(timeout=0.25)

						for i in range(0, len(audio_chunk), self.chunk_size):

							if self.play_event.is_set():
								break

							chunk = audio_chunk[i:i+self.chunk_size]
							self.play_stream.write(chunk)

					except queue.Empty:
						continue

					except Exception as exception:
						logging.error(f'could not play part of the audio: {exception}', exc_info=True)

					# make sure the loop stops
					if self.play_event.is_set():
						self._stop_playing = True

			finally:

				self._is_playing = False

				if self.play_stream:

					self.play_stream.stop_stream()
					self.play_stream.close()
					self.play_stream = None

		try:
			self.play_buffer.put_nowait(audio_bytes)

		except queue.Full:

			logging.warning('play buffer is full; dropping the oldest chunk.')
			self.play_buffer.get_nowait()
			self.play_buffer.put_nowait(audio_bytes)

		if not self.play_thread or not self.play_thread.is_alive():

			self._stop_playing = False
			self.play_event.clear()
			self.play_thread = threading.Thread(target=_keep_playing, args=(output_device_index,))
			self.play_thread.start()

		self._is_playing = True

	def stop_playing(self) -> None:
		"""
		Stop audio play immediately
		"""

		self._stop_playing = True

		# ensure thread-safety when clearing the queue
		with self._buffer_lock:
			self.play_buffer.queue.clear()

		self._is_playing = False
		self.play_event.set()

	@property
	def is_playing(self) -> bool:
		"""
		Returns whether audio is playing		
		"""
		return self._is_playing and self.play_thread is not None and self.play_thread.is_alive()

	""" Utilities """

	@classmethod
	def get_devices(self) -> list[dict]:
		"""
		Returns a list of audio devices that can be used to play audio from
		"""

		audio: PyAudio = PyAudio()
		devices: list[dict] = []

		for device_index in range(audio.get_device_count()):

			device_info: dict[str, Any] = audio.get_device_info_by_index(device_index)
			devices.append({'id': device_info['index'], 'name': device_info['name'],
							'type': 'microphone' if device_info['maxInputChannels'] > 0 else 'speaker'})

		return devices

	""" Shared """	

	def stop_all(self):
		"""
		Stops both recording and listening
		"""

		self._stop_playing()
		self.stop_stream(self.listening_stream)
		self.audio.terminate()

	""" Internal """

	def stop_stream(self, stream: Stream):
		"""
		[Internal]
		Stops a given `Stream`
		"""

		if not stream:
			return

		stream.stop_stream()
		stream.close()


if __name__ == '__main__':

	async def callback(audio_bytes: bytes):
		print(len(audio_bytes))

	async def main():
		await AudioClient.shared.listen(callback=callback)

	asyncio.run(main())
