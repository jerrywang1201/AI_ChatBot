import uuid
import logging
from typing import Any
from qdrant_client import QdrantClient as BaseQdrantClient
from qdrant_client.http.exceptions import UnexpectedResponse
from qdrant_client.models import PointStruct, Filter, FilterSelector,  \
								 FieldCondition, MatchValue, MatchAny, Distance, VectorParams,  \
								 HnswConfigDiff

from interlinked.core.config import Config
from interlinked.core.utilities import Utilities
from interlinked.core.singleton import SingletonMeta
from interlinked.core.clients.basevectorstoreclient import BaseVectorStoreClient

logger = logging.getLogger(__name__)



class QdrantClient(BaseQdrantClient, BaseVectorStoreClient, metaclass=SingletonMeta):
	"""
	A Qdrant client specifically designed for storing Knowledge to use in `AI.ask(…, store_client=…)` and
	`Knowledge.search(…, store_client=…)`
	"""

	# the default distance to use when creating a collection
	DEFAULT_DISTANCE: Distance = Distance.COSINE

	def __init__(self, in_memory: bool = False, host: str = None, port: str = None, **kwargs):
		"""
		Initializes the Qdrant vector store/database

		@param in_memory(bool): (Optional) If set, the entire database will run in memory/RAM and all data
								stored will only be available until your script/code finishes running
		@param host(str): (Optional) The Qdrant host name if you're hosting Qdrant or running it via Docker locally
		@param port(str): (Optional) The Qdrant port number if you're hosting Qdrant or running it via Docker locally
		"""

		if in_memory:

			super(QdrantClient, self).__init__(location=':memory:', **kwargs)
			return

		url: str = kwargs.pop('url', None)
		path: str = kwargs.pop('path', None)

		# if `path` is set (including in production, read from the path)
		if path or (Config.current.is_development and not (host or port or url)):

			from pathlib import Path

			try:
				super(QdrantClient, self).__init__(path=path or Config.current.QDRANT_PATH or f'{Path.home()}/.interlinked-qdrant', **kwargs)

			except RuntimeError as error:

				if 'is already accessed' in str(error):
					raise Exception('Another Python process is using the vector store. If you are unsure, run `killall Python -9`, then try again')

		elif url:
			port = port or 443
			super(QdrantClient, self).__init__(url=url, port=port, **kwargs)

		else:
			super(QdrantClient, self).__init__(host=host or 'interlinked-qdrant', port=port or 6333, **kwargs)

	@SingletonMeta.Shared
	def shared(cls) -> 'QdrantClient':
		return cls(shared=True)

	def create_collection(self, name: str, size: int) -> None:
		"""
		Creates a collection if it doesn't exist already

		@param name(str): The name of the collection
		@param size(int): The vector size (varies based on model)
		"""

		if self.get_has_collection(name=name):
			return

		try:
			super(QdrantClient, self).create_collection(collection_name=name,
														vectors_config=VectorParams(size=size, distance=self.DEFAULT_DISTANCE),
														hnsw_config=HnswConfigDiff(m=32, ef_construct=200))
		except ValueError as error:

			# if an exception occurs because the collection already exists, it is
			# likely that the caller is running in multiple threads
			if (error_text := str(error)) and not ('Collection' in error_text and 'already exists' in error_text):
				raise

		self.collection_names.add(name)

	def delete_collection(self, name: str) -> None:
		"""
		Deletes a collection

		@param name(str): The name of the collection
		"""

		# only delete if the collection does not exist
		if not self.get_has_collection(name=name):
			return

		super(QdrantClient, self).delete_collection(collection_name=name)

		if name in self.collection_names:
			self.collection_names.remove(name)

	def get_has_collection(self, name: str) -> bool:
		"""
		Returns whether a given collection exists

		@param name(str): The name of the collection
		@returns (bool): Whether the collection exists
		"""

		try:

			has_collection: bool = self.get_collection(collection_name=name)

			if has_collection:
				self.collection_names.add(name)

			return has_collection is not None

		except ValueError:
			return False

		except UnexpectedResponse as error:

			# in production, if collection doesn't exist, a "Not found" error is raised
			if 'Not found' in str(error):
				return False

			raise error

	def upsert(self, embedding: list[float], payload: dict[str, Any], collection_name: str) -> str:
		"""
		Adds an embedding to a given collection

		@param embedding(float): The embedding
		@param payload(dict): The string/text content used to generate the embedding
		@param collection_name(str): The name of the collection to store the knowledge in
		@return (str): The newly-generated ID of the point/embedding
		"""

		# if we've never seen or initialized the collection, create one and use the size of the embedding
		if collection_name not in self.collection_names:
			self.create_collection(name=collection_name, size=len(embedding))

		id: str = str(uuid.uuid4())
		point_struct: PointStruct = PointStruct(id=id, vector=embedding, payload=payload)
		super(QdrantClient, self).upsert(collection_name=collection_name, points=[point_struct])
		return id

	def update(self, id: str, embedding: list[float], payload: dict[str, Any], collection_name: str) -> None:
		"""
		Updates an embedding in a given collection

		@param id(id): The ID of the point
		@param embedding(float): The embedding
		@param payload(dict): The string/text content used to generate the embedding
		@param collection_name(str): The name of the collection the knowledge is stored in
		"""
		point_struct: PointStruct = PointStruct(id=id, vector=embedding, payload=payload)
		super(QdrantClient, self).upsert(collection_name=collection_name, points=[point_struct])

	def delete(self, id_key: str, ids: list[int|str], collection_name: str, keep_filters: list[FieldCondition] = []) -> None:
		"""
		Deletes an embedding from a given collection

		@param id_key(str): the name of the ID key to use for finding/deleting the points
		@param ids(list): the list of IDs to delete
		@param collection_name(str): the name of the collection the knowledge is stored in
		@param keep_filters(list): a list of conditions to use to exclude certain points/embeddings
		"""

		points_selector: FilterSelector = FilterSelector(filter=Filter(must=[
			FieldCondition(key=id_key, match=MatchAny(any=ids))
		], must_not=keep_filters))

		super(QdrantClient, self).delete(collection_name=collection_name, points_selector=points_selector)

	def get_snapshot(self, collection_name: str) -> bytes:
		"""
		Creates and returns a snapshot/backup of all Knowledge/collections
		that you can then restore on another device/instance using `restore_snapshot`

		@param collection_name(str): the name of the collection to backup/snapshot
		@return (bytes): the snapshot as bytes (can be saved as a file using `with open('/tmp/file.snapshot', 'wb') as file:`)
		"""

		import requests

		headers: dict[str, str] = {}
		snapshot_description: Any = self.create_snapshot(collection_name=collection_name, wait=True)

		if self._client._api_key is not None:
			headers['api-key'] = self._client._api_key

		response: Any = requests.get(f'{self._client._scheme}://{self._client._host}:{self._client._port}/collections/{collection_name}/snapshots/{snapshot_description.name}', headers=headers)

		if not response.ok:
			logger.error(f'could not download snapshot ({response.text=})')

		response.raise_for_status()
		return response.content

	def restore_snapshot(self, snapshot: bytes, collection_name: str) -> None:
		"""
		Restores data from a snapshot

		@param snapshot(bytes): the snapshot bytes (from `get_snapshot()`)
		@param collection_name(str): the name of the collection to backup/snapshot
		"""

		import requests

		# get the hash of the snapshot to ensure integrity after
		# it gets uploaded
		checksum: str = Utilities.get_sha256_hash(value=snapshot)

		response: Any = requests.post(f'{self._client._scheme}://{self._client._host}:{self._client._port}/collections/{collection_name}/snapshots/upload',
									  params={'priority': 'snapshot', 'wait': 'true', 'checksum': checksum},
									  files={'snapshot': ('file.snapshot', snapshot, 'application/octet-stream')})

		if not response.ok:
			logger.error(f'could not restore snapshot ({response.text=})')

		response.raise_for_status()

		if not response.json().get('result'):
			raise Exception(f'could not restore snapshot ({response.text=})')