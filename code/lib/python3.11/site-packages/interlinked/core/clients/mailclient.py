import re
import os
import ssl
import email
import logging
import smtplib
import mimetypes
from ssl import SSLContext
from mimetypes import guess_type
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email.message import EmailMessage
from email.encoders import encode_base64
from email.headerregistry import Address
from email.mime.multipart import MIMEMultipart

from interlinked.core.config import Config
from interlinked.core.utilities import Utilities

logger = logging.getLogger(__name__)

# Monkey-patch MailParser's ADDRESSES_HEADERS to support Resent-*
# const.ADDRESSES_HEADERS.add('resent-to')
# const.ADDRESSES_HEADERS.add('resent-cc')
# const.ADDRESSES_HEADERS.add('resent-bcc')
# const.ADDRESSES_HEADERS.add('resent-from')


class MailClient:
    """
    All-in-one Mail client that allows you to read emails from an inbox, send emails, etc

    For sending emails, check out the `send` function
    """

    SMTP_PORT = 465
    SMTP_HOST = 'relay.apple.com'
    MESSAGE_ID_IDSTRING = 'interlinked.mail'
    MESSAGE_ID_DOMAIN = 'apple.com'

    IMAP_HOST = 'mail.apple.com'

    def __init__(self, imap_username: str = None, imap_password: str = None, imap_host: str = IMAP_HOST):
        """
        Initializes this client to use for reading emails

        Initializing is not needed for sending email. Instead, you can call `MailClient.send(…)` directly

        @param imap_username(str): Your IMAP username from appleconnect.apple.com (e.g. `jane@apple.com`)
        @param imap_password(str): Your IMAP password from appleconnect.apple.com
        @param imap_host(str): (Optional) Only set if you'd like to change the host name. Defaults to `mail.apple.com`
        """

        if imap_username is None or imap_password is None:
            raise Exception('username or password are None')

        try:
            from imapclient import IMAPClient

        except (ImportError, ModuleNotFoundError) as error:

            # for convenience, auto-install imapclient
            if Config.current.is_development:

                logger.section('installing imapclient…')
                Utilities.install_package(name='imapclient')

            from imapclient import IMAPClient

        self.imap_server = IMAPClient(host=imap_host, use_uid=True)
        self.imap_server.login(username=imap_username, password=imap_password)

    def get_emails(self, limit: int = None, unread_only: bool = True, folder_name: str = 'INBOX') -> list:
        """
        Fetches all unread emails in a user's mailbox        

        @param limit(int): (Optional) Limit the number of emails this function should return
        @param unread_only(bool): (Optional) Whether to only return unread emails
        @param folder_name(str): (Optional) Specify the folder to look in (For sent emails, use `folder_name='Sent Messages'`)
        """

        try:
            import mailparser

        except (ImportError, ModuleNotFoundError) as error:

            # for convenience, auto-install mailparser
            if Config.current.is_development:

                logger.section('installing mail-parser')
                Utilities.install_package(name='mail-parser')

            import mailparser

        self.imap_server.select_folder(folder_name)

        if unread_only:
            messages = self.imap_server.sort('ARRIVAL', 'UNSEEN')

        else:
            messages = self.imap_server.sort('REVERSE ARRIVAL')
        
        if limit and messages:
            messages = messages[:limit]

        response = self.imap_server.fetch(messages, ['BODY.PEEK[]'])

        for message_id, data in response.items():

            email_bytes: bytes = data[b'BODY[]']

            try:
                mail = mailparser.parse_from_bytes(email_bytes)
                yield(message_id, mail)

            except Exception as exception:
                
                # sometimes a UnicodeError happens due to malformed spam emails
                if 'rawunicodeescape' in str(exception):

                    try:

                        email_decoded: str = email_bytes.decode()

                        # since monkey-patching `parse` in mailparser is a bit tricky, we
                        # manually add encoding to the email ourselves
                        email_decoded = re.sub(r'^(--.*?)$', r'\1\nContent-Transfer-Encoding: quoted-printable', email_decoded, flags=re.MULTILINE)
                        mail = mailparser.parse_from_string(email_decoded)
                        yield(message_id, mail)

                    except Exception as exception:
                        logger.error(f'could not parse email ({message_id=})', exc_info=True)

                else:
                    raise exception

    def get_email_for_message_id(self, message_id: str, folder_name: str = 'INBOX') -> object:
        """
        Returns a MailParser object for a given message ID

        @param message_id(str): The ID of the message/email
        @param folder_name(str): (Optional) Specify the folder to look in (For sent emails, use `folder_name='Sent Messages'`)
        """

        try:
            import mailparser

        except (ImportError, ModuleNotFoundError) as error:

            # for convenience, auto-install mailparser
            if Config.current.is_development:

                logger.section('installing mailparser…')
                Utilities.install_package(name='mail-parser')

            import mailparser

        self.imap_server.select_folder(folder_name)
        messages: list = self.imap_server.search(['HEADER', 'Message-ID', message_id])

        response = self.imap_server.fetch(messages, ['BODY.PEEK[]'])

        if len(messages) > 0 and (data := response[messages[0]]) is not None:
            return mailparser.parse_from_bytes(data[b'BODY[]'])

        return None

    def mark_as_read(self, uids: list) -> None:
        """
        Marks a given message as read
        """

        self.imap_server.add_flags(uids, ['\\Seen'])

    def delete(self, uids: list) -> None:
        """
        Deletes a given message

        @param uids(list): a list of email UIDs to delete
        """

        self.imap_server.delete_messages(messages=uids)

    @classmethod
    def send(cls, from_address: str, to_addresses: list[str], cc_addresses: list[str] = None,
             bcc_addresses: list[str] = None, subject: str = None, body: str = None, reply_to_message_id: str = None,
             attachments: list = [], from_name: str = None, password: str = None, host: str = SMTP_HOST) -> str:
        """
        Sends an email. Since this is a classmethod, you can call this function
        using `MailClient.send(from_address=...)` without having to initalize `MailClient`.

        @param from_address(str): sender's email address (e.g. `noreply@apple.com`)
        @param to_addresses(list): a list of recipients' email addresses (e.g. `['test1@apple.com', 'test2@apple.com']`)
        @param cc_addresses(list): a list of recipients' email addresses to CC (e.g. `['test1@apple.com', 'test2@apple.com']`)
        @param bcc_addresses(list): a list of recipients' email addresses to BCC (e.g. `['test1@apple.com', 'test2@apple.com']`)
        @param subject(str): the subject of the email
        @param body(str): the body of the email
        @param reply_to_message_id(str): if this email is a reply to an existing email thread, pass the Message-ID of the thread (e.g. `<f4bdb5f0-87eb-11eb-a50b-d124217e9a@apple.com>`)
        @param attachments(list): a list of dict {`name`: file name, `path`: file path, `file_bytes`: file contents if path is not passed}
        @param from_name(str): sender's name (e.g. Apple)
        @param password(str): if you want to send the email over an authenticated channel (optional. if you don't pass one, the email will still be sent in TLS mode)
        @param host(str): if you want to send the email through a custom SMTP host (optional)
        @return (str): the Message-ID of the email this function sends
        """

        if from_address is None:
            raise Exception('missing "From" email address')

        message_id = email.utils.make_msgid(idstring=cls.MESSAGE_ID_IDSTRING,
                                            domain=cls.MESSAGE_ID_DOMAIN)

        message: EmailMessage = EmailMessage()

        # if no subject, set a default one
        if subject is None:
            subject = ''

        # we do this magic to satisfy the email library which may sometimes complain about certain subjects
        message['Subject'] = ' '.join(subject.replace('\n', ' ').replace('\t', ' ').replace('\r', ' ').splitlines())
        message['From'] = Address(display_name=from_name, addr_spec=from_address) if from_name else from_address

        if to_addresses:
            message['To'] = ', '.join(to_addresses)

        if cc_addresses:
            message['CC'] = ', '.join(cc_addresses)

        message['Message-id'] = message_id
        message['Date'] = email.utils.formatdate(localtime=True)

        if reply_to_message_id:
            message['In-reply-to'] = reply_to_message_id

        message.set_content(body)

        if '\n' not in body or '<html' in body or body.startswith('<'):
            message.add_alternative(body, subtype='html')

        # add attachments
        for attachment in attachments:

            name: str = attachment.get('name')
            path: str = attachment.get('path')
            file_bytes: bytes = attachment.get('file_bytes')

            if name is None or (path is None and file_bytes is None):
                raise Exception('invalid attachment name or (path and file_bytes)')

            base_file_name: str = os.path.basename(name)
            mimetype, _ = mimetypes.guess_type(base_file_name)

            if mimetype is None:
                mimetype = 'text/plain'

            maintype, subtype = mimetype.split('/', 1)

            if path:

                with open(path, 'rb') as file:
                    file_bytes = file.read()

            message.add_attachment(file_bytes, maintype=maintype, subtype=subtype, filename=base_file_name)

        context: SSLContext = ssl.create_default_context()

        to_addrs: list[str] = list(to_addresses) if to_addresses else []

        if cc_addresses:
            to_addrs.extend(cc_addresses)

        if bcc_addresses:
            to_addrs.extend(bcc_addresses)

        if password:

            with smtplib.SMTP_SSL(host=host, port=cls.SMTP_PORT, context=context) as server:

                server.login(user=from_address, password=password)
                server.sendmail(from_addr=from_address, to_addrs=to_addrs, msg=message.as_string())
        else:

            server = smtplib.SMTP(host=host)
            server.starttls()
            server.sendmail(from_addr=from_address, to_addrs=to_addrs, msg=message.as_string())

        return message_id

    """ Helper functions """

    @classmethod
    def get_is_bounce(cls, from_address: str) -> bool:
        """
        Checks if a given from email address is a bounce email

        @param from_address(str): an email address
        @return (bool): whether this email is a bounce or not
        """

        lower_email: str = from_address.lower()
        return lower_email.startswith(('postmaster@', 'mailer-daemon@'))

    @classmethod
    def get_is_autoreply(cls, from_address: str) -> bool:
        """
        Checks if a given from email address is an autoreply (e.g. Clipper)

        @param from_address(str): an email address
        @return (bool): whether this email is an auto-reply
        """

        return from_address in {'do-not-reply@clipper.pie.apple.com'}
