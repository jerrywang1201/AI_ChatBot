import re
import requests
from time import sleep
from typing import Any, Optional
from collections import defaultdict
from ldap3.abstract.entry import Entry
from appledirectory import AppleDirectory
from pydantic import BaseModel, PrivateAttr
from appledirectory.endpoint.nod import NodEndpoint
from appledirectory.exceptions import ServiceFailure
from appledirectory.endpoint.lookup import LookupEndpoint

from interlinked.core.config import Config
from interlinked.core.utilities import Utilities
from interlinked.core.singleton import SingletonMeta


class Person(BaseModel):
	"""
	Represents an internal person
	"""

	dsid: int = None
	first_name: str = None
	last_name: str = None
	email: Optional[str] = None
	department_number: str = None

	# e.g. `AP01:7`
	location_code: Optional[str] = None

	# [Internal]
	employee_type: Optional[str] = None

	_slack_member_id: Optional[str] = PrivateAttr(default=None)
	_manager: Optional[str] = PrivateAttr(default=None)
	_direct_reports: Optional[list['Person']] = None

	@property
	def name(self) -> str:
		"""
		Returns this person's full name
		"""
		return f'{self.first_name} {self.last_name}'

	@property
	def slack_member_id(self) -> str:
		"""
		Returns the Slack member ID of this person
		"""

		if self._slack_member_id:
			return self._slack_member_id

		if not self.dsid:
			return None

		aim_official: str = AppleDirectoryClient.shared.get_user_by_dsid(dsid=self.dsid, attributes=['appleAIMOfficial']).appleAIMOfficial.value

		if aim_official and '@im.' in aim_official:
			aim_official = AppleDirectoryClient.shared.get_user_by_dsid(dsid=self.dsid, attributes=['appleAIMPreferred']).appleAIMPreferred.value

		if aim_official:
			self._slack_member_id = aim_official.split('|')[0]

		return self._slack_member_id

	@property
	def manager(self) -> 'Person':
		"""
		Returns the manager of this person
		"""

		if self._manager:
			return self._manager

		if not self.dsid:
			return None

		manager_raw: str = AppleDirectoryClient.shared.get_user_by_dsid(dsid=self.dsid, attributes=['appleManager']).appleManager.value

		if not manager_raw:
			return None

		manager_raw = manager_raw.split('|')
		manager: Person = Person(first_name=manager_raw[0], last_name=manager_raw[1], dsid=manager_raw[2], email=manager_raw[3])
		return manager

	@property
	def svp(self) -> 'Person':
		"""
		Returns the SVP of this person
		"""

		manager: Person = self.manager

		while manager.manager and manager.manager.dsid != 115284:
			manager = manager.manager

		return manager

	@property
	def direct_reports(self) -> 'Person':
		"""
		Returns the direct reports of this person
		"""

		if self._direct_reports:
			return self._direct_reports

		if not self.dsid:
			return None

		persons: list[Person] = []
		person_raw: 'Attribute' = AppleDirectoryClient.shared.get_user_by_dsid(dsid=self.dsid, attributes=['appleDirectReports'])

		if not person_raw:
			return

		direct_reports: list[Person] = []
		direct_reports_raw: list[str] = person_raw.appleDirectReports.value

		if isinstance(direct_reports_raw, str):
			direct_reports_raw = [direct_reports_raw]

		for direct_report_raw in (direct_reports_raw or []):

			direct_report_raw: list[str] = direct_report_raw.split('|')
			direct_reports.append(Person(first_name=direct_report_raw[1], last_name=direct_report_raw[0], dsid=direct_report_raw[2]))

		self._direct_reports = direct_reports
		return self._direct_reports

	@property
	def is_bot(self) -> bool:
		"""
		Returns `True` if this person is a bot
		"""
		return len(re.findall(r'\b(System|Bot|User)\b', self.name, flags=re.IGNORECASE)) > 0

	def __eq__(self, other: 'Person') -> bool:
		return self.dsid == other.dsid

	def __hash__(self) -> int:
		return hash(self.dsid)


class Room(BaseModel):
	"""
	Represents an internal conference room
	"""

	dsid: int = None
	name: str = None
	email: Optional[str] = None
	building_name: Optional[str] = None
	_apple_map_info: Optional[str] = None

	@property
	@Utilities.dynamic
	def name(self) -> str:
		"""
		Returns this person's full name
		"""

		return f'{self.name}'

	def __eq__(self, other: 'Room') -> bool:
		return self.dsid == other.dsid

	def __hash__(self) -> int:
		return hash(self.dsid)


class Building(BaseModel):
	"""
	Represents an internal building
	"""

	dsid: int = None
	name: str = None
	address: str = None
	abbreviation: str = None

	@property
	@Utilities.dynamic
	def name(self) -> str:
		"""
		Returns this person's full name
		"""

		return f'{self.name}'

	def __eq__(self, other: 'Building') -> bool:
		return self.dsid == other.dsid

	def __hash__(self) -> int:
		return hash(self.dsid)


class AppleDirectoryClient(AppleDirectory, metaclass=SingletonMeta):

	@SingletonMeta.Shared
	def shared(cls) -> 'AppleDirectoryClient':
		return cls(shared=True)

	def get_groups_by_name(self, name: str) -> list[dict[str, Any]]:
		"""
		Returns a group with a given name.

		@param name(str): The name of the group
		@return (list): A list Apple Directory groups (dictionaries)
		"""

		group: Entry = super(AppleDirectoryClient, self).get_group_by_name(name=name)

		if not group:
			return []

		return [{

			'name': group.cn.value,
			'dsid': int(group.appledsId.value),
			'email': group.appleGroupEmail.value,
		}]

	def get_group_dsids_for_person_dsid(self, dsid: int) -> list[int]:
		"""
		Returns a list of group DSIDs a person is part of.

		@param dsid(int): The dsid of the person
		@return (list): A list of DSIDs
		"""

		group_membership = self.query(
			attribute=self.endpoint.GROUP_MEMBER_SEARCH_ATTRIBUTE,
			value=dsid,
			search_base=self.endpoint.GROUP_MEMBER_SEARCH_BASE,
			object_class=self.endpoint.GROUP_MEMBER_OBJECT_CLASS,
			return_attributes=['applegroupid'],
		)
		return [int(group_membership.applegroupid.value) for group_membership in group_membership]

	def get_is_group_has_nested(self, dsid: int) -> bool:
		"""
		Returns whether a group has nested groups.

		@param dsid(int): The dsid of the group
		@return (bool): Whether the group has nested groups
		"""

		members: list[Entry] = self.get_group_members_by_dsid(
			dsid=dsid, attributes=self.endpoint.DEFAULT_GROUP_MEMBER_ATTRIBUTES + ['appleUniqueMember', 'appleUniqueGroupMember'])

		persons: list[Person] = []

		for member in members:

			if (sub_group_dsid := member.appleUniqueGroupMember.value) is not None:
				return True

		return False

	def get_persons_by_name(self, name: str) -> list[Person]:
		"""
		Returns a list of Persons with a given name.

		@param name(str): The name of the person
		@return (list): A list of Person objects
		"""

		if '*' not in name:
			name = f'*{name}*'

		# encode parentheses
		name = name.replace('(', '\\28').replace(')', '\\29')

		persons: list[Person] = []
		persons_raw: list = self.get_user_by_name(name=name, attributes=['mail', 'name', 'appledsId', 'appleUniqueMemberGivenname', 'appleUniqueMemberSN',
																		 'appleUniqueMember', 'appleUniqueGroupMember', 'appleDirectReports', 'employeeType'])

		for person_raw in persons_raw:

			direct_reports: list[Person] = []
			direct_reports_raw: list[str] = person_raw.appleDirectReports.value

			if isinstance(direct_reports_raw, str):
				direct_reports_raw = [direct_reports_raw]

			for direct_report_raw in (direct_reports_raw or []):
				direct_report_raw: list[str] = direct_report_raw.split('|')
				direct_reports.append(Person(first_name=direct_report_raw[1], last_name=direct_report_raw[0], dsid=direct_report_raw[2]))

			person: Person = Person(first_name=person_raw.givenName.value, last_name=person_raw.sn.value,
									dsid=person_raw.appledsId.value, email=person_raw.mail.value, direct_reports=direct_reports,
									employee_type=person_raw.employeeType.value)

			persons.append(person)

		# sort so that Vendors come last, keeping original order for everything else
		# `Vendor` is not same as `On-site Vendor (V)`. By default, Apple Directory does not show vendors
		persons.sort(key=lambda person: person.employee_type == 'Vendor')
		return persons

	def get_person_for_dsid(self, dsid: int) -> Person:
		"""
		Returns a Person for a given DSID.

		@param dsid(int): The dsid of the person
		@return (Person): a Person
		"""

		persons: list[Person] = []
		person_raw: 'Attribute' = self.get_user_by_dsid(dsid=dsid, attributes=['mail', 'name', 'appledsId', 'appleUniqueMemberSN',
																			   'departmentnumber', 'appleManager', 'appleDirectReports',
																			   'appleLocationCd'])

		if not person_raw:
			return

		manager: Person = None

		if manager_raw := person_raw.appleManager.value:

			manager_raw = manager_raw.split('|')
			manager: Person = Person(first_name=manager_raw[0], last_name=manager_raw[1], dsid=manager_raw[2], email=manager_raw[3])

		direct_reports: list[Person] = []
		direct_reports_raw: list[str] = person_raw.appleDirectReports.value

		if isinstance(direct_reports_raw, str):
			direct_reports_raw = [direct_reports_raw]

		for direct_report_raw in (direct_reports_raw or []):

			direct_report_raw: list[str] = direct_report_raw.split('|')
			direct_reports.append(Person(first_name=direct_report_raw[1], last_name=direct_report_raw[0], dsid=direct_report_raw[2]))

		return Person(first_name=person_raw.givenName.value, last_name=person_raw.sn.value,
					  dsid=person_raw.appledsId.value, email=person_raw.mail.value,
					  department_number=person_raw.departmentnumber.value, _manager=manager,
					  direct_reports=direct_reports, location_code=person_raw.appleLocationCd.value)

	def get_person_for_email_address(self, email_address: str) -> Person:
		"""
		Returns a Person for a given email address.

		@param email_address(str): The email address of the person
		@return (Person): a Person
		"""

		persons: list[Person] = []
		person_raw: 'Attribute' = self.get_user_by_email(email=email_address,
														 attributes=['mail', 'name', 'appledsId', 'appleUniqueMemberSN', 'appleLocationCd'])

		if not person_raw:
			return

		return Person(first_name=person_raw.givenName.value, last_name=person_raw.sn.value,
					  dsid=person_raw.appledsId.value, email=person_raw.mail.value, location_code=person_raw.appleLocationCd.value)

	def get_person_for_slack_member_id(self, member_id: str) -> Person:
		"""
		Returns a Person for a given Slack member ID.

		@param member_id(str): The member ID of the person (e.g. `WNCETJFMF`)
		@return (Person): a Person
		"""

		if '|' in member_id:
			member_id = member_id.split('|')[0]

		persons: list[Person] = []
		persons_raw: list['Attribute'] = AppleDirectoryClient(endpoint=LookupEndpoint).  \
			query(attribute='appleAIMOfficial', value=f'{member_id}|Slack',
				  search_base=LookupEndpoint.USER_SEARCH_BASE,
				  object_class=LookupEndpoint.USER_OBJECT_CLASS,
				  return_attributes=['mail', 'name', 'appledsId', 'appleUniqueMemberSN'])

		if not persons_raw:

			persons_raw = AppleDirectoryClient(endpoint=LookupEndpoint).  \
				query(attribute='appleAIMPreferred', value=f'{member_id}|Slack',
					  search_base=LookupEndpoint.USER_SEARCH_BASE,
					  object_class=LookupEndpoint.USER_OBJECT_CLASS,
					  return_attributes=['mail', 'name', 'appledsId', 'appleUniqueMemberSN'])

		if not persons_raw:
			return

		person_raw: 'Attribute' = persons_raw[0]
		return Person(first_name=person_raw.givenName.value, last_name=person_raw.sn.value,
					  dsid=person_raw.appledsId.value, email=person_raw.mail.value)

	def get_persons_for_group_dsid(self, dsid: int, nested: bool = True) -> list[Person]:
		"""
		Returns a list of Persons inside of a group (traverses through the group).

		@param dsid(int): An Apple Directory group ID
		@return (list): A list of Person objects
		"""

		members: list[Entry] = self.get_group_members_by_dsid(
			dsid=dsid, attributes=self.endpoint.DEFAULT_GROUP_MEMBER_ATTRIBUTES + ['appleUniqueMember', 'appleUniqueGroupMember'])

		persons: list[Person] = []

		for member in members:

			if (sub_group_dsid := member.appleUniqueGroupMember.value) is not None:

				if nested:
					persons = list(set(persons + self.get_persons_for_group_dsid(dsid=sub_group_dsid, nested=nested)))

				continue

			person: Person = Person(first_name=member.appleUniqueMemberGivenname.value, last_name=member.appleUniqueMemberSN.value,
									dsid=member.appleUniqueMember.value, email=member.mail.value)

			persons.append(person)

		return list(set(persons))

	def get_matching_group_dsids(self, group_dsids: list[int], person_dsid: int) -> list[int]:
		"""
		Returns whether a person is in a group. Supports nested groups
		"""

		max_retries: int = 3
		retry_count: int = 0

		while retry_count < max_retries:

			try:
				apple_directory_client: AppleDirectoryClient = AppleDirectoryClient(endpoint=NodEndpoint)
				user_group_dsids: list[int] = [int(group.gidNumber.value) for group in apple_directory_client.get_groups_for_user_dsid(dsid=person_dsid)]
				return [group_dsid for group_dsid in group_dsids if group_dsid in user_group_dsids]

			except ServiceFailure:

				retry_count += 1

				if retry_count >= max_retries:
					raise

				sleep(1)

	def get_opendirectory_username_for_dsid(self, dsid: str) -> str:
		"""
		Returns the OpenDirectory (OD) username for a given DSID.

		@param dsid(int): The DSID of the person too look up
		@return (str): The OpenDirectory username
		"""

		# inefficient init every time this is called
		user: Any = AppleDirectory(endpoint=NodEndpoint).get_user_by_dsid(dsid, attributes=['uid'])

		if not user:
			raise Exception(f'{dsid} has no OpenDirectory account')

		uid: list[str]|str = user.uid.value

		if not uid:
			return None

		if isinstance(uid, list):

			# most `uid` values are a list with the OpenDirectory user name + AppleConnect
			# e.g. `['interlinked', 'interlinked@APPLECONNECT.APPLE.COM']`
			uid = next((_uid for _uid in uid if '@' not in _uid), None)

		return uid

	def get_opendirectory_username_for_name(self, name: str) -> str:
		"""
		Returns the OpenDirectory (OD) username for a given name

		@param name(int): The full name of the person to look up
		@return (str): The OpenDirectory username
		"""

		# inefficient init every time this is called
		persons: list[Person] = self.get_persons_by_name(name=name)

		if not persons:
			raise Exception(f'Could not find anyone with the name "{name}"')

		return self.get_opendirectory_username_for_dsid(dsid=persons[0].dsid)

	def get_meeting_room_by_dsid(self, dsid: int) -> Room:
		"""
		Returns a Meeting for a given DSID.

		@param dsid(int): The dsid of the Meeting room
		@return (Room): a Room
		"""

		rooms_raw = self.get_conference_room_by_dsid(dsid=dsid)

		if not rooms_raw:
			return

		return Room(name=rooms_raw.cn.value, dsid=dsid,
					email=rooms_raw.mail.value, building_name=rooms_raw.buildingname.value,
					_apple_map_info=rooms_raw.appleMapMetaInfo.value)

	def get_conference_room_by_query(self, query: str|list) -> list[Room]:
		"""
		Find conference rooms in the directory by its name, building name or email and return details about them.

		@param query(str|list): Query to search the conference room.

		@return list[Room]: A list of Rooms
		"""

		if type(query) is list:
			name = [f'*{query_item.lower()}*' for query_item in query if type(query_item) is str]

		elif type(query) is str:
			name = f'*{query.lower()}*'

		merged_rooms = defaultdict(dict)

		for lookup in ['cn', 'mail', 'applesearchtext']:

			conf_rooms = self.query(
				attribute=lookup,
				value=name,
				search_base=self.endpoint.CONF_ROOM_SEARCH_BASE,
				object_class=self.endpoint.CONF_ROOM_OBJECT_CLASS,
				return_attributes=['appleDSID', 'cn', 'mail',
									'buildingName', 'appleMapMetaInfo', 'applesearchtext', 'applefloor'],
			)

			# finding unique rooms
			for room in conf_rooms:

				ds_id = room.appleDSID.value
				merged_rooms[ds_id] = room

		rooms = []

		for cn, room_data in merged_rooms.items():
			rooms.append(Room(name=room_data.cn.value, dsid=room_data.appledsId.value, email=room_data.mail.value,
							  building_name=room_data.buildingname.value, _apple_map_info=room_data.appleMapMetaInfo.value))

		return rooms

	def get_buildings_by_query(self, query: str) -> list[Building]:
		"""
		Find buildings in the directory by its name or abbreviation and return details about them.

		@param query(str|list): Query to search the building.

		@return list[Building]: A list of Buildings
		"""

		query = f'*{query.lower()}*'

		merged_buildings = defaultdict(dict)

		# Apple Park -> Apple Park 1
		if 'apple park' in query.lower():

			pattern = r'(apple park) (section .+)'
			replacement = r'\1 1 \2'
			query = re.sub(pattern, replacement, query)

		for lookup in ['appleBldgAbbr', 'appleBldgNm']:

			buildings = self.query(
				attribute=lookup,
				value=query,
				search_base=self.endpoint.BUILDING_SEARCH_BASE,
				object_class=self.endpoint.BUILDING_OBJECT_CLASS,
				return_attributes=['appleDSID', 'appleBldgNm', 'appleBldgAbbr',
								   'appleBldgCity', 'appleBldgCountry']
			)

			buildings_list = list(buildings)

			# finding unique buildings
			for building in buildings_list:

				ds_id = building.appleDSID.value
				merged_buildings[ds_id] = building

		buildings = []

		for cn, building_data in merged_buildings.items():
			buildings.append(Building(name=building_data.appleBldgNm.value, dsid=building_data.appledsId.value,
									  abbreviation=building_data.appleBldgAbbr.value, address=f'{building_data.appleBldgCity.value} {building_data.appleBldgCountry.value}'))

		return buildings

	def get_meeting_rooms(self, query: str) -> list[Room]:
		"""
		Looks up the meeting rooms by its name, or it's location, or it's building name.

		@param query(str): Query to look up the meeting room by name or by location
		@return list[Room]: List of meeting rooms
		"""

		rooms: list[Room] = self.get_conference_room_by_query(query=query)

		# Look up room based on the building
		building_names = self.get_buildings_by_query(query)

		for building in building_names:
			rooms.extend(self.get_conference_room_by_query(query=building.abbreviation))

		# Unique rooms
		rooms = list({room.dsid: room for room in rooms}.values())

		return rooms

	def add_to_group(self, dsid: str, group_dsid: str, type: int = 1, app_id: str = None, app_password: str = None,
					 username: str = None, password: str = None):
		"""
		[Internal]
		Add a person or group to a group.

		@param dsid(int): The DSID of the person to add
		@param type(int): Any of [1, 2, 3, 4, 5] (see chorus.apple.com/page/2214914)
		@param group_dsid(int): The AppleDirectory group ID
		@param app_id(int): The AppleConnect ID of the person to add
		@param app_password(str): The AppleConnect password of the person to add
		@param username(str): The username of your AppleConnect System account
		@param password(str): The password of your AppleConnect System account
		"""

		app_id = app_id or Config.current.IDMS_APP_ID
		username = username or Config.current.APPLECONNECT_USERNAME
		password = password or Config.current.APPLECONNECT_PASSWORD
		app_password = app_password or Config.current.IDMS_APP_PASSWORD

		user_session: str = Utilities.get_user_session(app_id=app_id, app_password=app_password, username=username, password=password)
		payload: dict[str, Any] = {

			'groupID': group_dsid,
			'dSRequest': {

				'session': {'userSession': user_session},
				'appCredentials': {'appID': app_id, 'appPassword': app_password}
			}
		}

		if type == 1:
			payload['dsGroupMembers'] = [{'groupMemberType': type, 'personMember': {'personID': dsid}, 'is_updated': True}]

		elif type == 2:
			payload['dsGroupMembers'] = [{'groupMemberType': type, 'groupMember': {'groupID': dsid}, 'is_updated': True}]

		response = requests.post('https://idms-int-rsvc.corp.apple.com/service/grpservice/addGroupMember',
								 headers={'appid': app_id, 'apppwd': app_password}, json=payload)

		response.raise_for_status()
		response_json: dict[str, Any] = response.json()

		if (error_code := response_json.get('errorCode')) and error_code != -20326:
			raise Exception(f'Could not add to group ({dsid=}, {group_dsid=}, error={response_json.get("errorMsg")})')


if __name__ == '__main__':
	print(AppleDirectoryClient.shared.get_person_for_dsid(dsid=2319733545))