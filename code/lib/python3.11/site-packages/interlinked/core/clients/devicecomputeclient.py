import re
import json
import base64
import logging
import requests
from time import sleep
from typing import Any

from interlinked.core.config import Config
from interlinked.core.utilities import Utilities
from interlinked.core.singleton import SingletonMeta

logger = logging.getLogger(__name__)


class DeviceComputeClient(metaclass=SingletonMeta):
	"""
	This client allows you to interact with devicecompute.apple.com to create
	virtual machines, and more
	"""

	BASE_URL: str = 'https://api-int.devicecompute.apple.com'

	shared: 'DeviceComputeClient' = None

	def __init__(self, daw_token: str = None):
		"""
		Initializes this client
     
		@param daw_token(str): (Optional) If not provided, your local AppleConnect session will be used
		"""

		self.session = requests.session()
		self.session.cookies['acack'] = daw_token
		self.session.headers['Accept-Encoding'] = 'deflate'
		self.session.headers['Content-Type'] = 'application/json'

		if not daw_token and Config.current.is_development:
			self.session.cookies['acack'] = Utilities.get_apple_connect_token(app_id=Config.current.IDMS_APP_ID)

	@SingletonMeta.Shared
	def shared(cls) -> 'DeviceComputeClient':
		return cls(shared=True)

	""" Jobs """

	def create_job(self, capabilities: dict[str], wait: bool = False) -> str:
		"""
		Creates a job (a virtual machine)

		@param capabilities(dict): capabilities can be found on devicecompute.apple.com
		@param wait(bool): if True, this function will wait until a session is created
		@return (str): if wait is True, the session ID will be returned. otherwise, job ID will be returned
		"""

		data: dict[str, Any] = {

			'maximumProvisioningAttempts': 2,
			'sessionCreationTimeout': '3600s',
			'capabilities': {'alwaysMatch': capabilities},
		}

		response = self.session.post(f'{self.BASE_URL}/v1alpha/jobs', data=json.dumps(data))

		if not response.ok:
			logging.error(response.text)

		response.raise_for_status()

		job: dict[str, Any] = response.json()
		job_id: str = job.get('jobId')

		if wait:

			job_status: str = self.get_job_status(id=job_id)

			while job_status in {'QUEUED', 'SELECTING', 'CREATING', 'REQUESTING_VM'}:

				sleep(2)
				job_status = self.get_job_status(id=job_id)

			if job_status == 'COMPLETED':

				job = self.get_job(id=job_id)
				return job.get('session', {}).get('sessionId')

			else:
				raise Exception(f'failed to create job: {job_status}')

		return job_id

	def get_job_status(self, id: str) -> str:
		"""
		Returns the status of a job
		"""
		response = self.session.get(f'{self.BASE_URL}/v1alpha/jobs/{id}/status')
		response.raise_for_status()

		return response.json().get('status')

	def get_job(self, id: str) -> dict[str, Any]:
		"""
		Returns a job
		"""
		response = self.session.get(f'{self.BASE_URL}/v1alpha/jobs/{id}')
		response.raise_for_status()

		return response.json()

	""" Interactions """

	def push_file(self, file_content: str|bytes, to_path: str, session_id: str) -> None:
		"""
		Pushes/Uploads a file to a given device

		@param file_content(str): a base64-encoded file or raw bytes
		"""

		if isinstance(file_content, bytes):
			file_content = base64.b64encode(file_content).decode()

		data: dict[str, Any] = {

			'path': to_path,
			'file': file_content,
		}

		response = self.session.post(f'{self.BASE_URL}/session/{session_id}/trieste/device/file/push', data=json.dumps(data))

		if not response.ok:
			logger.error(f'could not push file: {response.text}')

		response.raise_for_status()

	def run_command(self, command: str, args: list[str], session_id: str, user: str = None) -> tuple[str, str]:
		"""
		Runs a given command
		"""

		data: dict[str, Any] = {'path': command, 'args': args}

		if user:
			data['user'] = user

		response = self.session.post(f'{self.BASE_URL}/session/{session_id}/trieste/execute/file', data=json.dumps(data))
		response.raise_for_status()

		response_json: dict[str, Any] = response.json()
		value: str = response_json.get('value', {})

		stderr_base64: str = value.get('standardErrorBase64')
		stdout_base64: str = value.get('standardOutputBase64')

		stdout: str = base64.b64decode(stdout_base64).decode().strip()
		stderr: str = base64.b64decode(stderr_base64).decode().strip()

		return stdout, stderr

	""" Metadata """

	def get_pid_for_name(self, name: str, session_id: str) -> int:
		"""
		Returns the pid of a given process name (if running)

		@param name(str): the name of the process
		@return (int): the pid of the process
		"""

		pid, _ = self.run_command(command='pgrep', args=['-n', name], session_id=session_id)
		return pid

	def get_username_for_pid(self, pid: int, session_id: str) -> str:
		"""
		Returns the username of a given pid

		@param pid(int): the pid of the process
		@return (str): the username of the process
		"""

		user_name, _ = self.run_command(command='ps', args=['-o', 'user=', pid], session_id=session_id)
		return user_name

	def get_storage_class_for_path(self, path: str, session_id: str) -> str|list[str]:
		"""
		Returns the storage class for a given path

		@param path(str): a relative or full path (can also have a wildcard `*`)
		@return (str|list): if the path is not a wildcard, a single string is returned with the storage class
		"""

		path = path.replace('\\', '')

		stdout, stderr = self.run_command(command='/usr/local/bin/sbutil', args=['classify', path], session_id=session_id)

		if '*' in path:
			return stdout

		storage_class: str = stdout.rsplit(':', 1)[-1].strip()
		return storage_class

	def get_sandbox_profile_for_pid(self, pid: int, session_id: str) -> tuple[str, bool]:
		"""
		Returns the sandbox profile for a given pid

		@param pid(int): the pid of the process
		@return (tuple): (str) the full sandbox profile of the process, (bool) whether the process is sandboxed
		"""

		sandbox_profile, _ = self.run_command(command='/usr/local/bin/sbutil', args=['inspect', '-p', pid], user='root', session_id=session_id)
		is_sandboxed: bool = sandbox_profile.split('\n')[0].endswith(' sandboxed.')

		return sandbox_profile, is_sandboxed

	def get_path_for_service(self, service_name: str, session_id: str) -> tuple[str, bool]:
		"""
		Returns the binary path for a given service

		@param service_name(str): the name of the mach service (e.g. `com.apple.gamed`)
		@return (str): the binary path for the service
		"""

		stdout, stderr = self.run_command(command='launchctl', args=['kickstart', f'gui/501/{service_name}'], session_id=session_id)
		stdout, stderr = self.run_command(command='launchctl', args=['print', f'gui/501/{service_name}'], session_id=session_id)
		matches: list[str] = re.findall(string=stdout, pattern=r'program = (.*?)$', flags=re.MULTILINE)

		if not matches:
			return None

		return matches[0]

	def get_entitlements_for_binary(self, binary_path: str, session_id: str) -> str:
		"""
		Returns the entitlements for a given binary (in XML format)

		@param binary_path(str): the path of the binary
		@return (str): the entitlements in XML format
		"""

		stdout, stderr = self.run_command(command='codesign', args=['-d', '--entitlements=-', '--xml', binary_path], session_id=session_id)

		# codesign is not available on embedded for some reason
		if 'command not found' in stderr:
			stdout, stderr = self.run_command(command='sbshell', args=['-ent', binary_path], session_id=session_id)

		return stdout

	def get_entitlements_for_name(self, process_name: str, session_id: str) -> str:
		"""
		Returns the entitlements for a given process name

		@param process_name(str): the name of the process
		@return (str): the entitlements in XML format
		"""

		pid = self.get_pid_for_name(name=process_name, session_id=session_id)
		entitlements = self.get_entitlements_for_binary(binary_path=binary_path, session_id=session_id)

		return entitlements

	def get_contents_for_path(self, path: str, session_id: str) -> list[str]:
		"""
		Returns the contents of a given directory

		@param path(str): the path to the directory
		@return (list): if the path is not a directory, `None` is returned
		"""

		# `ls -la` won't list contents if the path doesn't end with `/`
		if not path.endswith('/'):
			path = f'{path}/'

		stdout, stderr = self.run_command(command='ls', args=['-la', path], session_id=session_id)

		if stderr:
			raise Exception(stderr)

		contents: list[str] = stdout.split('\n')

		if contents[0].startswith('total '):
			contents.pop(0)

		return contents
