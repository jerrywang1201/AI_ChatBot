import logging
import requests
from typing import Any

from interlinked.core.singleton import SingletonMeta

logger = logging.getLogger(__name__)
DEFAULT_STASH_BASE_URL = 'https://stashweb.sd.apple.com/rest/api/1.0'

class StashWebClient(metaclass=SingletonMeta):
	"""
	Client for interacting with Stash (Bitbucket Server) Web API via a
	[Stash HTTP Access Token](https://confluence.atlassian.com/bitbucketserver/http-access-tokens-939515499.html)
	"""

	base_url: str = None
	session: requests.Session = None
	token: str = None

	def __init__(self, token: str, base_url: str = None):
		"""
		Initialize the StashWebClient instance with the provided API token and
		Stash instance to use. 

		@param api_token(str): Personal access token for Stash API
		@param base_url(str): (Optional) The Stash (Bitbucket Server) instance
		 					  to use. Defaults to https://stashweb.sd.apple.com/rest/api/1.0
		"""

		# prefix `base_url` if it doesn't have `https://â€¦`
		if base_url and not base_url.startswith('http'):
			base_url = f'https://{base_url}'

		self.token = token
		self.base_url = base_url or DEFAULT_STASH_BASE_URL
		self.headers = {
			'Accept': 'application/json',
			'Authorization': f'Bearer {self.token}',
		}

		self.session = requests.Session()
		self.session.headers.update(self.headers)

		logging.basicConfig(level=logging.INFO)
		
	@SingletonMeta.Shared
	def shared(cls) -> 'StashWebClient':
		return cls(shared=True)

	""" Utilities """
	def make_request(self, method: str, endpoint: str, headers: dict[str, str] = None,
					 data: dict[str, Any] = None, params: dict[str, Any] = None) -> dict:
		"""
		Make a HTTP request to the Stash API
		
		@param method: The HTTP method to use (e.g., 'GET', 'POST').
		@param endpoint: The API endpoint to target.
		@param headers: Additional headers to send with the request
		@param data: Data to send in the body of the request
		@param params: Additional parameters to send in the body of the request
		@return: The JSON response from the API as a dictionary
		"""

		full_url = f'{self.base_url}{endpoint}'

		if not headers:
			headers = {}

		if params:
			response = requests.request(method, full_url, headers=headers, json=data, params=params)

		else:
			response = requests.request(method, full_url, headers=headers, json=data)

		if response.status_code == 204:
			return {'status': 'ok'}

		if not response.ok:
			logging.error(response.text)

		response.raise_for_status()

		return response.json()
	
	@classmethod
	def parse_changes(self, raw_diff_data: list) -> list:
		"""
		Parse the raw diff data into list of changes, including file path and patches.
		Patches of a file are concatenated into a single string that mimics the content of a .patch file.

		@param raw_diff_data(list): The raw diff data obtained from Stash API
		@return: List of files changes, including the patches, from the diff data
		"""
		changes = []

		for diff_item in raw_diff_data:
			change = {}

			# Destination/source field is None for deleted/newly added files
			change['path'], change['old_path'] = '', ''
			if 'destination' in diff_item and diff_item['destination']: 
				change['path'] = diff_item['destination'].get('toString', '')
			if 'source' in diff_item and diff_item['source']:
				change['old_path'] = diff_item['source'].get('toString', '')

			if change['path'] != change['old_path']:
				change['type'] = 'MOVE'
			else:
				change['type'] = 'MODIFIED'

			# Extract patch information
			hunks = diff_item.get('hunks', [])
			patch_content = ""
			added_line_counter: int = 0
			starting_line_number: int = 0

			for hunk in hunks:
				hunk_header = f"@@ -{hunk.get('sourceLine', 0)},{hunk.get('sourceSpan', 0)} +{hunk.get('destinationLine', 0)},{hunk.get('destinationSpan', 0)} @@\n"
				patch_content += hunk_header
				segments = hunk.get('segments', [])
				for segment in segments:
					lines = segment.get('lines', [])
					for line in lines:
						line_content = line.get('line', '').replace('\n', '') + '\n'
						segment_type = segment.get('type')

						if segment_type == 'ADDED':
							patch_content += f"+{line_content}"
							added_line_counter += 1
							if not starting_line_number:
								starting_line_number = line.get('destination', 0)
						elif segment_type == 'REMOVED':
							patch_content += f"-{line_content}"
						elif segment_type == 'CONTEXT':
							patch_content += f" {line_content}"

				change['patch'] = patch_content
				change['line_ending_number'] = starting_line_number + added_line_counter - 1 if starting_line_number else 0
				
			changes.append(change)

		return changes

	""" Pull Reqeusts """
	def approve_pull_request(self, id: int, project_key: str, repository_slug: str) -> dict:
		"""
		https://docs.atlassian.com/DAC/rest/stash/3.11.3/stash-rest.html#idp549472
		Approve a pull request.

		@param id(int): The ID of the pull request to approve
		@param project_key(str): The project key, i.e. owner/organization name
		@param repository_slug(str): The repository slug, i.e. repository name
		@return: A dictionary of the API response
		"""

		endpoint = f'/projects/{project_key}/repos/{repository_slug}/pull-requests/{id}/approve'
		return self.make_request('POST', endpoint=endpoint, headers=self.headers)

	def post_comment_to_pull_request(self, id: int, project_key: str, repository_slug: str, body: str) -> dict:
		"""
		https://docs.atlassian.com/DAC/rest/stash/3.11.3/stash-rest.html#idp1448560
		Post a comment to a pull request
		
		@param id(int): The ID of the pull request to comment on
		@param project_key(str): The project key, i.e. owner/organization name
		@param repository_slug(str): The repository slug, i.e. repository name
		@param body(str): The content of the comment to post
		@return: A dictionary of the API response
		"""
		endpoint = f'/projects/{project_key}/repos/{repository_slug}/pull-requests/{id}/comments'
		data = {'text': body}

		return self.make_request('POST', endpoint=endpoint, headers=self.headers, data=data)

	def list_pull_requests(self, project_key: str, repository_slug: str, state: str = 'OPEN', max_count: int = 30) -> list[dict]:
		"""
		https://docs.atlassian.com/DAC/rest/stash/3.11.3/stash-rest.html#idp36368
		Retrieve a list of pull requests for the repository
		By default, By default, returns open pull requests, but can be modified by the state parameter

		@param project_key(str): The project key, i.e. owner/organization name
		@param repository_slug(str): The repository slug, i.e. repository name
		@param state(str): The state of the pull requests to return. Can be 'OPEN', 'DECLINED', 'MERGED' or 'ALL'
		@param max_count(int): The maximum number of pull requests to be returned
		@return: A list containing pull request data

		"""
		endpoint = f'/projects/{project_key}/repos/{repository_slug}/pull-requests'
		params = {
			'limit': max_count,
			'state': state
		}

		result = self.make_request('GET', endpoint=endpoint, headers=self.headers, params=params)
		return result['values']

	def get_pull_request_changes(self, id: int, project_key: str, repository_slug: str) -> list[dict]:
		"""
        https://docs.atlassian.com/DAC/rest/stash/3.11.3/stash-rest.html#idp1811216
		Get the file changes in a pull request with at most 1000 changed files.

        @param id(int): The ID of the pull request
		@param project_key(str): The project key, i.e. owner/organization name
		@param repository_slug(str): The repository slug, i.e. repository name
		@return (list): List of files changed in the PR, including patch data
        """

		endpoint = f"/projects/{project_key}/repos/{repository_slug}/pull-requests/{id}/diff"
		diff_data = self.make_request('GET', endpoint=endpoint, headers=self.headers, params={'withComments': False})

		if diff_data is None or not diff_data.get('diffs'):
			return []

		return self.parse_changes(diff_data.get('diffs'))
	
	def get_pull_request_changes_for_file(self, id: int, project_key: str, repository_slug: str, file_path: str) -> dict:
		"""
		https://docs.atlassian.com/DAC/rest/stash/3.11.3/stash-rest.html#idp1014000
		Get the changes of a specific file in a pull request

		@param id(int): The ID of the pull request
		@param project_key(str): The project key, i.e. owner/organization name
		@param repository_slug(str): The repository slug, i.e. repository name
		@param file_path: The path to the file in the repository to retrieve the changes
		@return: Dictionary containing information of the changes and the patch
		"""
		endpoint = f'/projects/{project_key}/repos/{repository_slug}/pull-requests/{id}/diff/{file_path}'
		diff_data = self.make_request('GET', endpoint=endpoint, headers=self.headers, params={'withComments': False})

		if diff_data is None or not diff_data.get('diffs'):
			return None

		return self.parse_changes(diff_data.get('diffs'))[0]

	""" Commits """
	def get_commit_changes(self, commit_id: str, project_key: str, repository_slug: str) -> list[dict]:
		"""
		https://docs.atlassian.com/DAC/rest/stash/3.11.3/stash-rest.html#idp992528
		Get the file changes for a specific commit with at most 1000 changed files.

		@param commit_id(str): ID of the commit, i.e. commit SHA
		@param project_key(str): The project key, i.e. owner/organization name
		@param repository_slug(str): The repository slug, i.e. repository name
		@return (list): List of files changed in the commit, including patch data
		"""

		endpoint = f"/projects/{project_key}/repos/{repository_slug}/commits/{commit_id}/diff"
		diff_data = self.make_request('GET', endpoint=endpoint, headers=self.headers, params={'withComments': False})

		if diff_data is None or not diff_data.get('diffs'):
			return []

		return self.parse_changes(diff_data.get('diffs'))

	def get_commit_metadata(self, commit_id: str, project_key: str, repository_slug: str) -> dict:
		"""
		https://docs.atlassian.com/DAC/rest/stash/3.11.3/stash-rest.html#idp1531440
		Get metadata about a specific commit
		Changes of the commit should be retrived from `get_commit_changes` instead

		@param commit_id(str): ID of the commit, i.e. commit SHA
		@param project_key(str): The project key, i.e. owner/organization name
		@param repository_slug(str): The repository slug, i.e. repository name
		@return (list): Metadata of the commit
		"""

		endpoint = f"/projects/{project_key}/repos/{repository_slug}/commits/{commit_id}"
		response = self.make_request("GET", endpoint=endpoint, headers=self.headers)

		commit_data = {
			'id': response.get('id'),
			'author': {
				'name': response['author'].get('name', '') if 'author' in response and response['author'] else '',
				'date': response.get('authorTimestamp'),  # Milliseconds since epoch
				'email': response.get('emailAddress')
			},
			'message': response.get('message'),
			'parents': [{'id': parent.get('id')} for parent in response.get('parents', [])],
		}

		return commit_data

	def get_commits_in_range(self, project_key: str, repository_slug: str, since: str, until: str, max_count: int = 25) -> list:
		"""
		https://docs.atlassian.com/DAC/rest/stash/3.11.3/stash-rest.html#idp1513136
		Get all commits between two commits or references

		@param project_key(str): The project key, i.e. owner/organization name
		@param repository_slug(str): The repository slug, i.e. repository name
		@paran since(str): The commit ID or reference (exclusively) to retrieve commits after
		@paran until(str): The commit ID or reference (inclusively) to retrieve commits before
		@param max_count(int): (Optional) Number of commits to show per page. Defaults to 25
		@return: commits list
		"""
		endpoint = f'/projects/{project_key}/repos/{repository_slug}/commits'
		params = {'since': since, 'until': until, 'withCounts': max_count}
			
		response = self.make_request('GET', endpoint=endpoint, headers=self.headers, params=params)
		
		return response["values"]

	""" Tags """
	def get_tags(self, project_key: str, repository_slug: str, max_count: int = 25) -> list:
		"""
		https://docs.atlassian.com/DAC/rest/stash/3.11.3/stash-rest.html#idp663664
		Get tags of a repository

		@param project_key(str): The project key, i.e. owner/organization name
		@param repository_slug(str): The repository slug, i.e. repository name
		@param max_count(int): Number of tags to show per page. Defaults to 25
		@return: tags list
		"""
		endpoint = f'/projects/{project_key}/repos/{repository_slug}/tags'
		params = {'limit': max_count}

		response = self.make_request('GET', endpoint=endpoint, headers=self.headers, params=params)

		return response["values"]
	
