import json
import logging
import requests
from typing import Any
from urllib.parse import urlparse
from requests.auth import HTTPBasicAuth
from interlinked.core.config import Config
from interlinked.core.utilities import Utilities

logger = logging.getLogger(__name__)


class SplunkClient:
	"""
	A client for getting logs from Splunk
	"""

	username: str = None
	password: str = None
	base_url: str = None


	def __init__(self, api_token: str = None, username: str = None, password: str = None, base_url: str = None):
		"""
		Initializes this client

		@param api_token(str): Your Splunk API Token (from splunk.iso.apple.com/en-US/manager/launcher/authorization/tokens)
		@param username(str): (Deprecated) Your AppleConnect username
		@param password(str): (Deprecated) Your OpenDirectory password
		@param base_url(str): (Optional) Your Splunk instance URL (e.g. `splunk.iso.apple.com:8089`)
		"""

		# prefix `base_url` if it doesn't have `https://…`
		if base_url and not base_url.startswith('http'):
			base_url = f'http://{base_url}'

		self.base_url = (base_url or 'https://splunk.iso.apple.com:8089').rstrip('/')

		# suffix the URL with the default port number if no port is already specified
		parsed_url = urlparse(self.base_url)

		if parsed_url.port is None:
			self.base_url = f'{self.base_url}:8089'

		self.password = password or Config.current.OPENDIRECTORY_PASSWORD
		self.username = username or Config.current.APPLECONNECT_USERNAME
		self.api_token = self.get_splunk_token() if not api_token else api_token

	def get_splunk_token(self):
		"""
		Gets a session token from Splunk using username/password authentication
		"""

		dsid = Config.current.DSID
		daw = Utilities.get_apple_connect_token(app_id='136601', type='daw')

		data = {

			'name': dsid,
			'type': 'static',
			'expires_on': '+1d',
			'not_before': '+1s',
			'audience': 'For Interlinked Automated API access',
		}

		response = requests.post(f'{self.base_url}/services/authorization/tokens?output_mode=json',
								 auth=HTTPBasicAuth(dsid, daw), data=data)

		token_data = response.json()

		if 'entry' in token_data and len(token_data['entry']) > 0:

			if token := token_data['entry'][0].get('content', {}).get('token'):
				return token

	def search(self, query: str, earliest_time: str = None, latest_time: str = None) -> list[dict]:
		"""
		Searches Splunk and returns the results

		@param query(str): Your Splunk search query/syntax
		@param earliest_time(str): Optional start time for the search (e.g., "-60m", "-24h")
		@param latest_time(str): Optional end time for the search (e.g., "now", "+1h")
		@return (list): a list of search results
		"""

		data: dict[str, Any] = {
			'search': query,
			'output_mode': 'json',
		}

		if earliest_time:
			data['earliest_time'] = earliest_time

		if latest_time:
			data['latest_time'] = latest_time

		headers: dict[str, str] = {'Authorization': f'Bearer {self.api_token}'}

		response = requests.request('POST', f'{self.base_url}/services/search/jobs/export',
									headers=headers, cookies=self.get_splunk_token() if not self.api_token else None,
									data=data)

		if not response.ok:
			return {'error': response.text}, response.status_code

		results = []
		for line in response.text.split('\n'):
			if line.strip():
				try:
					results.append(json.loads(line))
				except json.JSONDecodeError:
					logger.warning(f"Failed to parse Splunk result: {line}")

		return results

	def get_fields(self, index_name: str) -> list[str]:
		"""
		Returns a list of fields available in the specified index

		@param index_name(str): Name of the Splunk index
		@return (list): List of field names
		"""
		query = f'| search index={index_name} | stats count | fields'

		results = self.search_async(query)
		return {'job-id': results}

	def search_async(self, query: str) -> str:
		"""
		Starts an asynchronous search and returns the job ID

		@param query(str): Splunk Search query
		@return (str): Job ID of the search
		"""
		headers: dict[str, str] = {'Authorization': f'Bearer {self.api_token}'}

		data = {
			'search': query,
			'output_mode': 'json'
		}

		response = requests.post(
			f'{self.base_url}/services/search/jobs',
			headers=headers,
			data=data
		)

		if not response.ok:
			return f'Failed to start async search: {response.text}'

		data = response.json()
		return data.get('sid', '')

	def get_job_status(self, job_id: str) -> dict:
		"""
		Retrieves the status of a Splunk search job

		@param job_id(str): ID of the search job
		@return (dict): Job status information
		"""
		headers: dict[str, str] = {'Authorization': f'Bearer {self.api_token}'}

		response = requests.get(
			f'{self.base_url}/services/search/jobs/{job_id}',
			headers=headers,
			params={'output_mode': 'json'}
		)

		if not response.ok:
			return f"Failed to get job status: {response.text}"

		return response.json()

	def get_job_results(self, job_id: str) -> list[dict]:
		"""
		Retrieves results from a completed search job

		@param job_id(str): ID of the search job
		@return (list): Search results
		"""
		headers: dict[str, str] = {'Authorization': f'Bearer {self.api_token}'}

		response = requests.get(
			f'{self.base_url}/services/search/jobs/{job_id}/results',
			headers=headers,
			params={'output_mode': 'json'}
		)

		if not response.ok:
			return f"Failed to get job results: {response.text}"

		try:

			data = response.json()
			return data.get('results', [])

		except json.JSONDecodeError:

			logger.error(f"Error parsing job results")
			return []

	def get_events(self, index: str, count: int = 100) -> list[dict]:
		"""
		Retrieves the most recent events from a specified index

		@param index(str): Name of the Splunk index
		@param count(int): Number of events to retrieve
		@return (list): List of events
		"""
		return self.search(f'search index={index} | head {count}')

	def create_alert(self, name: str, query: str, alert_condition: str, actions: list, cron_schedule: str) -> dict:
		"""
		Creates a Splunk alert based on search query

		@param name(str): Name of the alert
		@param query(str): Splunk search query that defines the alert
		@param alert_condition(str): Condition for triggering the alert (e.g., "greater than", "less than")
		@param actions(list): List of actions to take when alert triggers
		@param cron_schedule(str): Schedule for running the alert search (cron format)
		@return (dict): Response from Splunk
		"""
		headers: dict[str, str] = {'Authorization': f'Bearer {self.api_token}'}

		data = {
			'name': name,
			'search': query,
			'is_scheduled': '1',
			'output_mode': 'json',
			'alert_type': 'always',
			'alert_threshold': '0',
			'actions': ','.join(actions),
			'dispatch.latest_time': 'now',
			'cron_schedule': cron_schedule,
			'dispatch.earliest_time': '-15m',
			'alert_comparator': alert_condition,
		}

		response = requests.post(f'{self.base_url}/services/saved/searches', headers=headers, data=data)

		if not response.ok:

			logger.error(f'Failed to create alert: {response.text}')
			raise Exception('Could not create alert')

		return response.json()

if __name__ == '__main__':
	print(SplunkClient(api_token='…').search(query='search earliest=-10s index=…'))