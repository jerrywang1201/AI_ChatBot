import logging
from threading import Event
from threading import Thread
from slack_bolt.app import App
from typing import Any, Callable
from slack_sdk.web import WebClient
from slack_bolt.adapter.socket_mode import base_handler

from interlinked.core.config import Config
from interlinked.core.singleton import SingletonMeta

logger = logging.getLogger(__name__)


# monkey-patch SlackBolt's start function to
# remove `⚡️ Bolt app is running!` log
def start(self):

	self.connect()
	Event().wait()

base_handler.BaseSocketModeHandler.start = start


class SlackClient(metaclass=SingletonMeta):
	"""
	Slack client used to send and receive Slack messages

	This client requires a Slack app created and installed: [Instructions ›](https://chorus.apple.com/page/5423104)
	The process for requesting access can be quite complex.

	ℹ️ If you're only looking for the ability to send messages (webhooks),
	you can request access [here](https://chorus.apple.com/page/5424954) and call `requests.post` directly
	"""

	app: App = None
	bot_id: str = None
	socket_mode_handler: 'SocketModeHandler'

	def __init__(self, bot_token: str = None, app_token: str = None):
		"""
		Initializes the SlackClient with tokens and an event callback method

		@param bot_token(str): The BOT token (starts with `xoxb-…`)
		@param app_token(str): The app token (starts with `xapp-…`)
		"""

		self.bot_token = bot_token or Config.current.SLACK_BOT_TOKEN
		self.app_token = app_token or Config.current.SLACK_APP_TOKEN

		if self.bot_token:

			slack_bolt_logger = logging.getLogger('slack_bolt')
			slack_bolt_logger.setLevel(level=logging.WARNING)

			# use a proxy in production
			self.app = App(client=WebClient(token=self.bot_token, proxy=Config.current.PROXY_URL),
						   logger=slack_bolt_logger)
			self.bot_id = self.app.client.auth_test().get('bot_id')

	@SingletonMeta.Shared
	def shared(cls) -> 'SlackClient':
		return cls(shared=True)

	""" Events """

	def listen_for(self, event_names: set[str], callback: Callable,
				   action_names: set[str] = None, actions_callback: Callable = None) -> None:
		"""
		Listens for Slack events (e.g. messages), then calls a callback function

		@param event_names(set): A list of Slack events (see api.slack.com/events)
		@param callback(Callable): A function to call when the events are posted
		@param action_names(set): A set/list of actions to watch for
		@param actions_callback(Callable): A function to call when the user presses a button in a Slack message AI sent
		"""

		from slack_bolt.adapter.socket_mode import SocketModeHandler

		def _callback(ack: Callable, body: dict[str, Any]) -> None:

			nonlocal callback
			callback(event=body.get('event'), ack=ack)

		def _actions_callback(ack: Callable, body: dict[str, Any]) -> None:

			nonlocal actions_callback
			actions_callback(body=body, ack=ack)

		for event_name in event_names:
			self.app.event(event_name)(_callback)

		for action_name in action_names or []:
			self.app.action(action_name)(_actions_callback)

		# start the SocketModeHandler in a separate thread
		thread = Thread(target=lambda: SocketModeHandler(app=self.app, app_token=self.app_token).start())
		thread.daemon = True
		thread.start()

	def send_message(self, channel_id: str = None, thread_ts: str = None, **kwargs):
		"""
		Sends or replies to a Slack message.

		This function accepts the same arguments as [here](https://api.slack.com/methods/chat.postMessage).
		"""

		channel_id = channel_id or kwargs.pop('channel')
		channel_id = channel_id.removeprefix('#').rsplit('/')[-1]

		# allow `thread_ts` to be a URL
		if thread_ts:

			thread_ts = thread_ts.rsplit('/')[-1]

			if thread_ts.startswith('p'):

				thread_ts = thread_ts.removeprefix('p')
				thread_ts = thread_ts[:10] + '.' + thread_ts[10:]

		return self.app.client.chat_postMessage(channel=channel_id, thread_ts=thread_ts, **kwargs)

	def send_ephemeral_message(self, channel_id: str = None, user_id: str = None, thread_ts: str = None, **kwargs):
		"""
        Sends a message only visible to a specific user in a channel or thread.

        @param channel_id(str): The channel ID where the ephemeral message will appear
        @param user_id(str): The user ID who will see the ephemeral message
        @param thread_ts(str): Optional thread timestamp to send message within a thread
        @return: Response from the Slack API
        """
		if not channel_id:
			channel_id = kwargs.pop('channel', None)

		if not channel_id:
			raise ValueError('channel_id is required for sending ephemeral messages')

		if not user_id:
			user_id = kwargs.pop('user', None)

		if not user_id:
			raise ValueError('user_id is required for sending ephemeral messages')

		channel_id = channel_id.removeprefix('#').rsplit('/')[-1]

		# allow `thread_ts` to be a URL
		if thread_ts:
			thread_ts = thread_ts.rsplit('/')[-1]

			if thread_ts.startswith('p'):
				thread_ts = thread_ts.removeprefix('p')
				thread_ts = thread_ts[:10] + '.' + thread_ts[10:]

		return self.app.client.chat_postEphemeral(channel=channel_id, user=user_id, thread_ts=thread_ts,**kwargs)

	def start_group_chat(self, user_ids: list[str], initial_message: str = None, **kwargs) -> str:
		"""
		Starts a group chat with the specified users and optionally sends an initial message

		@param user_ids(list): A list of user IDs (starts with `U`) to include in the group chat
		@param initial_message(str): (Optional) initial message to send to the group chat
		@return str: The ID of the newly created group chat channel (starts with `C`), or None if an error occurred.
		"""

		response: dict[str, Any] = self.app.client.conversations_open(users=user_ids)

		if not response['ok']:
			raise Exception(f'Could not start group chat (error={response["error"]})')

		channel_id = response['channel']['id']

		# send initial message, if provided
		if initial_message:
			self.send_message(channel_id=channel_id, text=initial_message, **kwargs)

		return channel_id

	def pin_message(self, channel_id: str, thread_ts: str) -> None:
		"""
		Pins a message to a channel

		@param channel(str): The ID of the channel (starts with `C`)
		@param thread_ts(str): The thread ID to pin
		"""

		# allow `thread_ts` to be a URL
		if thread_ts:

			thread_ts = thread_ts.rsplit('/')[-1]

			if thread_ts.startswith('p'):

				thread_ts = thread_ts.removeprefix('p')
				thread_ts = thread_ts[:10] + '.' + thread_ts[10:]

		response: dict[str, Any] = self.app.client.pins_add(channel=channel_id, timestamp=thread_ts)

		if not response['ok']:
			raise Exception(f'Could not pin message (error={response["error"]})')

	def add_reaction(self, name: str, channel_id: str, thread_ts: str) -> None:
		"""
		Adds a reaction emoji to a message

		@param name(str): The name of the emoji (without colons)
		@param channel_id(str): The ID of the channel (starts with `C`)
		@param thread_ts(str): The timestamp of the message to add reaction to
		"""

		# allow `thread_ts` to be a URL
		if thread_ts:

			thread_ts = thread_ts.rsplit('/')[-1]

			if thread_ts.startswith('p'):
				thread_ts = thread_ts.removeprefix('p')
				thread_ts = thread_ts[:10] + '.' + thread_ts[10:]

		# ensure reaction doesn't have colons
		name = name.strip().strip(':')

		response: dict[str, Any] = self.app.client.reactions_add(channel=channel_id, timestamp=thread_ts,
																 name=name)

		if not response['ok']:

			if response.get('error') == 'already_reacted':
				return

			raise Exception(f'Could not add reaction (error={response["error"]})')

	def remove_reaction(self, name: str, channel_id: str, thread_ts: str) -> None:
		"""
		Removes a reaction emoji from a message

		@param name(str): The name of the emoji (without colons)
		@param channel_id(str): The ID of the channel (starts with `C`)
		@param thread_ts(str): The timestamp of the message to remove reaction from
		"""

		# allow `thread_ts` to be a URL
		if thread_ts:

			thread_ts = thread_ts.rsplit('/')[-1]

			if thread_ts.startswith('p'):
				thread_ts = thread_ts.removeprefix('p')
				thread_ts = thread_ts[:10] + '.' + thread_ts[10:]

		# ensure reaction doesn't have colons
		name = name.strip().strip(':')

		response: dict[str, Any] = self.app.client.reactions_remove(channel=channel_id, timestamp=thread_ts,
																   name=name)

		if not response['ok']:

			if response.get('error') == 'no_reaction':
				return

			raise Exception(f'Could not remove reaction (error={response["error"]})')

	def add_user_to_channel(self, channel_id: str, user_id: str = None, full_name: str = None) -> dict:
		"""
        Adds users to a Slack channel

        @param channel_id(str): The ID of the channel (starts with 'C')
        @param user_ids(str): (Optional) User ID to add to the channel
        @param full_name(str): (Optional) Full name of the user
        @return (dict): Dictionary with result
        """

		if full_name:

			from interlinked.core.clients.appledirectoryclient import AppleDirectoryClient, Person

			person: Person = AppleDirectoryClient.shared.get_persons_by_name(name=full_name)[0]
			user_id = person.slack_id

		results = {}

		if not user_id:
			return f'Error: Unable to find the user with user_id {user_id} or full name {full_name}'

		try:

			response = self.app.client.conversations_invite(
				channel=channel_id,
				users=[user_id]
			)
			results[user_id] = response.get('ok', False)

		except Exception as e:
			results[user_id] = f"Error: {str(e)}"

		return results

	def get_thread_details(self, thread_ts: str, channel_id: str = None) -> dict:
		"""
        Retrieves details about a thread including all replies

        @param thread_ts(str): The timestamp of the thread parent message
        @param channel_id(str): The ID of the channel containing the thread
        @return dict: Dictionary containing thread details including all replies
        """

		# allow `thread_ts` to be a URL
		if thread_ts:
			thread_ts = thread_ts.rsplit('/')[-1]

			if thread_ts.startswith('p'):
				thread_ts = thread_ts.removeprefix('p')
				thread_ts = thread_ts[:10] + '.' + thread_ts[10:]

		if not channel_id:
			raise ValueError("channel_id is required to retrieve thread details")

		try:

			# Get the parent message
			parent_response = self.app.client.conversations_history(
				channel=channel_id,
				latest=thread_ts,
				limit=1,
				inclusive=True
			)

			if not parent_response['ok']:
				raise Exception(f"Could not retrieve parent message (error={parent_response['error']})")

			# Get thread replies
			replies_response = self.app.client.conversations_replies(
				channel=channel_id,
				ts=thread_ts
			)

			if not replies_response['ok']:
				raise Exception(f"Could not retrieve thread replies (error={replies_response['error']})")

			return {
				'parent_message': parent_response.get('messages', [])[0] if parent_response.get('messages') else None,
				'replies': replies_response.get('messages', [])[1:],  # Skip the first message as it's the parent
				'has_more': replies_response.get('has_more', False),
				'thread_ts': thread_ts,
				'channel_id': channel_id
			}

		except Exception as e:
			return f"Error retrieving thread details: {str(e)}"

	def get_attachment_content(self, file_id: str) -> dict:
		"""
		Fetches attachment data as bytes from a Slack file

		@param file_id(str): The ID of the file to fetch (starts with 'F')
		"""

		import requests

		try:

			file_info = self.app.client.files_info(file=file_id)

			if not file_info['ok']:
				raise Exception(f"Could not retrieve file info (error={file_info['error']})")

			file_data = file_info['file']
			url_private = file_data.get('url_private')

			if not url_private:
				raise Exception('No private URL available for this file')


			headers = {'Authorization': f'Bearer {self.bot_token}'}
			response = requests.get(url_private, headers=headers, proxies={'http': Config.current.PROXY_URL,
																		   'https': Config.current.PROXY_URL} if Config.current.PROXY_URL else None)

			if response.status_code != 200:
				raise Exception(f'Failed to download file: HTTP {response.status_code}')

			file_content = response.content

			return {

				'file_id': file_id,
				'file_content': file_content,
				'size': file_data.get('size'),
				'filename': file_data.get('name'),
				'filetype': file_data.get('filetype'),
				'mimetype': file_data.get('mimetype')

			}

		except Exception as e:

			logger.error(f'Error retrieving attachment as base64: {str(e)}')
			raise Exception(f'Failed to retrieve attachment: {str(e)}')


if __name__ == '__main__':
	# SlackClient.shared.add_reaction(channel_id='C0696KE2DDY', thread_ts='https://a1391192.slack.com/archives/C0696KE2DDY/p1747069729127979', reaction=':loading-2:')
	# SlackClient.shared.remove_reaction(channel_id='C0696KE2DDY', thread_ts='https://a1391192.slack.com/archives/C0696KE2DDY/p1747069729127979', reaction=':loading-2:')
	SlackClient.shared.start_group_chat(user_ids=['U01JQ4B8WJU', 'WNCETJFMF'], initial_message='…')
	# SlackClient.shared.pin_message(channel_id='C0696KE2DDY', thread_ts='https://a1391192.slack.com/archives/C0696KE2DDY/p1747069729127979')