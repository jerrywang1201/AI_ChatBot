import os
import re
import sys
import math
import json
import logging
import requests
import subprocess
from time import sleep
from typing import Any
from functools import wraps

from interlinked.core.config import Config

logger = logging.getLogger(__name__)


class Utilities:

	# 8 hours in milliseconds
	A3_TIME_TO_LIVE: int = 28800000

	""" Authentication """

	@classmethod
	def get_apple_connect_username(cls) -> str:
		"""
		Returns the current AppleConnect username

		@return (str): your AppleConnect username
		"""

		if not Config.current.is_development:
			return Config.current.APPLECONNECT_USERNAME

		result = subprocess.run(['/usr/local/bin/appleconnect', 'currentUser'],
								check=True, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
		return result.stdout.decode('utf-8').rstrip()

	@classmethod
	def get_apple_connect_token(cls, app_id: int, type: str = 'daw') -> str:
		"""
		Returns token by calling the `appleconnect` system binary

		@param app_id(int): The ID of the app or client you're looking to get an AppleConnect token for
		@return (str): token
		"""

		if not Config.current.is_development:
			raise NotImplementedError('AppleConnect is not available to use when production is set to True')

		# daw
		if type == 'daw':

			try:
				result = subprocess.run(['/usr/local/bin/appleconnect', 'getToken', f'--appID={app_id}', '--token-type=daw',
										 '--interactivity-type=none', '--environment', 'prod'],
										check=True, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)

				token: str = result.stdout.decode('utf-8').rstrip()

				# for appleconnect < 5.6
				return token.split('token: ')[1] if 'token: ' in token else token

			except subprocess.CalledProcessError as error:

				# re-authenticate automatically
				if not Config.current.APPLECONNECT_USERNAME:
					raise Exception('could not re-authenticate automatically with AppleConnect. Please authenticate manually or set environment variables')

				# dynamically import pexpect to authenticate for the user
				try:
					import pexpect

				except ModuleNotFoundError as error:

					cls.install_package(name='pexpect')
					import pexpect

				child = pexpect.spawn(f'/usr/local/bin/appleconnect getToken --appID={app_id} --token-type=daw --environment prod')

				child.expect('AppleConnect account:')
				child.sendline(Config.current.APPLECONNECT_USERNAME.strip())
				child.expect('password:')
				child.sendline(Config.current.APPLECONNECT_PASSWORD.strip())
				child.expect(pexpect.EOF)

				output: str = child.before.decode('utf-8').strip()

				if not output.startswith('DAW'):
					raise Exception(f'could not get DAW token ({output})')

				return output

			except FileNotFoundError as error:

				raise Exception('AppleConnect is not installed. If you are running AI on Linux (or any non-Mac environment),'
								' setting `INTERLINKED_CONFIG=production` environment variable should do the trick ✅')

		# oauth
		elif type == 'oauth':

			try:
				result = subprocess.run(['/usr/local/bin/appleconnect', 'getToken', '-C', app_id, '--token-type=oauth', '--interactivity-type=none',
										 '--environment', 'prod', '-G', 'pkce', '-o', 'openid,dsid,accountname,profile,groups'],
										check=True, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)

				id_token: str = None

				for line in result.stdout.splitlines():

					id_token_info = b'oauth-id-token: '

					if line.startswith(id_token_info):
						id_token = line[len(id_token_info):].strip().decode('utf-8')

				if not id_token:
					raise Exception('Could not get your Oauth token')

				return id_token

			except FileNotFoundError as error:

				raise Exception('AppleConnect is not installed. If you are running AI on Linux (or any non-Mac environment),'
								' setting `INTERLINKED_CONFIG=production` environment variable should do the trick ✅')

		raise Exception('Unknown type')

	@classmethod
	def get_westgate_token(cls, app_id: int, app_url: str) -> str:
		"""
		Returns a Westgate token for a given app ID

		@param app_id(int): The ID of the app you're looking to connect to
		@param app_url(str): The base URL of the app
		@return (tuple): app ID, app token
		"""

		apple_connect_token: str = Utilities.get_apple_connect_token(app_id=app_id)

		response = requests.post(f'{app_url}/westgate/token', headers={'Authorization': f'Bearer {apple_connect_token}'})

		if not response.ok:
			logging.error(response.text)

		response.raise_for_status()

		return response.json().get('Password')

	@classmethod
	def get_a3_token(cls, context: str, other_app_id: str, app_id: str = None,
					 app_password: str = None, dsid: int = None) -> str:
		"""
		Returns an A3 token
		"""

		headers: dict[str, str] = {'Content-Type': 'application/json', 'cache-control': 'no-cache', 'Accept': 'application/json'}

		app_id = app_id or Config.current.IDMS_APP_ID

		if app_id is None:
			raise Exception('Missing `app_id` or the "Application ID" environment variable')

		app_password = app_password or Config.current.IDMS_APP_PASSWORD

		if app_password is None:
			raise Exception('Missing `app_password` or the "Application Password" environment variable')

		data: dict[str, Any] = {'appId': app_id, 'context': context, 'otherApp': other_app_id,
								'appPassword': app_password, 'timeToLive': cls.A3_TIME_TO_LIVE}

		if dsid:
			data['prsId'] = dsid

		response: Any = None

		for attempt in range(1, 3):

			response = requests.post('https://idmsac.corp.apple.com/auth/apptoapp/token/generate', headers=headers,
									 data=json.dumps(data))

			if response.status_code in {502, 503, 504, 429}:

				sleep(1)
				continue

		if not response.ok:
			logging.error(response.text)

		response.raise_for_status()

		response_dict: dict[str, Any] = response.json()
		return response_dict.get('token')

	@classmethod
	def get_oidc_token(cls, client_id: str = None, client_secret: str = None) -> str:
		"""
		Returns OIDC (Oauth access token) by calling the `appleconnect` system binary

		@param client_id(str): The ID of your client/app (from IdMS)
		@param client_secret(str): The secret of your client/app (from IdMS)
		@return (str): Oauth access token
		"""

		if not Config.current.is_development:
			raise NotImplementedError('Not available in production')

		client_id = client_id or Config.current.IDMS_APP_OIDC_CLIENT_ID

		if client_id is None:
			raise Exception('Missing `client_id` or the `INTERLINKED_IDMS_APP_OIDC_CLIENT_ID` environment variable')

		client_secret = client_secret or Config.current.IDMS_APP_OIDC_CLIENT_SECRET

		if client_secret is None:
			raise Exception('Missing `client_secret` or the `INTERLINKED_IDMS_APP_OIDC_CLIENT_SECRET` environment variable')

		result = subprocess.run(['/usr/local/bin/appleconnect', 'getToken', '-E', 'prod', '-t', 'oauth', '-C', client_id,
								 '-S', client_secret], check=True, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)

		token: str = result.stdout.decode('utf-8').rstrip()

		if matches := re.findall(r'oauth-access-token\: (.*$)', token, flags=re.MULTILINE):
			return matches[0]

		raise Exception('Could not get oauth-access-token')

	@classmethod
	def get_notary_token(cls) -> str:
		"""
		Returns a Notary token by calling the `notarycli` system binary

		@return (str): Notary token
		"""

		try:

			result = subprocess.run(['notarycli', 'issue'],
								  check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
			return result.stdout.strip()

		except subprocess.CalledProcessError as error:
			raise Exception(f'Failed to generate Notary token: {error.stderr}')

		except FileNotFoundError:
			raise Exception('notarycli not found. Please install notarycli to use Notary authentication.')

	@classmethod
	def get_daw_token_details(cls, daw_token: str, app_id: int = None, app_password: str = None) -> dict[str, Any]:
		"""
		Returns the user's name, email, and DSID given a DAW (AppleConnect) token
		"""

		app_id = app_id or Config.current.IDMS_APP_ID
		app_password = app_password or Config.current.IDMS_APP_PASSWORD

		response = requests.post('https://idmsac.apple.com/IDMSWebAuth/validate', data={

			'ip': '',
			'appId': app_id,
			'format': 'json',
			'cookie': daw_token,
			'appAdminPassword': app_password,
			'func': ';'.join(['prsId']) + ';',
		})

		response.raise_for_status()
		return response.json()

	@classmethod
	def get_user_session(cls, app_id: str = None, app_password: str = None, username: str = None, password: str = None) -> str:
		"""
		Returns user session for the system account

		@param app_id(str): The ID of your app (from Apple Connect)
		@param app_password(str): The password of your app (from Apple Connect)
		@param username(str): The username of your AppleConnect System account
		@param password(str): The password of your AppleConnect System account
		"""

		app_id: int = app_id or Config.current.IDMS_APP_ID
		app_password: str = app_password or Config.current.IDMS_APP_PASSWORD
		username: str = username or Config.current.APPLECONNECT_USERNAME
		password: str = password or Config.current.APPLECONNECT_PASSWORD

		auth_url: str = 'https://idms-int-rsvc.corp.apple.com/service/authservice/authenticate'
		payload: dict[str, Any] = {
			'dsRequest': {
				'appCredentials': {
					'appID': app_id,
					'appPassword': app_password
				}
			},
			'account': {
				'accountName': username,
				'password': password
			}
		}

		try:

			response = requests.post(auth_url, json=payload)
			response.raise_for_status()
			response_data = response.json()
			user_session = response_data.get('session', {}).get('userSession')
			return user_session

		except Exception as e:
			return None

	@classmethod
	def get_oidc_access_token(cls, client_id: str, client_secret: str,
							  totp_secret: str = None, device_id: str = None,
							  app_id: str = None, app_id_key: str = None,
							  username: str = None, password: str = None) -> str:
		"""
		[Internal]
		Exchange JWT for access token for OIDC (OAuth2.0)

		@param client_id(str): The ID of your app (from Apple Connect OIDC)
		@param client_secret(str): The secret of your app (from Apple Connect OIDC)
		@param totp_secret(str): The TOTP secret from your app
		@param device_id(str): The device ID from your app
		@param app_id(str): The ID of your app (from IdMS)
		@param app_id_key(str): The ID of your app (from IdMS)
		@param username(str): The username of your AppleConnect System account
		@param password(str): The password of your AppleConnect System account
		@return: OIDC access token
		"""

		try:
			import pyotp

		except ModuleNotFoundError:

			cls.install_package(name='pyotp')
			import pyotp

		totp_secret: str = totp_secret or Config.current.APPLECONNECT_TOTP_SECRET
		device_id: int = device_id or Config.current.APPLECONNECT_DEVICE_ID
		username: str = username or Config.current.APPLECONNECT_USERNAME
		password: str = password or Config.current.APPLECONNECT_PASSWORD

		totp: pyotp.TOTP = pyotp.TOTP(totp_secret)

		authenticate_payload: dict[str, Any] = {

			'generateJwt': True,
			'dsRequest': {'appCredentials': {'appIdKey': app_id_key}},
			'account': {'accountName': username, 'password': password},
			'secondFactor': {'secCode': totp.now(), 'deviceId': device_id},

		}
		authenticate_headers: dict[str, Any] = {

			'appid': app_id,
			'appidkey': app_id_key,
			'accept': 'application/json',
			'content-type': 'application/json',
		}

		response = requests.post('https://idms-int-rsvc.corp.apple.com/service/authservice/authenticate', json=authenticate_payload, headers=authenticate_headers)

		if not response.ok:
			logger.error(f'Could not able to authenticate the user for OIDC: {response.text}')

		response.raise_for_status()
		response_json: dict[str, Any] = response.json()

		corp_jwt: str = response_json.get('corpJwt')

		if not corp_jwt:
			raise Exception(f'Could not get `corpJwt`: {response_json=}')

		payload: dict[str, Any] = {

			'scope': 'openid',
			'assertion': corp_jwt,
			'client_id': client_id,
			'client_secret': client_secret,
			'grant_type': 'urn:ietf:params:oauth:grant-type:jwt-bearer'

		}

		headers: dict[str, str] = {'content-type': 'application/json'}

		response = requests.post('https://idmsac.apple.com/auth/oauth2/token', json=payload, headers=headers)

		if not response.ok:
			logger.error(f'Could not get access token for OIDC: {response.text}')

		response.raise_for_status()

		access_token: str = response.json().get('access_token')
		return access_token


	""" Dynamic Workflows """

	@classmethod
	def dynamic(cls, function):
		"""
		[Internal]
		A decorator that makes a given function supported by `AutomationProcesssor`.
		"""

		@wraps(function)
		def wrapper(*args, **kwargs):
			return function(*args, **kwargs)

		return wrapper

	@classmethod
	def get_functions_in_file(cls, path: str) -> list[dict]:
		"""
		[Internal]
		Returns a list of functions in a given Python file

		@param path(str): The path to the Python file
		"""

		import ast

		content: str = None
		tree: ast.Node = None
		functions: list[dict] = []

		with open(path, 'r') as file:
			content = file.read()

		tree = ast.parse(content, filename=path)

		class FunctionVisitor(ast.NodeVisitor):

			def __init__(self):
				self.current_class = None

			def visit_ClassDef(self, node):

				self.current_class = node.name
				self.generic_visit(node)
				self.current_class = None

			def visit_FunctionDef(self, node):

				self._add_function(node)

			def visit_AsyncFunctionDef(self, node):

				self._add_function(node)

			def _add_function(self, node):

				if any(isinstance(decorator, ast.Name) and decorator.id == 'property' for decorator in node.decorator_list):
					return

				code: str = ast.get_source_segment(source=content, node=node)
				description: str = ast.get_docstring(node)

				functions.append({
					'name': f'{self.current_class}.{node.name}' if self.current_class else node.name,
					'description': description,
					'code': code})

		FunctionVisitor().visit(tree)

		unique_functions = {}
		for func in functions:
			unique_functions[func['name']] = func

		return list(unique_functions.values())


	""" AI """

	@classmethod
	def get_cosine_distance(cls, embedding_1: list[float], embedding_2: list[float]) -> float:
		"""
		Returns the cosine similarity between two embeddings

		Uses the same calculation as pgVector

		@param embedding_1(list): A list of embeddings
		@param embedding_2(list): A list of embeddings
		@return (float): The cosine distance between the embeddings
		"""

		if len(embedding_1) != len(embedding_2):
			raise Exception(f'embedding lists size do not match (embedding_1={len(embedding_1)}, embedding_2={len(embedding_2)})')

		dot_product: float = sum(x * y for x, y in zip(embedding_1, embedding_2))

		# calculate the magnitude (euclidean norm) of each embedding
		magnitude_1 = math.sqrt(sum(x ** 2 for x in embedding_1))
		magnitude_2 = math.sqrt(sum(x ** 2 for x in embedding_2))

		similarity: float = None
		if magnitude_1 == 0 or magnitude_2 == 0:
			similarity = 0

		else:
			similarity = dot_product / (magnitude_1 * magnitude_2)

		if similarity > 1:
			similarity = 1

		elif similarity < -1:
			similarity = -1

		return 1 - similarity

	""" Content """

	@classmethod
	def get_words_in_text(cls, words: list|set, text: str, strict: bool = True) -> list[str]:
		"""
		Returns a list of words that are in a given text.

		@param words(list): A list of words(str) to check if they are in the text
		@param text(str): The text to be checked
		@param strict(bool): If `True`, matches should be exact words/sentences
		@return (list): All matching words
		"""

		if text is None:
			return None

		escaped_words: list[str] = [re.escape(word) for word in words]
		pattern: str = fr'(?:{"|".join(escaped_words)})'

		if strict:
			pattern = fr'\b{pattern}\b'

		matches: list[str] = re.findall(pattern, text, re.IGNORECASE)
		return matches

	@classmethod
	def remove_words_in_text(cls, words: list[str] | set[str], text: str) -> str:
		"""
		Removes a list of words from a given text.

		e.g. `words = {'TSTT *'}`, `text = 'TSTT test'`, `return = 'test`
		e.g. `words = {'*iPhone*'}`, `text = 'iPhone'`, `return = 'iPhone`

		@param words(list): A list of words to remove
		@param text(str): The text to remove the words from
		@return (str): The new text
		"""

		for word in words:

			text_lower: str = text.lower()

			# e.g. `*TSTT*`
			if word.startswith('*') and word.endswith('*'):
				text = re.sub(word.strip('*'), '', text, flags=re.IGNORECASE)

			# e.g. `*TSTT`
			elif word.startswith('*'):
				text = re.sub(fr'{word.strip("*")}$', '', text, flags=re.IGNORECASE)

			# e.g. `TSTT*`
			elif word.endswith('*'):
				text = re.sub(fr'^{word.strip("*")}', '', text, flags=re.IGNORECASE)

			# e.g. `TSTT`
			elif word.lower() == text_lower:
				text = ''

		return text

	@classmethod
	def remove_acronyms(cls, text: str) -> str:
		"""
		Removes acronyms from a given response (or field value)

		@param text(str): A response (e.g. an OOB (out-of-bounds) read)
		@return (str): e.g. an out-of-bounds read
		"""

		# e.g. `TCC (Transparency, Consent, and Control)` -> `TCC`
		# e.g. `"TCC" (Transparency, Consent, and Control)` -> `"TCC"`
		for match in re.findall(r'(?:"|)\b[A-Z]+\b(?:"|) \([A-Za-z]+.*?\)', text, flags=re.MULTILINE | re.IGNORECASE):

			# e.g. abbreviation = `TCC`
			#      full_form = `(Transparency, Consent, and Control)`
			acronym, full_form = match.split(None, 1)
			acronym = acronym.strip('"')

			# e.g. `(Transparency, Consent, and Control)` -> `TCC`
			acronym_full_form: str = ''.join([word[0].upper() for word in re.findall(r'\b\w+\b', full_form, flags=re.IGNORECASE) if word != 'and'])

			if acronym == acronym_full_form:
				text = text.replace(f' {full_form}', '')

		# find any acronym like `(TCC)` and remove the full form
		# e.g. `Transparency, Consent, and Control (TCC)` -> `TCC`
		for acronym in re.findall(r'\(([A-Za-z]{2,8}.*?)\)', text, flags=re.MULTILINE | re.IGNORECASE):

			# turn the acronym into a pattern that we can use to match the full form
			# e.g. acronym (TCC) -> `T\w+(?: |-)C(?: |-)C(?: |-)`, which allows us to match (Transparency, Consent, and Control)
			acronym_full_form_pattern: str = r'(?: |-|, |, and | and )'.join([fr'{letter}\w+' for letter in acronym if letter.isalpha()])
			full_form_matches: list[str] = re.findall(fr'({acronym_full_form_pattern}) \([A-Za-z]+.*?\)', text, flags=re.MULTILINE | re.IGNORECASE)

			for full_form in full_form_matches:
				text = text.replace(f'{full_form} ({acronym})', acronym)

		return text

	@classmethod
	def remove_standard_headers(cls, text: str) -> str:
		"""
		[Internal]
		Removes standard radar description headers, like `Tap-to-Radar draft…`

		@param text(str): Description text
		@return (str): The updated description
		"""

		text = text.strip()
		text = text.removeprefix('EDIT: ')
		text = re.sub(r'CrashTracer:.*?\.', '', text, flags=re.MULTILINE)
		text = re.sub(r'External[\S\s]*?\—\n\n', '', text, flags=re.DOTALL | re.MULTILINE)
		text = re.sub(r'Tap-to-Radar draft started at.*?\.', '', text, flags=re.MULTILINE)
		return text.strip()

	@classmethod
	def remove_seed_text(cls, text: str, description_only: bool = False) -> str:
		"""
		[Internal]
		Removed SEED headers from a given Radar's description

		e.g. `CUSTOMER SEED BUG…`

		@param text(str): The Radar description text
		@param description_only(bool): (Optional) If `True`, we'll return the description field only
									   without any metadata, such as device and build
		@return (str): the updated description
		"""

		description: str = text.split('* DESCRIPTION:')[-1].split('* ')[0].strip()

		if description_only:
			return description or text

		if not text.startswith('CUSTOMER SEED BUG') and not text.startswith('Developer Originated Bug'):
			return text

		text = text.replace('CUSTOMER SEED BUG - This is a customer originated seed bug. Please return to the originator'
							' for any additional follow-up needed with the customer.', '')

		text = text.replace('Developer Originated Bug - This is a developer originated bug. Please assign to the originator'
							' or Developer ADCBugs for any additional follow-up needed with the developer.', '')

		text = text.replace(description, '').replace('* DESCRIPTION:', '')

		text = text.replace('Please return to the originator for any additional follow-up needed with the customer.\n'
							'APPLE INTERNAL USE ONLY - Contact Customer Seeding if you need to provide this bug to a'
							' third party.', '')

		text = text.replace(
			'This feedback was translated, original text can be found within the FeedbackCollector link tracking all'
			' communication.', '')

		text = f'{description}\n{text}'

		return text.strip()

	@classmethod
	def remove_applecare_text(cls, title: str, description: str) -> tuple[str, str]:
		"""
		[Internal]
		Removes a given AppleCare radar's description

		e.g. rdar://109212407

		@param title(str): Title text
		@param description(str): Description text
		@return (str): Clean description
		"""

		title = title.replace('AppleCare:', '').strip()
		description = description.replace('** NOTE: this is a customer report on production HW & SW **', '')
		description = description.replace('ISSUE DESCRIPTION:', '')
		description = re.sub(r'(?s)CONFIGURATION:(.*?)\n\n', '', description)
		description = description.replace('CUSTOMER\'S ', '')
		description = re.sub(r'(?s)CASE DETAILS:(.*?)$', '', description)

		description = description.strip()

		return title, description

	@classmethod
	def remove_ossfuzz_text(cls, title: str, description: str) -> tuple[str, str]:
		"""
		[Internal]
		Removes a given OSSFuzz radar's description

		e.g. rdar://109212407

		@param title(str): Title text
		@param description(str): Description text
		@return (str): Clean description
		"""

		title = re.sub(r'Issue [1-9]+ in oss-fuzz\: ', '', title)
		description = re.sub(r'(?s)\<script\>.*Type\: Bug', '', description)
		description = re.sub(r'\nDetailed Report: https.*\n', '', description)
		description = description.strip()

		return title, description

	@classmethod
	def remove_signature(cls, text: str) -> str:
		"""
		[Internal]
		Removes email signature from a given text

		@param text(str): A text
		"""
		return re.split(r'(?:Best |)(r|R)egards,', text, flags=re.MULTILINE)[0].strip()

	""" Distribution """

	@classmethod
	def split_by_chunks(cls, full_list: list[Any], chunk_size: int, overlap: bool = False) -> list[list[Any]]:
		"""
		Splits a given list into chunks of a given maximum chunk size

		e.g. `[1, 2, 3, 4, 5, 6]` -> `[1, 2, 3], [4, 5, 6]`

		@param full_list(list): The full list to split
		@param chunk_size(int): The number of elements each chunk should have
		@param overlap(bool): (Optional) if set, each chunk will have one element from the previous chunk
		"""

		if overlap:
			return [full_list[index:index + chunk_size] for index in range(len(full_list) - chunk_size + 1)]

		return [full_list[index:index + chunk_size] for index in range(0, len(full_list), chunk_size)]

	""" Numbers """

	@classmethod
	def get_is_numeric(cls, value: str) -> bool:
		"""
		Checks whether a given string is an int or float, which is not supported
		by `.isnumeric()`

		@param value(str): Any string
		"""

		# the second check is to ensure we don't match `17.1.1` (which is not a float)
		return value.replace('.', '').removeprefix('-').isnumeric() and value.count('.') <= 1

	""" Date/time """

	def get_time_until(target_time: 'datetime') -> str:
		"""
		[Internal]
		Returns a display time until a given time
		"""

		from datetime import datetime, timedelta

		now: float = datetime.utcnow()
		remaining_time = target_time - now

		if remaining_time <= timedelta(0):
			return 0

		# calculate the remaining days, hours, minutes, and seconds
		days = remaining_time.days
		hours, remainder = divmod(remaining_time.seconds, 3600)
		minutes, seconds = divmod(remainder, 60)

		# create an output string only for non-zero fields
		output: list[str] = []

		if days > 0:
			output.append(f'{days}d')

		if hours > 0:
			output.append(f'{hours}h')

		if minutes > 0 or days > 0 or hours > 0:
			output.append(f'{minutes}m')

		output.append(f'{seconds}s')

		return ' '.join(output)

	""" Hashes """

	@classmethod
	def get_sha256_hash(cls, value: str|bytes) -> str:
		"""
		Generates and returns SHA256 hash. Only used for checksums

		@param value(str|bytes): A string or bytes value
		"""
		import hashlib
		return hashlib.sha256(value.encode('utf-8') if isinstance(value, str) else value).hexdigest()

	""" Packages """

	@classmethod
	def install_package(cls, name: str, pip_version: str = None) -> str:
		"""
        Installs a Python package using the current Python interpreter's pip

        @param name(str): The name of the package (can be multiple, separated by space)
		@param pip_version(str): The pip version to use (e.g. 3.12)
        """
		# Use the same Python executable that's running this script
		python_executable = sys.executable

		cmd = f'"{python_executable}" -m pip install {name} -U -i https://pypi.apple.com/simple'

		process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE,
								   stderr=subprocess.PIPE, text=True)

		stdout, stderr = process.communicate()

		if f'Successfully installed {name}' not in stdout and \
				stderr and (has_error := [line for line in stderr.splitlines() if line and not line.startswith(('[notice]', 'WARNING')) and not 'upgrade' in line]):

			if pip_version is None:
				pip_version = f'{sys.version_info.major}.{sys.version_info.minor}'

			fallback_cmd = f'pip{pip_version} install {name} -U -i https://pypi.apple.com/simple'
			process = subprocess.Popen(fallback_cmd, shell=True, stdout=subprocess.PIPE,
									   stderr=subprocess.PIPE, text=True)

			stdout, stderr = process.communicate()

			if f'Successfully installed {name}' not in stdout and \
					stderr and (has_error := [line for line in stderr.splitlines() if line and not line.startswith(('[notice]', 'WARNING')) and not 'upgrade' in line]):

				# If pip version is incorrect, try just the major version
				if 'command not found' in stderr and pip_version != str(sys.version_info.major):
					return cls.install_package(name=name, pip_version=str(sys.version_info.major))

			raise Exception(f'⚠️ Could not run `pip3 install {name}`.\n{stdout}\n---{stderr}')

		return stdout

	@classmethod
	def get_installed_version(cls, package_name: str) -> str:
		"""
		Returns the current installed version of a given package

		@param package_name(str): The name of the package to check the version of
		"""

		import importlib.metadata

		try:
			return importlib.metadata.version(package_name)

		except importlib.metadata.PackageNotFoundError:
			return None

	@classmethod
	def get_latest_version(cls, package_name: str) -> str:
		"""
		Returns the latest available version of a package

		@param package_name(str): The name of the package to check the version of
		"""

		from packaging import version
		from html.parser import HTMLParser

		class VersionHTMLParser(HTMLParser):

			versions: list[str] = []

			def handle_starttag(self, tag: str, attributes: list[tuple]):

				if tag != 'a':
					return

				for attribute_name, attribute_value in attributes:

					if attribute_name != 'href':
						return

					_package_name: str = attribute_value.rsplit('/')[-1].split('#')[0].replace(f'{package_name}-', '').  \
														 replace(f'{package_name.replace("-", "_")}-', '').replace('.tar.gz', '').split('-py3')[0]
					self.versions.append(_package_name)

		response = requests.get(f'https://pypi.apple.com/simple/{package_name}/')

		if response.status_code != 200:
			return

		parser: VersionHTMLParser = VersionHTMLParser()
		parser.feed(response.text)

		if not parser.versions:
			return

		return sorted(parser.versions, key=lambda _version: version.parse(_version))[-1]

	@classmethod
	def compress(cls, path: str, root_directory_name: str = None, skipped_file_names: str = None) -> bytes:
		"""
		[Internal]
		Compresses a folder into a zip file in memory, wrapped with a specified root folder.
		"""
		import io
		import zipfile

		output_buffer = io.BytesIO()

		with zipfile.ZipFile(output_buffer, 'w', compression=zipfile.ZIP_DEFLATED) as zip_file:

			for root, dirs, files in os.walk(path):

				normalized_root: str = os.path.normpath(root)

				# skip `__MACOSX` directory and hidden files
				if '__MACOSX' in normalized_root.split(os.sep):
					continue

				# Skip directory
				current_dir = os.path.basename(root)
				if current_dir in (skipped_file_names or []):
					# Clear the dirs list to prevent walking into subdirectories
					dirs[:] = []
					continue

				# Remove directories from dirs that should be skipped (prevents walking into them)
				dirs[:] = [d for d in dirs if d not in (skipped_file_names or []) and not d.startswith('.')]

				for file_name in files:

					if file_name.startswith('.'):
						continue

					if file_name in (skipped_file_names or []):
						continue

					file_path: str = os.path.join(root, file_name)

					# Get the relative path within the zip file, including the root folder
					relative_path = os.path.relpath(file_path, path)
					zip_file_path: str = None

					if root_directory_name:
						zip_file_path = os.path.join(root_directory_name, relative_path)
					else:
						zip_file_path = relative_path

					zip_file.write(file_path, zip_file_path)

		return output_buffer.getvalue()

	@classmethod
	def decompress(cls, content: bytes, directory_name: str = None) -> str:
		"""
		[Internal]
		Decompresses a given file to a temporary directory
		"""

		import io
		import zipfile
		import tempfile

		temporary_path: str = None

		if directory_name:

			temporary_path = tempfile.gettempdir()
			temporary_path = os.path.join(temporary_path, directory_name)
			os.makedirs(temporary_path, exist_ok=True)

		else:
			temporary_path = tempfile.mkdtemp()

		# read the contents of the file
		with io.BytesIO(content) as zip_buffer:

			with zipfile.ZipFile(zip_buffer, 'r') as zip_file:

				total_compressed_size: float = sum(info.compress_size for info in zip_file.infolist())
				total_uncompressed_size: float = sum(info.file_size for info in zip_file.infolist())

				if total_compressed_size == 0:
					raise Exception('The zip file is empty')

				elif total_compressed_size > (1024 * 1024) * 8:
					raise Exception(f'The zip file should be smaller than 8mb')

				ratio = total_uncompressed_size / total_compressed_size

				# zip file is too big
				if ratio > 50:
					raise Exception('The zip file is potentially malicious.')

				# check for malicious filenames (e.g. containing `..`)
				root_directory_names: set[str] = set()

				for zipinfo in zip_file.infolist():

					if zipinfo.filename.startswith('/') or '..' in zipinfo.filename:
						raise Exception('The zip file has potentially malicious files')

				zip_file.extractall(temporary_path)

		return temporary_path

	""" Visual """

	@classmethod
	def get_average_color(cls, data: bytes) -> tuple[int, int, int]:
		"""
		Returns the average color of an image.

		@param data(bytes): the bytes of the image
		@return tuple: red, green, blue
		"""

		from io import BytesIO

		try:
			from PIL import Image

		except (ImportError, ModuleNotFoundError) as error:

			# for convenience, auto-install Pillow
			if Config.current.is_development:

				logger.section('installing Pillow…')
				cls.install_package(name='Pillow')

			from PIL import Image

		image: Image = Image.open(BytesIO(data)).convert('RGB')
		width, height = image.size

		red_sum = 0
		blue_sum = 0
		green_sum = 0

		for x in range(width):

			for y in range(height):

				red, green, blue = image.getpixel((x, y))

				red_sum += red
				blue_sum += blue
				green_sum += green

		size: int = width * height
		return red_sum // size, green_sum // size, blue_sum // size