import re
import logging
from typing import Any, Callable

from interlinked.core.config import Config
from interlinked.core.utilities import Utilities
from interlinked.core.ai import AI, Observation, Knowledge
from interlinked.core.clients.ajaxclient import AJAXClient
from interlinked.core.clients.googleaiclient import GoogleAIClient
from interlinked.core.workflows.agent.templates import LOOKUP_TEMPLATE


logger = logging.getLogger(__name__)


def lookup_knowledge(query: str, context: str = None, prompt: str = None, knowledge_source_ids: list[int|str] = None,
					 callback: Callable = None, client: Any = None, limit: int = 4, **kwargs) -> str:
	"""
	Use this to search for documentation.
	If the results match the query, respond to the user with a paraphrased version.

	@param query(str): a search query describing the info you're looking for
	@param context(str): words that may be helpful when querying
	"""

	if context and context not in query:
		query = f'{query} {context}'

	# find similar Knowledge
	knowledges: list[Knowledge] = Knowledge.search(query=query, knowledge_source_ids=knowledge_source_ids,
												   limit=limit, min_score=0, max_gap=0.4, client=client)

	if not knowledges:

		if callback:
			callback(None, 'no_results')

		return 'No results. Try another query'

	# TODO: run two `AI.ask` with slightly different queries, then pick the Knowledge that overlaps
	knowledge_content: str = '\n-----\n'.join([knowledge.content for knowledge in knowledges])

	if client and isinstance(client, GoogleAIClient):
		return knowledge_content

	observation: Observation = AI.ask(prompt={'query': query, 'prompt': prompt, 'knowledge_content': knowledge_content},
									  template=LOOKUP_TEMPLATE, client=client)

	response: str = observation.response
	response = response.reduce_verbosity()

	# let the code know which knowledges we're using
	if callback:

		# find which knowledges were actually used in the response by counting the words
		used_knowledges: list[Knowledge] = []
		response_words: list[str] = re.findall(r'(\w{4,})', response, flags=re.IGNORECASE | re.MULTILINE)

		for knowledge in knowledges:

			if len(Utilities.get_words_in_text(words=response_words, text=knowledge.content, strict=False)) > 3:
				used_knowledges.append(knowledge)

		callback(used_knowledges, None)

	# specific response for Ajax models to reduce confusion
	# for other models (OpenAI), we them know that they can try again if the Knowledge doesn't match
	if observation.client.__class__.__name__ == 'AJAXClient':
		return response

	return f'Knowledge results below. If the results don\'t match what you are looking for, try another query.\n\n---\n{response}'


def lookup_person(name: str, **kwargs) -> list[dict]:
	"""
	Looks up a person if their first and last name is known. Returns the details (email and Slack username) of a person

	@param name(str): the person's full name
	"""
	from interlinked.core.clients.appledirectoryclient import AppleDirectoryClient

	persons: list[Person] = AppleDirectoryClient.shared.get_persons_by_name(name=name)

	if not persons:
		return 'No results'

	return [{'email': person.email, 'slack_username': f'<@{person.slack_member_id}>'} for person in persons]


def file_radar(title: str, description: str, component_name: str, classification: str, **kwargs) -> dict[str, Any]:
	"""
	Files a bug/enhancement/task in the Radar tracking system

	@param title(str): a title for the radar
	@param description(str): a description for the radar
	@param component_name(str): the name of the component (e.g. Safari). You must ask the user for the exact name
	@param classification(str): can be any of Security, Serious Bug, Other Bug, Feature, Enhancement, or Task
	"""

	from interlinked.core.classes import ExternalItem
	from interlinked.core.clients.customradarclient import RadarClient
	from interlinked.core.workflows.screen_radars.workflow import AIScreener

	# look up the New Bugs component
	components: list['Component'] = RadarClient.shared.get_components_by_name(name=component_name)

	# pick the New Bugs component
	components = AIScreener.sort_components(components=components)

	if not components:
		return 'Error: No such component'

	classification_map: dict[str, str] = {

		'security': ExternalItem.CLASSIFICATION_SECURITY,
		'serious bug': ExternalItem.CLASSIFICATION_SERIOUS_BUG,
		'other bug': ExternalItem.CLASSIFICATION_OTHER_BUG,
		'feature': ExternalItem.CLASSIFICATION_FEATURE,
		'enhancement': ExternalItem.CLASSIFICATION_ENHANCEMENT,
		'task': ExternalItem.CLASSIFICATION_TASK,
	}

	classification = classification_map.get(classification.lower().replace('_', ' '))

	if not classification:
		return f'Error: classification must be one of [{", ".join(list(classification_map.keys()))}]'

	component: 'Component' = components[0]
	radar: Any = RadarClient.shared.create_radar({'title': title, 'description': description,
												  'classification': classification, 'component': {'id': component.id}})

	return f'Successfully filed rdar://{radar.id} to "{component.name} | {component.version}". Respond directly to the user'


def reply_to_user(reply_text: str, channel_id: str, thread_ts: str, configuration: 'Configuration', **kwargs) -> str:
	"""
	Replies to the user. Always reply to the user

	@param reply_text(str): the content of the message
	"""

	from interlinked.core.clients.slackclient import SlackClient

	reply_text = Utilities.remove_signature(text=reply_text)

	SlackClient.shared.send_message(channel=channel_id, text=reply_text, username=configuration.data.name,
									thread_ts=thread_ts, icon_emoji=configuration.data.slack_image)

	return 'Reply sent successfully'


def send_email(to_addresses: list[str] | str, subject: str, body: str, from_address: str, **kwargs) -> str:
	"""
	Sends an email

	@param to_addresses(list): list of email addresses to send an email to
	@param subject(str): the subject of the email
	@param body(str): the body of the email
	"""
	from interlinked.core.clients.mailclient import MailClient

	MailClient.send(from_address=from_address, to_addresses=to_addresses, subject=subject, body=body)


def resolve_slack_thread(channel_id: str, thread_ts: str, **kwargs):
	"""
	Marks a Slack thread as fully resolved. All of the user's questions were fully answered
	Only use if the user says their question/ask has been resolved or thanks us
	"""

	from slack_sdk.errors import SlackApiError
	from interlinked.core.clients.slackclient import SlackClient

	try:
		SlackClient.shared.app.client.reactions_add(channel=channel_id, name='white_check_mark', timestamp=thread_ts)

	except SlackApiError as error:

		# raised if we already reacted
		if 'already_reacted' not in str(error):
			raise error from error

	return 'Resolved'


def run_code(channel_id: str, thread_ts: str, **kwargs):
	"""
	Runs code in a VM
	"""
	print('run_code', kwargs)


if __name__ == '__main__':
	print(lookup_knowledge(query='launchd.report', prompt='Whatâ€™s the purpose of the launchd.report?'))
