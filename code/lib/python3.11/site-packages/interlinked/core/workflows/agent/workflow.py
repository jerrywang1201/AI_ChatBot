import os
import re
import difflib
import logging
from pydantic import BaseModel
from typing import Any, Optional

from interlinked.core.tool import Tool
from interlinked.core.utilities import Utilities
from interlinked.core.workflows.agent.tools import *
from interlinked.core.dynamic.functions import Function
from interlinked.core.workflows.agent.templates import *
from interlinked.core.clients.ajaxclient import AJAXClient
from interlinked.core.clients.googleaiclient import GoogleAIClient
from interlinked.core.workflows.agent.workflownonui import AgentNonUI
from interlinked.core.ai import AI, Observation, Template, Response, Pause
from interlinked.ui.models import BaseWorkflow, BaseConfiguration, KnowledgeSource, Thread, ThreadSource,  \
									Message, Tool as DatabaseTool, Configuration as DatabaseConfiguration

logger = logging.getLogger(__name__)


class ConfigurationData(BaseModel):

	name: str
	email: str | None = None

	slack_image: str | None = None
	slack_template: str = SLACK_TEMPLATE
	slack_channels: list[str] | None = []

	client_name: str | None = 'googleaiclient'

	tool_names: list[str] | None = []
	knowledge_configuration_ids: Optional[list[int]] = []

	def custom_validate(self, values: dict[str, Any], previous: 'ConfigurationData' = None, dsid: int = None) -> None:
		"""
		Validates a dictionary of fields that match the fields in this class

		@param previous(ConfigurationData): the previous instance of this configuration
		@param dsid(int): the DSID of the user making the changes
		"""

		data: dict[str, Any] = values.get('data')

		for field_name, value in data.items():

			if field_name.endswith('_template') and value != getattr(self, field_name):

				built_in_template: Template = Template(text=getattr(sys.modules[__name__], field_name.upper()))
				new_template: Template = Template(text=value)

				if len(built_in_template.fields) > len(new_template.fields):
					raise Exception(f'Your "{field_name}" template is missing fields that were in the original one')


class Configuration(BaseConfiguration):

	data: ConfigurationData


class Agent(AgentNonUI, BaseWorkflow):

	DEFAULT_CONFIGURATION: Configuration = Configuration(data=ConfigurationData(name='Interlinked (Default)'))

	@classmethod
	def handle_ui_message(cls, ask_ai_request: 'AskAIRequest', user: 'User' = None) -> dict[str, Any]:
		"""
		Handles (and replies to) a message from the UI
		"""

		configurations: list[DatabaseConfiguration] = None

		if not ask_ai_request._client and not ask_ai_request.client_name or ask_ai_request.client_name == 'ajaxclient':
			ask_ai_request._client = AJAXClient(model_name='afm-text-30b-instruct-latest')

		# `user` is required in production
		if user or not Config.current.is_development:
			configurations = DatabaseConfiguration.get_for_user(user=user, workflow_name='knowledge')

		# get the KnowledgeSource IDs
		knowledge_sources: list[KnowledgeSource] = None

		if configurations:
			knowledge_sources = KnowledgeSource.select().join(DatabaseConfiguration).  \
												where(DatabaseConfiguration.id.in_({configuration.id for configuration in configurations})).all()

		# if the caller wants us to limit the knowledge sources to a set of IDs
		if ask_ai_request.knowledge_source_ids:
			knowledge_sources = [knowledge_source for knowledge_source in knowledge_sources if knowledge_source.id in ask_ai_request.knowledge_source_ids]

		# TODO: use distinct instead
		if knowledge_sources:
			knowledge_sources = list({knowledge_source.external_id: knowledge_source for knowledge_source in knowledge_sources}.values())

		knowledge_source_ids: list[int] = [knowledge_source.id for knowledge_source in knowledge_source] if ask_ai_request.knowledge_source_ids else None

		observation, used_knowledges = AgentNonUI.handle_nonui_message(prompt=ask_ai_request.prompt, messages=ask_ai_request.messages,
																	   client=ask_ai_request.client, knowledge_source_ids=knowledge_source_ids)

		# if AI used lookup_knowledge, return the sources to the user
		sources: list[dict[str, str|int]] = []

		if used_knowledges:

			# get a list of words chunked into two that will be used later to find the knowledge sources the words map to
			response_sentences: set[str] = set(re.split(r'(?<=[.!?])\s+|[\r\n]+', observation.response, flags=re.IGNORECASE | re.MULTILINE))
			response_sentences = [sentence.strip('.').strip(':') for sentence in response_sentences if len(sentence.split()) > 4]

			# get the `display_source` of the knowledge (e.g. `quip-apple.com/ElRgAaaTbxmi`)
			for knowledge in used_knowledges:

				display_source: str = None
				knowledge_source: KnowledgeSource = None

				if knowledge_sources and knowledge.knowledge_source_id:

					knowledge_source = next(knowledge_source for knowledge_source in knowledge_sources if knowledge_source.id == knowledge.knowledge_source_id)

					if knowledge.external_id:
						display_source = knowledge_source.get_display_source_for_knowledge(knowledge=knowledge)

					else:
						display_source = knowledge_source.display_source

				elif knowledge.knowledge_source_id:
					display_source = f'{knowledge.knowledge_source_id} ({knowledge.external_id})'

				knowledge_sentences: set[str] = set(re.split(r'(?<=[.!?])\s+|[\r\n]+', knowledge.content, flags=re.IGNORECASE | re.MULTILINE))
				chunks: set[str] = set()

				for response_sentence in response_sentences:

					# find + add any sentences from the response that are similar to sentences from the Knowledge
					if any(knowledge_sentence for knowledge_sentence in knowledge_sentences if
							difflib.SequenceMatcher(None, response_sentence, knowledge_sentence).ratio() >= 0.5):
						chunks.add(response_sentence)

				sources.append({

					'chunks': list(chunks),
					'content': knowledge.content[:100],
					'knowledge_source': display_source,
				})

		return {'observation': observation, 'sources': sources}

	@classmethod
	def handle_slack_message(cls, text: str, channel_id: str, thread_ts: str, sender: 'Person',
							 configuration: DatabaseConfiguration = DEFAULT_CONFIGURATION) -> None:
		"""
		Handles (and replies to) a Slack message
		"""

		# convert configuration to our type
		configuration = Configuration(**configuration.model_dump())

		# get the KnowledgeSource IDs
		knowledge_sources: list[KnowledgeSource] = None

		if configuration:

			knowledge_sources = KnowledgeSource.select().join(DatabaseConfiguration). \
														 where(DatabaseConfiguration.id.in_(configuration.data.knowledge_configuration_ids)).all()

			# TODO: use distinct instead
			knowledge_sources = list({knowledge_source.external_id: knowledge_source for knowledge_source in knowledge_sources}.values())

		# strip @ identifier if the message has `@Interlinked` (`<@…>`)
		# TODO: unless it's someone else that's @, then we want to keep that and convert it to their full name
		text = re.sub(r'\<@[A-Z0-9]+\>', '', text).strip()

		# look up to see if there's an existing Thread
		thread, _ = Thread.get_or_create(source=ThreadSource.slack, external_id=thread_ts, configuration_id=configuration.id)
		messages: list[Message] = thread.messages

		client: Any = GoogleAIClient(model_name='gemini-2.5-pro')

		# get a list of tools to give AI access to
		tools: list[Tool] = [Tool(function=lookup_person)]

		if knowledge_sources:

			knowledge_source_ids: list[int] = [knowledge_source.id for knowledge_source in knowledge_sources]
			tools.append(Tool(function=lookup_knowledge, function_kwargs={'prompt': text, 'knowledge_source_ids': knowledge_source_ids,
																		  'callback': None, 'client': client, 'limit': 20}))

		# add resolve thread only after there's been a conversation
		# to avoid potentially having it resolved before a response is made
		if messages and not '?' in text:
			tools.append(Tool(function=resolve_slack_thread, function_kwargs={'channel_id': channel_id, 'thread_ts': thread_ts}))

		for tool_name in configuration.data.tool_names:

			if tool_name in {tool.name for tool in tools}:
				continue

			db_tool: DatabaseTool = DatabaseTool.get_or_none(name=tool_name)

			if not db_tool:

				logger.error(f'could not find tool "{tool_name}" ({configuration.id=})')
				continue

			tools.append(db_tool.tool)

		logger.info(f'tools: {tools}')

		# add system message
		template_text: str = Template(text=configuration.data.slack_template).get_populated_text(prompt={'name': configuration.data.name})
		messages.insert(0, client.create_message(role=client.ROLE_SYSTEM, content=template_text))

		# ask AI
		observation: Observation = AI.ask(prompt=text, tools=tools, messages=[message if isinstance(message, dict) else message.raw for message in messages], client=client)

		reply_to_user(reply_text=observation.response, channel_id=channel_id, thread_ts=thread_ts, configuration=configuration)

		for message_index, message in enumerate(observation.messages):

			# only add new messages (we use index to track which ones are already in the database)
			# if message_index < len(messages) - 1:
				# continue

			# convert message to a dict if it's a custom type (e.g. `OpenAIClient` uses a class instead of dict)
			if isinstance(message, BaseModel):
				message = message.model_dump()

			# add the reply to the database
			Message.create(sender=None, raw=message, thread_id=thread.id)

		logger.info('✅ successfully handled slack message')


if __name__ == '__main__':

	configuration: DatabaseConfiguration = DatabaseConfiguration.select().where(DatabaseConfiguration.workflow_name == 'agent').first()
	print(configuration.model_dump())
	# Configuration(created_by=1, data={'name': '1'})
