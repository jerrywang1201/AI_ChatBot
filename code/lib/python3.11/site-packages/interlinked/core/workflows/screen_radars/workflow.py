import os
import re
import sys
import math
import locale
import random
import pathlib
import logging
import threading
from enum import IntEnum
from typing import Any, Optional
from radarclient import Component
from collections import defaultdict
from datetime import datetime, timedelta
from pydantic import BaseModel, PrivateAttr, ValidationError

from interlinked.core.config import Config
from interlinked.core.utilities import Utilities
from interlinked.core.clients.ajaxclient import AJAXClient
from interlinked.core.workflows.screen_radars.templates import *
from interlinked.core.clients.customradarclient import RadarClient
from interlinked.core.classes import ExternalItem, SimilarItem, Person
from interlinked.core.clients.appledirectoryclient import AppleDirectoryClient
from interlinked.core.ai import AI, Observation, Template, Enum, Knowledge, Section
from interlinked.ui.models import BaseWorkflow, BaseConfiguration, Suggestion, Configuration as DatabaseConfiguration

logger = logging.getLogger(__name__)


class AssignmentOrder(IntEnum):

	before: int = 0
	during: int = 1
	after: int = 2


class Behavior(IntEnum):

	suggest: int = 0
	save: int = 1


class ConfigurationData(BaseModel):

	radar_query_id: int

	find_component_behavior: Optional[Behavior | None] = None
	find_subcomponent_behavior: Optional[Behavior | None] = None

	find_duplicate_behavior: Optional[Behavior | None] = None
	classification_behavior: Optional[Behavior | None] = None

	return_non_actionable_seed_radars: bool = False

	# assignments
	assign_if_duplicate: bool = False
	assignee_behavior: Optional[Behavior | None] = None
	assignments_group_dsid: Optional[int | None] = None
	assignments_order: AssignmentOrder = AssignmentOrder.during
	assignment_percentages: Optional[dict[int, float] | None] = {}

	# security
	security_dri_behavior: Optional[Behavior | None] = None
	return_non_security_seed_radars: bool = False

	# templates
	component_template: str = COMPONENT_TEMPLATE
	verify_duplicate_template: str = VERIFY_DUPLICATE_TEMPLATE
	classification_internal_template: str = CLASSIFICATION_INTERNAL_TEMPLATE

	knowledge_source_ids: Optional[list[int|str]] = None

	# private
	_assignments_persons: Optional[list[Person]] = PrivateAttr(default=None)
	_assignments_person_dsids: Optional[list[int]] = PrivateAttr(default=None)

	@property
	def assignments_persons(self) -> list[Person]:
		"""
		If `assignments_group_dsid` is set, this property will return a list of `Person`
		"""

		if self._assignments_persons is None:

			if self.assignments_group_dsid:
				self._assignments_persons = [person for person in AppleDirectoryClient.shared.get_persons_for_group_dsid(dsid=self.assignments_group_dsid, nested=True)]

			else:
				self._assignments_persons = []

		return self._assignments_persons

	@property
	def assignments_person_dsids(self) -> list[int]:
		"""
		If `assignments_group_dsid` is set, this property will return a list of `Person` DSIDs
		"""

		if self._assignments_person_dsids is None:
			self._assignments_person_dsids = [person.dsid for person in self.assignments_persons]

		return self._assignments_person_dsids

	def custom_validate(self, values: dict[str, Any], previous: 'ConfigurationData' = None, dsid: int = None) -> None:
		"""
		Validates a dictionary of fields that match the fields in this class

		@param previous(ConfigurationData): the previous instance of this configuration
		@param dsid(int): the DSID of the user making the changes
		"""

		data: dict[str, Any] = values.get('data')

		for field_name, value in data.items():

			# make sure we have access to the query
			if field_name == 'radar_query_id' and value != self.radar_query_id:

				items: list[ExternalItem] = RadarClient.shared.get_items_for_query_id(query_id=value)

				if not items:
					raise Exception('The query is invalid or has no radars')

				elif not Config.current.is_development and len(items) > 100:

					raise Exception('The query has too many radars. Our production instance of Interlinked can currently handle up to 30 radars. '
									'If you would like to screen more, please run Interlinked locally')

			# validate the template and fields
			elif field_name.endswith('_template'):

				built_in_template: Template = Template(text=getattr(sys.modules[__name__], field_name.upper()))
				new_template: Template = Template(text=value)

				if len(built_in_template.fields) > len(new_template.fields):
					raise Exception(f'Your "{field_name}" template is missing fields that were in the original one')

				# make sure names/alternative names are the same
				built_in_field_names: set[str] = {_field.alternative_name or _field.name for _field in built_in_template.fields.values() if _field.required}
				new_field_names: set[str] = {_field.alternative_name or _field.name for _field in new_template.fields.values()}

				if len(built_in_field_names - new_field_names) > 0:
					raise Exception(f'Your template is missing a required field. Did you accidentally delete a field?')


class Configuration(BaseConfiguration):

	data: ConfigurationData

	def add_suggestion(self, item: ExternalItem, name: str, value: Any, **kwargs):
		"""
		Convenience method that creates a suggestion and adds it to an item
		"""
		Suggestion.create(name=name, value=value, item_external_id=item.external_id,
						  configuration_id=self.id, **kwargs)


class AIScreener(BaseWorkflow):

	""" Customizable fields """

	# general configuration
	THREAD_COUNT: int = int(os.getenv('INTERLINKED_THREAD_COUNT', 4))

	# components to not suggest/ignore
	# you can find the component ID using Radar â†’ Find â†’ Component
	IGNORED_COMPONENTS: set[Component] = {Component(id=int(component_id)) for component_id in os.getenv('INTERLINKED_IGNORED_COMPONENT_IDS', '').split(',') if component_id}.union({Component(id=200145)})

	""" Static fields """

	# enum options that are likely too broad
	BROAD_ENUM_OPTIONS: set[str] = {'sandbox', 'sandbox bypass', 'app sandbox', 'tcc', 'tcc bypass'}

	# radar components to always skip because external radars are
	# unlikely to be in these components
	EXCLUDED_COMPONENT_NAMES: set[str] = {'*Guardian*', '*OS Build*', '*Customer Feedback Holding*', 'Product Security', '*-SRE', '* SRE', '*Documentation*', '* IT',
										  '*do not use*', '*trash*', '* Ops', '* QA', 'Activation Lock Mailer', 'Chatlet', '*apple.com', '* Automation', '* Help',
										  'AMP *', 'QRF*', 'IS&T', 'Feedback Pool', 'Loc:*', '*TSTT', 'Red team*', '*PEP Localization*', '*Retail*', '* Ops *',
										  '*Customer*', '*CSP*', '*Panic Triage*', '* UAT', '*Capture Data*', '*Data Collection*', 'Infra*', '*Bringup',
										  '*Build Failures*', 'Sitewatch', '* QE'}.union(set(Templates.PLATFORM_NAMES))
	EXCLUDED_COMPONENT_VERSIONS: set[str] = EXCLUDED_COMPONENT_NAMES.union({'Automation'}).difference(set(Templates.PLATFORM_NAMES))

	ISSUE_POOL_COMPONENT: Component = Component(id=962606, name='Issue Pool', version='(seed)')

	# TODO: use embeddings to `"where should i send Safari bugs to?"`
	# then it'll give a list. if the distance is 0, and there are multiple options,
	# pick the most relevant component
	# TODO: in the future, track the bugs AI sends to components, and see
	# if they do end up being in that component, then auto-remember the component and add it
	# to the list
	CACHED_COMPONENTS: dict[str, list[Component]] = {

		'Maps':  [Component(id=667072, name='Maps', version='New Bugs')],
		'libxml2': [Component(id=173762, name='libxml2', version='All')],
		'Safari': [Component(id=144485, name='Safari', version='(New Bugs)')],
		'WebKit': [Component(id=144485, name='WebKit', version='(New Bugs)')],
		'Siri': [Component(id=672551, name='Siri (New Bugs)', version='(All)')],
		'Photos': [Component(id=630529, name='Photos (New Bugs)', version='all')],
	}

	# e.g. {component ID (int): whether to skip/ignore (bool)}
	CACHED_CHECKED_COMPONENT_IDS: dict[int, bool] = {component.id: True for component in IGNORED_COMPONENTS}
	CACHED_EMBEDDINGS: list[float] = []

	NEW_BUGS_PATTERN: str = r'\b(new bugs|all|[0-9]{1,2}\.[0-9]{1,2}|X)\b'

	DEFAULT_CONFIGURATION: Configuration = Configuration(data=ConfigurationData(radar_query_id=2635902,
																				find_component_behavior=Behavior.suggest,
																				security_dri_behavior=Behavior.suggest,
																				find_duplicate_behavior=Behavior.suggest,
																				return_non_actionable_seed_radars=True,
																				return_non_security_seed_radars=False,
																				assign_if_duplicate=True))

	@classmethod
	def run(cls, configuration_id: int = None, reset_suggestions: bool = False, external_ids: list[str]|str = None, **kwargs) -> None:
		"""
		Runs AI Screener

		All of the arguments below can be passed via the CLI. e.g. `interlinked screen_radars 1 --external_ids="rdar://12345&67890"`

		@param configuration_id(int): the ID of the Configuration that was created by the user in the UI
		@param reset_suggestions(bool): (Optional) resets all suggestions before running
		@param external_ids(list): (Optional) if set, the screener will only screen a list of radar IDs instead of radar query
		"""

		configuration: Configuration = None

		if not configuration_id:

			logger.warning('no id passed. using defaultâ€¦')
			configuration = AIScreener.DEFAULT_CONFIGURATION

		else:

			configuration: Configuration = Configuration(**DatabaseConfiguration.get_or_none(id=configuration_id).model_dump())

			if not configuration:
				raise Exception(f'configuration not found ({configuration_id=})')

		if AIScreener.THREAD_COUNT > 4:
			AIScreener.THREAD_COUNT = 4

		elif AIScreener.THREAD_COUNT < 1:
			AIScreener.THREAD_COUNT = 1

		# can be used in the CLI to reset suggestions
		if reset_suggestions:
			Suggestion.delete().where(Suggestion.configuration_id == configuration.id).execute()

		items: list[ExternalItem] = []

		# if external IDs are passed, use that instead
		# otherwise, get the list of radars from the radar query in Configuration
		if external_ids:

			if isinstance(external_ids, str):
				external_ids = external_ids.split('&')

			items = [RadarClient.shared.get_item_for_radar_id(id=external_id) for external_id in external_ids]

		else:

			logger.info(f'querying radars to screenâ€¦ (radar_query_id={configuration.data.radar_query_id})')
			items = RadarClient.shared.get_items_for_query_id(query_id=configuration.data.radar_query_id)

		# sort by oldest
		items.sort(key=lambda item: item.external_id)

		for item in items[:]:

			# skip umbrella radars
			if 'â˜‚ï¸' in item.title or 'â˜”ï¸' in item.title:

				logger.info(f'skipping umbrella radarâ€¦ ({item=})')
				items.remove(item)

		# assign radars
		if (configuration.data.assignee_behavior or configuration.data.security_dri_behavior) and  \
			configuration.data.assignments_order == AssignmentOrder.before:

			logger.info(f'assigning {len(items)} radarsâ€¦')
			AIScreener.assign_items(items=items, configuration=configuration)

		# if we're in production, limit the number of radars to screen to first 100
		if not Config.current.is_development and len(items) > 100:

			logger.warning('too many radars in query. screening first 100')
			items = items[:100]

		logger.info(f'screening {len(items)} radarsâ€¦')

		# split items by chunks for multithreading
		for items_chunk in Utilities.split_by_chunks(full_list=items, chunk_size=AIScreener.THREAD_COUNT):

			def _screen_item(item: ExternalItem) -> None:

				try:
					AIScreener.screen_item(item=item, configuration=configuration)

				except Exception as exception:

					logger.error(f'could not screen item ({item=})', exc_info=True)
					logger.info('--\n\n')
					return

				logger.info('--\n\n')

			threads: list[threading.Thread] = []

			for item in items_chunk:

				thread: threading.Thread = threading.Thread(target=_screen_item, args=(item, ))
				threads.append(thread)
				thread.start()

			for thread in threads:
				thread.join()

		# assign radars
		if (configuration.data.assignee_behavior or configuration.data.security_dri_behavior) and  \
			configuration.data.assignments_order == AssignmentOrder.after:

			logger.info(f'assigning {len(items)} radarsâ€¦')
			AIScreener.assign_items(items=items, configuration=configuration)

	@classmethod
	def screen_item(cls, item: ExternalItem, configuration: Configuration):
		"""
		Asks AI to screen a radar
		"""

		is_seed: bool = item.title.startswith('SEED:')
		title, description = cls.get_title_description_for_item(item=item)
		prompt: dict[str, str] = {'title': title, 'description': description}

		logger.section(f'screening radarâ€¦ ({item.external_id} {title})')

		# classification
		comment_suggestion: Suggestion = Suggestion.select().where(Suggestion.item_external_id == item.external_id,
																   Suggestion.name == 'internal_comment', Suggestion.configuration_id == configuration.id,
																   Suggestion.result.is_(None)).first()

		if not comment_suggestion:

			classification, summary = cls.get_classification_for_item(item=item, title=title, description=description, configuration=configuration)

			if configuration.data.classification_behavior is not None:
				logger.info(f'classification: {classification}')

		else:

			summary = comment_suggestion.value
			classification = item.classification

		logger.info(f'summary: {summary}')

		# if this is a SEED radar, check if it makes sense
		if configuration.data.return_non_actionable_seed_radars and is_seed  \
			and (observation := AI.ask(prompt={**prompt, **{'display_classification': cls.get_display_classification(classification=classification)}},
														 template=CLASSIFICATION_SEED_TEMPLATE)) and observation.thought:

			if observation.category.is_nonsense:

				logger.info(f'â„¹ï¸  SEED classifier said this is nonsense ({observation.thought=})')
				cls.stage_seed_feedback_item(item=item, comment_text=observation.thought, configuration=configuration)
				return

			elif configuration.data.return_non_security_seed_radars and classification != ExternalItem.CLASSIFICATION_SECURITY:

				logger.info(f'moving to SEED Feedback since the classification is not security ({observation.thought=})')
				cls.stage_seed_feedback_item(item=item, comment_text=summary, configuration=configuration)
				return

		component, component_thought, actual_search_term = None, None, None
		component_suggestion: Suggestion = Suggestion.select().where(Suggestion.item_external_id == item.external_id,
																	 Suggestion.name == 'component', Suggestion.configuration_id == configuration.id,
																	 Suggestion.result.is_(None)).first()

		if configuration.data.find_component_behavior is not None and not component_suggestion:

			component, component_thought, actual_search_term = cls.get_component_for_item(item=item, title=title, description=description,
																						  classification=classification)

			if not component:
				logger.error(f'could not find component for item ({item=})')

			logger.info(f'ðŸ: {component}')

		else:

			# if we already have a suggested component, use that. otherwise, use the current item's component
			if component_suggestion:

				components = RadarClient.shared.components_for_ids(component_ids=[component_suggestion.value])

				if components:

					component = components[0]
					logger.info(f'using previously-suggested component ({component=}, {item=})')

			else:
				component = item.component

			if not component:
				raise Exception('missing component')

		# find subcomponent
		if component and configuration.data.find_subcomponent_behavior is not None and not component_suggestion:

			component, component_thought = cls.get_subcomponent_for_item(item=item, component=component, classification=classification,
																		 required_search_term=actual_search_term, configuration=configuration)

			logger.info(f'ðŸ: {component} (current: {item.component.name})')

		# find duplicates
		duplicate_item, duplicate_thought = None, None
		duplicate_item_suggestion: Suggestion = Suggestion.select().where(Suggestion.item_external_id == item.external_id,
																		  Suggestion.name == 'duplicate_of', Suggestion.configuration_id == configuration.id,
																		  Suggestion.result.is_(None)).first()

		if component and configuration.data.find_duplicate_behavior is not None and not duplicate_item_suggestion:

			# TODO: if top 4 similar radars are in the same component, maybe override `component` with that?
			duplicate_item, duplicate_thought = cls.get_duplicate_item_for_item(item=item, component=component, classification=classification,
																				configuration=configuration)

			if duplicate_item:
				logger.info(f'found duplicate ({duplicate_item=} {duplicate_thought=}, {item=})')

			if duplicate_item:
				configuration.add_suggestion(name='duplicate_of', value=duplicate_item.external_id,
											 display_value=f'{duplicate_item.external_id} {duplicate_item.title}', thought=duplicate_thought, item=item)

		# security type
		if item.classification == ExternalItem.CLASSIFICATION_SECURITY:

			# if the radar is not a security/privacy vulnerability, set Security Type to None
			security_type_suggestion: Suggestion = Suggestion.select().where(Suggestion.item_external_id == item.external_id,
																			 Suggestion.name == 'security_type', Suggestion.configuration_id == configuration.id,
																			 Suggestion.result.is_(None)).first()

			if configuration.data.classification_behavior is not None and not security_type_suggestion:

				if classification == ExternalItem.CLASSIFICATION_SECURITY:

					# check if this is a null-dereference
					null_dereference_words: list[str] = Utilities.get_words_in_text(words={'null deref', 'null-deref', 'null pointer'}, text=f'{title}{description}', strict=False)

					if null_dereference_words:

						observation: Observation = AI.ask(prompt=prompt, template=NULL_DEREFERENCE_TEMPLATE)

						if observation.is_null_deref:
							classification = ExternalItem.CLASSIFICATION_CHD

				# if the suggested classification is not security, add the suggestion
				if classification != ExternalItem.CLASSIFICATION_SECURITY:
					configuration.add_suggestion(name='security_type', value=ExternalItem.PRODUCT_SECURITY_TYPE_NONE, item=item)

		# set assignee if the item is not a duplicate
		if not (configuration.data.assign_if_duplicate and duplicate_item) and  \
			   (configuration.data.assignee_behavior or configuration.data.security_dri_behavior) and  \
			   configuration.data.assignments_order == AssignmentOrder.during and  \
			   component:

			assignment_field_name: str = 'assignee' if configuration.data.assignee_behavior is not None else 'security_dri'
			assignment_suggestion: Suggestion = Suggestion.select().where(Suggestion.item_external_id == item.external_id,
																		  Suggestion.name == assignment_field_name, Suggestion.configuration_id == configuration.id,
																		  Suggestion.result.is_(None)).first()

			# only assign if we don't have a suggested assignee yet
			if not assignment_suggestion:

				person, thought = None, None

				if configuration.data.assignee_behavior is not None:
					person, thought = cls.get_assignee_for_item(item=item, component=component, configuration=configuration)

				else:
					person, thought = cls.get_security_dri_for_item(item=item, component=component, configuration=configuration)

				if person:
					configuration.add_suggestion(name=assignment_field_name, value=person.dsid, display_value=person.name,
												 thought=thought, item=item)

				else:
					logger.error(f'no person assigned ({item=})')

		# set suggestions
		if not component_suggestion and  \
			(configuration.data.find_component_behavior is not None or configuration.data.find_subcomponent_behavior is not None) and  \
			(component and component.id != item.component.id):

			# update summary with component name
			# e.g. `Siri (New Bugs)` -> `Siri`
			display_component_name: str = component.name.split('-', 1)[0].split('(', 1)[0]

			# print('item.component.name', item.component.name)
			# print('display_component_name', display_component_name, component.name)

			# # if the radar is already in WebKit, and we're sending to a subcomponent, use the subcomponent name instead
			# # e.g. `â€¦. Over to Layout and Rendering` (a subcomponent of WebKit)
			# # only replace whole words
			# # e.g. item.component = `CoPresense`, display_component_name = 'CoPresense-Core'
			# # we want to keep `display_component_name` as is
			# if item.component.name.startswith(display_component_name):
			# 	display_component_name = item.component.name.replace(f'{display_component_name} ', '').strip()

			summary = f'{summary}. Over to {display_component_name}' if summary else f'Over to {display_component_name}'

			configuration.add_suggestion(name='component', value=component.id, display_value=f'{component.name} | {component.version}',
										 thought=component_thought, item=item)

		if configuration.data.classification_behavior == Behavior.suggest and classification != item.classification:
			configuration.add_suggestion(name='classification', value=classification, item=item)

		# only comment if we haven't written a comment yet
		if not comment_suggestion:
			configuration.add_suggestion(name='internal_comment', value=summary, item=item)

	@classmethod
	def get_title_description_for_item(cls, item: ExternalItem, max_length: int = 700,
									   include_attachments: bool = True, include_hw_names: bool = False) -> tuple[str, str]:
		"""
		Returns a sanitized title and description for a given radar item

		@param include_hw_names(bool): off by default to avoid misdetecting HW names as components
		"""

		title: str = item.display_title.removeprefix('Dup: ')
		is_seed: bool = title.startswith('SEED:')

		# pass the title and description to AI
		# we get the raw text instead of display to allow us to call `clean_seed` with custom args
		descriptions: list[str] = sorted(item.descriptions, key=lambda entry: entry.addedAt, reverse=True)
		description: str = next((description for description in descriptions if description.text and not description.text.startswith('Page tracking all')), None) if descriptions else None
		description = description.text if description else None

		if not description:

			logger.error(f'could not screen radar. no description ({item=})')
			return None, None

		# remove Tap-to-Radar, etc from the description
		description = Utilities.remove_standard_headers(text=description)

		# if this is a Seed radar, get only the description part of the description and ignore irrelavent things
		if is_seed:
			description = Utilities.remove_seed_text(text=description, description_only=True)

		# e.g. rdar://109212407
		elif re.findall(r'\bAppleCare:', title):
			title, description = Utilities.remove_applecare_text(title=title, description=description)

		# e.g. rdar://109057212
		elif 'oss-fuzz:' in title:
			title, description = Utilities.remove_ossfuzz_text(title=title, description=description)

		title = title.removeprefix('SEED: Web:').removeprefix('SEED:').removeprefix('Dup: ').replace('GWP-ASan', '').replace('Carpe Facto', '').strip()
		description = re.sub(r'FB([0-9]{7,9})', '', description, flags=re.MULTILINE)
		description = description.replace('GWP-ASan', '')

		# GitHub/Stash links
		# e.g. `https://github.com/apple/batch-processing-gateway/â€¦/src/DBConnection.java`
		#   -> `batch-processing-gateway. https://github.com/apple/batch-processing-gateway/â€¦/src/DBConnection.java`
		description = re.sub(r'(http(?:s|)://(?:apple\.|)github\.com)/([^/]+)/([^/]+).*?', r'\3. \1/\2/\3', description, flags=re.IGNORECASE | re.MULTILINE)

		# truncate to the nearest word (700 characters)
		if truncated_description := re.match(fr'^.{{0,{max_length}}}\b', description, flags=re.DOTALL):
			description = truncated_description.group(0)

		description = description.strip()

		# if the radar is prefixed with the reporter's domain, remove it (e.g. Google: â€¦) (e.g. rdar://115259561)
		# if item.reporter_info and (domain_raw := item.reporter_info.domain_raw):
		# 	title = title.replace(f'{domain_raw.split(".")[0].title()}: ', '').strip()

		# remove build numbers from title
		title = cls.remove_builds(text=title)

		# attempt to remove HW codenames from title
		if not include_hw_names:

			title = re.sub(r'[A-Z][0-9]{2,3}([a-z]|)', r'', title)
			title = re.sub(r'(iPhone|iPad|(?:i|)Mac(?:[A-Za-z]+|)|Watch|RealityDevice)[0-9]{1,2},[0-9]{1,2}', r'\1', title)

		# remove any leading charachters from the above
		title = re.sub(r'^[/:+]+', '', title).strip()

		# e.g. `N399/: bug in` -> `N399: bug in`
		title = title.replace('/: ', ': ').strip()

		# add attachment file names
		if include_attachments:

			attachment_display_file_names: set[str] = set()

			for attachment in item.attachments:

				attachment_name: str = attachment.fileName

				if 'auto_sym' in attachment_name:
					continue

				attachment_name = os.path.basename(attachment_name.replace('ï¼', '/'))

				# add crash logs to the description
				if attachment_name.endswith('.ips') and  \
					not attachment_name.startswith(('stacks', 'JetsamEvent', 'ExcResource', 'ExcUserFault')) and  \
					not 'runloop' in attachment_name:
					attachment_display_file_names.add(f'- {attachment_name.split("-", 1)[0]}')

			if attachment_display_file_names:

				attachment_display_file_names = '\n'.join(list(attachment_display_file_names)[:10])
				description = f'{description}\n\nAttachments:\n{attachment_display_file_names}'

		# e.g. `**bold**` -> `bold`
		title = re.sub(r'^\*\*(.*?)\*\*$', r'\1', title, flags=re.IGNORECASE | re.MULTILINE)
		description = re.sub(r'^\*\*(.*?)\*\*$', r'\1', description, flags=re.IGNORECASE | re.MULTILINE)

		return title, description

	@classmethod
	def learn_from_item(cls, item: ExternalItem) -> list[Knowledge]:
		"""
		Learns from a given radar item
		"""

		title, description = cls.get_title_description_for_item(item=item, include_attachments=False)
		return AI.learn(input=Section(title=title, content=[description]), knowledge_source_id=item.external_id)

	@classmethod
	def get_embedding_for_item(cls, item: ExternalItem) -> list[float]:
		"""
		Returns embedding for a given radar item
		"""

		title, description = cls.get_title_description_for_item(item=item, include_attachments=False)

		content: set[str] = set()

		if title:
			content.add(title)

		if description:
			content.add(description)

		content: str = '\n'.join(content)
		# content = PatternsUtility.replace_all(text=content, detect_signature=False, skip_replacement=True)

		return AI.client.get_embedding(input=content)

	@classmethod
	def get_classification_for_item(cls, item: ExternalItem, title: str, description: str,
									configuration: Configuration = DEFAULT_CONFIGURATION) -> tuple[str, str]:
		"""
		Asks AI to classify a given radar item

		@param item(Item): an unscreened radar
		@param title(str): the cleaned-up version of the title
		@param description(str): the cleaned-up version of the description
		"""

		is_seed: bool = title.startswith('SEED:')
		is_external: bool = is_seed
		# is_external: bool = is_seed or ProductSecurityPrescreen.RADAR_ADVISORY_KEYWORD_ID in item.keyword_ids

		# multi-turn prompt. ask what the report is about, then ask for classification
		prompt: dict = {'title': title, 'description': description, 'display_classification': 'report'}
		observation: Observation = AI.ask(prompt=prompt, template=INITIAL_TEMPLATE)

		template: str = CLASSIFICATION_EXTERNAL_TEMPLATE if is_external else configuration.data.classification_internal_template
		observation = observation.ask(prompt=prompt, template=template)

		if not (observation.classification and observation.summary):

			logger.warning(f'ðŸ«± classifier did not give a classification and summary. Skippingâ€¦ ({observation.response=})')
			return item.classification, None

		classification: str = None
		summary: str = cls.get_updated_summary(summary=observation.summary)

		if observation.classification.is_security:
			classification = ExternalItem.CLASSIFICATION_SECURITY

		elif observation.classification.is_enhancement:
			classification = ExternalItem.CLASSIFICATION_ENHANCEMENT

		elif observation.classification.is_other_bug:
			classification = ExternalItem.CLASSIFICATION_SERIOUS_BUG

		elif observation.classification.is_usability:
			classification = ExternalItem.CLASSIFICATION_UI_USABIILITY

		elif observation.classification.is_crash_hang_data_loss:
			classification = ExternalItem.CLASSIFICATION_CHD

		elif observation.classification.is_task:
			classification = ExternalItem.CLASSIFICATION_TASK

		else:

			classification = item.classification
			logger.warning(f'unknown classification ({classification}, {observation.response=})')

		return classification, summary

	@classmethod
	def get_component_for_item(cls, item: ExternalItem, title: str, description: str,
							   classification: str = None, configuration: Configuration = DEFAULT_CONFIGURATION,
							   skipped_search_terms: set[str] = set()) -> tuple[Component, str, str]:
		"""
		Asks AI to find the radar component for a given radar item

		@param item(Item): an unscreened radar
		@param title(str): the cleaned-up version of the title
		@param description(str): the cleaned-up version of the description
		"""

		if not classification:
			classification = item.classification

		display_classification: str = cls.get_display_classification(classification=classification)

		search_terms: list[str] = []
		prompt: dict = {'title': re.sub(r'|'.join(skipped_search_terms), '', title, flags=re.IGNORECASE | re.MULTILINE),
						'description': re.sub(r'|'.join(skipped_search_terms), '', description, flags=re.IGNORECASE | re.MULTILINE),
						'display_classification': display_classification}

		# ask AI
		observation: Observation = AI.ask(prompt=prompt, template=configuration.data.component_template,
															validator=lambda observation: cls.get_response_status(
																observation=observation, item=item, prompt=prompt,
																skipped_search_terms=skipped_search_terms))
		logger.info(observation.response)

		if not observation.component_name:

			logger.warning('â¤µï¸ No component name. Skippingâ€¦')
			return None, None, None

		# if the component name is too broad (e.g. Sandbox), try asking again
		if observation.component_name.raw.lower() in cls.BROAD_ENUM_OPTIONS:

			logger.info('ðŸœï¸ Component is too broad. Trying againâ€¦')

			# remove the component name from the title/description
			_prompt: dict[str, Any] = {**prompt,
									   **{'title': re.sub(observation.component_name.raw, '', prompt['title'], flags=re.IGNORECASE),
										  'description': re.sub(observation.component_name.raw, '', prompt['description'], flags=re.IGNORECASE | re.MULTILINE)}}

			_observation: Observation = AI.ask(prompt=_prompt, template=configuration.data.component_template,
																 validator=lambda observation: cls.get_response_status(
																	observation=observation, item=item, prompt=_prompt,
																	skipped_search_terms=skipped_search_terms))

			if _observation.component_name and _observation.component_name != observation.component_name:

				logger.info(f'ðŸœï¸ Added a less broad component ({_observation.component_name.raw})')
				search_terms.append(_observation.component_name.raw)

		# if the component name is multiple words, get another observation, but instead of the report
		# title + description, use the component name to extract the actual component
		if not cls.get_is_search_term_valid(search_term=observation.component_name.raw):

			logger.debug(f'â¤µï¸ Asking Mini-helper because component is likely not valid ({observation.component_name.raw})â€¦')

			mini_helper_observation: Observation = AI.ask(prompt=prompt, template=MINI_HELPER_TEMPLATE, max_iterations=5)

			if mini_helper_observation.component_name:

				# if the component/product name is still too long, skip
				if mini_helper_observation.component_name == observation.component_name:

					logger.debug('â¤µï¸ Mini-helper gave the same invalid component. Asking ðŸ”§ extractorâ€¦')

					extractor_observation: Observation = AI.ask(prompt={'component_name': observation.component_name.raw,
																		'display_classification': display_classification},
																template=EXTRACTOR_TEMPLATE)

					if not extractor_observation.component_name:

						logger.debug('ðŸ”§ Extractor gave no component name. Skippingâ€¦')
						return None, None, None

					if extractor_observation.component_name == mini_helper_observation.component_name:

						logger.debug('ðŸ”§ Extractor gave the same invalid component. Skippingâ€¦')
						return None, None, None

					logger.debug(f'ðŸ”§ Response: {extractor_observation.response}')

					mini_helper_observation.component_name = extractor_observation.component_name

				# manually update the first observation's `component_name`
				observation.component_name = mini_helper_observation.component_name

			else:
				logger.debug('â¤µï¸ Mini-helper gave no component name. Continuingâ€¦')

		# ask another AI to verify that the component is accurate
		logger.debug(f'ðŸ‘€ Verifying with helperâ€¦ ({observation.component_name.raw})')

		helper_observation: Observation = AI.ask(prompt={**prompt, **{'display_classification': display_classification}},
																   template=INITIAL_TEMPLATE)
		helper_observation = helper_observation.ask(prompt={'component_name': observation.component_name.raw, 'display_classification': display_classification},
													template=VERIFY_COMPONENT_TEMPLATE,
													validator=lambda observation: cls.get_response_status(observation=observation, item=item, name='verify_component'))

		logger.info(helper_observation.response)

		logger.debug(f'2ï¸âƒ£ Fits component: {helper_observation.fits_component}')
		logger.debug(f'2ï¸âƒ£ Radar component: {helper_observation.component_name.raw if helper_observation.component_name else None}')
		logger.debug(f'1ï¸âƒ£ {observation.component_name.raw} 2ï¸âƒ£ {helper_observation.component_name.raw if helper_observation.component_name else None}')

		if helper_observation.fits_component:

			# happens when helper says the component fits, but still suggests another component
			if helper_observation.component_name and observation.component_name != helper_observation.component_name:
				logger.debug(f'ðŸ’­ 1st radar component: {observation.component_name.raw}, helper radar component: {helper_observation.component_name.raw}')

				component_names: list[str] = [observation.component_name.raw, helper_observation.component_name.raw]
				picker_observation: Observation = AI.ask(prompt={**prompt, **{'component_names': ', '.join(component_names)}},
																		   template=COMPONENT_PICKER_TEMPLATE)

				# no 'Thought' currently because it seems to lower the quality of results
				logger.debug(f'3ï¸âƒ£ Best component: {picker_observation.best_component_name}')

				if picker_observation.best_component_name:
					search_terms.append(picker_observation.best_component_name.raw)

				search_terms.append(observation.component_name.raw)
				search_terms.append(helper_observation.component_name.raw)

			else:
				search_terms.append(observation.component_name.raw)

		else:

			if not helper_observation.component_name:

				logger.debug(f'ðŸ’­ helper said component doesnt fit but didnt give alternative. using {observation.component_name}â€¦')
				search_terms.append(observation.component_name.raw)

			else:

				# TODO: I'm not sure what the logic here is for sorting components, but it works as expected
				if cls.get_is_search_term_valid(search_term=helper_observation.component_name.raw):

					search_terms.append(observation.component_name.raw)
					search_terms.append(helper_observation.component_name.raw)

				else:
					search_terms.append(helper_observation.component_name.raw)

					# add the first component anyways (e.g. rdar://108914849)
					search_terms.append(observation.component_name.raw)

		# remove duplicates while preserving order
		search_terms = list(dict.fromkeys(search_terms))

		for index, search_term in enumerate(search_terms[:]):

			# if the component name references an invalid enum option, remove that part and keep the rest
			# e.g. `Passkey vulnerability` -> `Passkey`
			#      `iOS QR Scanner` -> `QR Scanner`
			# e.g. `iPhone` -> None
			# sort by length to account for strings that are part of other strings (e.g. Mac and macOS)
			_search_term: str = Utilities.remove_words_in_text(words=sorted(list(cls.get_invalid_enum_options()), key=len, reverse=True), text=search_term).strip()
			_search_term = Utilities.remove_words_in_text(words={f'*{platform_name}*' for platform_name in Templates.PLATFORM_NAMES}, text=_search_term).strip()
			_search_term = Utilities.remove_words_in_text(words={'* feature', '* app', '* logic', '* functionality', '* function', 'bug in *', '* bypass',
															  '* for', '* on', '* in', 'the *'}, text=_search_term).strip()

			if search_term != _search_term:
				logger.info(f'Renamed search query ({search_term} â†’ {_search_term})')

			# this happens if the name was just `Apple Watch`
			if not _search_term:

				del search_terms[index]
				continue

			search_terms[search_terms.index(search_term)] = _search_term
			_search_query_lower: str = _search_term.lower()

			# e.g. `App Store Agent` -> `appstoreagent`
			if _search_query_lower.endswith(' agent'):
				search_terms.append(_search_query_lower.replace(' ', ''))

		# remove invalid components
		_search_terms: list[str] = [search_term for search_term in search_terms if search_term and  \
																				   search_term not in skipped_search_terms and  \
																				   cls.get_is_search_term_valid(search_term=search_term)]
		if not _search_terms:

			# if after removing invalid search terms, we don't have any, try again but without
			# the search terms we tried
			if not skipped_search_terms:

				logger.warning(f'â˜¹ï¸ No search terms to look up. Trying againâ€¦ ({search_terms})')
				return cls.get_component_for_item(item=item, title=title, description=description, classification=classification,
												  skipped_search_terms=search_terms)

			else:

				logger.warning(f'â˜¹ï¸ No search terms to look up. Not trying again')
				return None, None, None

		search_terms = _search_terms

		# sort the components
		# 1. rdar://109153751 (1ï¸âƒ£ Shared memory buffer 2ï¸âƒ£ AppleNeuralEngine) -> AppleNeuralEngine
		search_terms = sorted(search_terms, key=lambda string: sum(1 for character in string if character.isupper()), reverse=True)

		# 2. rdar://109108178 (1ï¸âƒ£ PKG Installation LPE 2ï¸âƒ£ appstoreagent) -> appstoreagent
		#    rdar://113350711 (1ï¸âƒ£ Screen Recording feature 2ï¸âƒ£ replayd)   -> replayd
		search_terms = sorted(search_terms, key=lambda string: cls.get_is_daemon_or_tool(name=string), reverse=True)

		# 3. rdar://109724767 (1ï¸âƒ£ TCC permissions 2ï¸âƒ£ Astronomy) -> Astronomy
		search_terms = sorted(search_terms, key=lambda string: string.isupper() and len(string) == 3)

		logger.info(f'ðŸ¥³: {search_terms}')

		component: Component = None
		actual_search_term: str = None
		should_lookup_platform: bool = True

		# first, check if the component is something we have Knowledge for
		if configuration.data.knowledge_source_ids:

			knowledges: list[Knowledge] = Knowledge.search(query=search_term,
														   knowledge_source_ids=configuration.data.knowledge_source_ids, limit=5, min_score=0.4)

			if not knowledges:

				knowledges = Knowledge.search(query=title,
											  knowledge_source_ids=configuration.data.knowledge_source_ids, limit=5, min_score=0.2)

			if knowledges:

				observation: Observation = AI.ask(prompt={'title': title, 'description': description,
														  'knowledges': knowledges}, template=COMPONENT_KNOWLEDGE_TEMPLATE)
				if observation.component_name:

					_component_name: str = observation.component_name.split('|')[0].strip()
					_component_version: str = observation.component_name.split('|')[-1].strip()

					components: list[Component] = []

					if len(_component_name) < 30 and len(_component_version) < 30:
						components = RadarClient.shared.get_components_by_name(name=_component_name, version=_component_version)

					if components:

						component = components[0]
						should_lookup_platform = False
						logger.info('found matching component from learned knowledge')

					else:
						logger.warning(f'found component from knowledge but the name is incorrect ({observation.component_name}). continuingâ€¦')

		if not component:

			for search_term in search_terms:

				if search_term.lower() in cls.BROAD_ENUM_OPTIONS:
					continue

				# find the component in radar
				components, actual_search_term = cls.get_components_by_name(name=search_term, classification=classification,
																			include_title=False)

				if not components:

					logger.warning(f'â€¼ï¸ No components found for {search_term}')
					continue

				# sort components by "New Bugs"/All
				components = cls.sort_components(components=components, search_term=search_term)

				# get the first match
				component = components[0]
				break

		if not component:

			for search_term in search_terms:

				# find the component in radar
				components, actual_search_term = cls.get_components_by_name(name=search_term, classification=classification,
																			include_title=True)

				if not components:

					logger.warning(f'â€¼ï¸ no components found for {search_term}')
					continue

				# sort components by "New Bugs"/All
				components = cls.sort_components(components=components, search_term=search_term)

				# get the first match
				component = components[0]
				break

		# if no component matched, try again
		if not component:

			logger.info(f'-> trying again with skipped namesâ€¦ ({search_terms=})')
			return cls.get_component_for_item(item=item, title=title, description=description, classification=classification,
											  skipped_search_terms=search_terms)

		if should_lookup_platform and component:
			component = cls.get_platform_specific_component(item=item, component=component, components=components)

		# if not skipped_search_terms:

		# 	# check if this component has similar radars. we use this as a way to double-check
		# 	# that the component is actually the right one
		# 	# e.g. if the radar is about "Shortcuts" and the component is "Shortcut (Help Menu)"
		# 	logger.info(f'checking if component has similar itemsâ€¦ ({component=}, {item=})')
		# 	similar_items = cls.get_similar_items_for_item(item=item, component=component, classification=classification,
		# 												   include_other_components=False)

		# 	logger.info(f'similar items: {[similar_item for similar_item in similar_items if similar_item.score <= 0.4]}')

		# 	# the distance is arbitrary. high enough for similar items, but not too high
		# 	if len([similar_item for similar_item in similar_items if similar_item.score <= 0.3]) <= 1:
		# 		logger.info(f'-> trying againâ€¦ no similar items for component. ({component=}, {item=})')

		# 		_component, _thought, _actual_search_term = AIScreener.get_component_for_item(item=item, title=title, description=description,
		# 																				   	  skipped_search_terms=search_terms + [actual_search_term])

		# 		if _component:
		# 			component, thought, actual_search_term = _component, _thought, _actual_search_term

		thought: str = f'Looked up {", ".join(search_terms)}'
		return component, thought, actual_search_term

	@classmethod
	def get_subcomponent_for_item(cls, item: ExternalItem, component: Component = None, classification: str = None,
								  required_search_term: str = None, configuration: Configuration = DEFAULT_CONFIGURATION) -> tuple[Component, str]:
		"""
		Asks AI to find the subcomponent for a given radar item

		@param item(Item): an unscreened radar
		@param title(str): the cleaned-up version of the title
		@param description(str): the cleaned-up version of the description
		@param required_search_term(str): a term to include when searching for similar radars
		"""

		if component is None:
			component = item.component

		if classification is None:
			classification = item.classification

		# find similar items first in the same component
		similar_items = cls.get_similar_items_for_item(item=item, component=component, classification=classification,
													   required_search_term=required_search_term)

		for similar_item in similar_items[:]:

			# skip New Bugs components
			is_new_bugs: bool = len(re.findall(cls.NEW_BUGS_PATTERN, f'{similar_item.component.name} {similar_item.component.version}', flags=re.IGNORECASE)) > 0

			# if has_new_bugs:
			# 	similar_items.remove(similar_item)

			# if is_new_bugs and similar_item.component.name.split()[0] == component.name:
				# similar_items.remove(similar_item)

			# print(similar_item.score, similar_item.component)

		components: list[Component] = [similar_item.component for similar_item in similar_items]

		# e.g. {Accounts | macOS: 157, Accounts | iOS: 96}
		components_count_map: dict[Component, int] = {_component: components.count(_component) for _component in set(components)}
		components_count_map = sorted(components_count_map.items(), key=lambda component_count_map: component_count_map[1], reverse=True)
		logger.info(components_count_map)

		subcomponent: Component = None
		thought: str = None

		# if there's more than one component (which is True is most cases), ask AI to pick the right one
		if len(components_count_map) > 1:

			# replace each component with a version that has the description
			components = RadarClient.shared.components_for_ids(component_ids=[component.id for component in set(components)])

			for index, component_count_map in enumerate(components_count_map):

				_component: Component = next((_component for _component in components if _component.id == component_count_map[0].id), None)

				# should never happen
				if not _component:

					logger.warning(f'could not get description for component ({component_count_map[0]=})')
					continue

				components_count_map[index] = (_component, component_count_map[1])

			components_display: str = ''
			component_descriptions: list[str] = []

			for _component, _ in components_count_map:

				# if the component has no description
				if not _component.description or len(_component.description) <= 5 or len(_component.description.split()) <= 1:
					logger.error(f'"{_component.name} | {_component.version}" has no description. This will likely affect accuracy. Please update the description in the Radar app')

				component_descriptions.append(f'- "{_component.name} {_component.version}": {_component.description}')

			title, description = cls.get_title_description_for_item(item=item, include_attachments=False)

			prompt: dict[str, str] = {

				'title': title,
				'description': description,
				'display_classification': cls.get_display_classification(classification=classification),
			}

			observation: Observation = AI.ask(prompt=prompt, template=INITIAL_TEMPLATE)

			# TODO: arbitrary truncation of component_descriptions because of current context window
			prompt = {**prompt, **{'component_descriptions': '\n'.join(component_descriptions[:20])}}
			observation = observation.ask(prompt=prompt, template=PICK_SUBCOMPONENT_TEMPLATE)

			if not observation.component_name:

				logger.error(f'response did not include subcomponent name. skippingâ€¦ ({item=}, {observation.response=})')
				return None, None

			# look up the component name in the response by using the same format we used in the template above
			subcomponent = next((_component for _component in components if observation.component_name == Enum(f'{_component.name} {_component.version}')), None)
			thought = observation.thought

			if not subcomponent:

				logger.error(f'response has an invalid component. skippingâ€¦ ({item=}, {observation.component_name.raw=})')
				return None, None

		elif components:
			subcomponent = components[0]

		if subcomponent:
			subcomponent = cls.get_platform_specific_component(item=item, component=subcomponent, components=components)

		return subcomponent, thought

	@classmethod
	def get_platform_specific_component(cls, item: ExternalItem, component: Component, components: list[Component]) -> Component:
		"""
		Returns a platform-specific component for a given suggested component

		e.g. if the suggested component has '| macOS' but the radar is 'iOS',
		look up the iOS-equivalent of that component

		@param item(Item): a radar item
		@param component(Component): a suggested component
		"""

		title, description = cls.get_title_description_for_item(item=item, include_attachments=False, include_hw_names=True)

		prompt: dict[str, str] = {

			'title': title,
			'description': description,
		}

		# if the component is platform-specific (e.g. iOS), make sure that the report is iOS-specific too.
		# otherwise, try finding the right component. e.g. rdar://109055122 -> `iMovie-New Bugs | iOS`, `iMovie-New Bugs | macOS`
		# we want the macOS one for that radar
		platform_names: list[str] = Utilities.get_words_in_text(words=Templates.PLATFORM_NAMES, text=f'{component.name} {component.version}', strict=True)

		if not platform_names:
			return component

		platform_name: str = platform_names[0]
		logger.info(f'platform in component name/version ({platform_name=}, {components=})')

		platform_name_observation: Observation = AI.ask(prompt=prompt, template=PLATFORM_NAME_TEMPLATE)

		if platform_name_observation.affected_operating_system:

			affected_operating_system_raw: str = platform_name_observation.affected_operating_system.raw

			# map iPadOS to iOS
			if affected_operating_system_raw == 'iPadOS':
				affected_operating_system_raw = 'iOS'

			logger.info(f'actual platform to choose: {affected_operating_system_raw}')

			# if AI gave us a platform (e.g. macOS) but it doesn't match the one in the component name (e.g. iOS),
			# find the macOS component
			if platform_name != affected_operating_system_raw and affected_operating_system_raw in Templates.PLATFORM_NAMES:

				# find the equivalent component
				# e.g. `PDFKit (iOS)` -> `PDFKit (macOS)`
				if _components := RadarClient.shared.get_components_by_name(name=component.name.replace(platform_name, affected_operating_system_raw),
																		   version=component.version.replace(platform_name, affected_operating_system_raw)):
					component = _components[0]

		return component

	@classmethod
	def get_similar_items_for_item(cls, item: ExternalItem, component: Component = None, classification: str = None,
								   exclude_closed: bool = False, include_fixed_only: bool = False,
								   include_other_components: bool = True, required_search_term: str = None) -> list[SimilarItem]:
		"""
		Asks AI to find similar radars to a given radar item
		"""

		if not component:
			component = item.component

		if not classification:
			classification = item.classification

		title, description = cls.get_title_description_for_item(item=item, include_attachments=False)
		prompt: dict[str, str] = {'title': title, 'description': description}

		# TODO:
		# - generate multiple versions of the title, then use embeddings to find the closest
		# - ask AI, is the radar the same, or would the fix be the same (e.g. rdar://116409766 and rdar://85599463)
		# - see what action was taken with the duplicate. e.g. if it's not security
		# - if not exact, but similar and recent, mention it in the comment (e.g. rdar://116352270 and rdar://110268620)
		# - don't look for radars created after (avoid forward-duping). only do so if the dupe-to radar is SW changed
		observation: Observation = AI.ask(prompt=prompt, template=EXTRACT_RELEVANT_TERMINOLOGY_TEMPLATE)
		search_terms: set[str] = set(observation.options or [])

		if not search_terms:

			logger.error(f'could not get search terms ({item=})')
			return None, None

		keywords: set[str] = cls.get_invalid_enum_options()
		keywords = keywords.union({f'*{device_name}*' for device_name in Templates.DEVICE_NAMES})
		keywords = keywords.union({attachment.fileName.lower() for attachment in item.attachments})
		keywords = keywords.union({f'*{platform_name}*' for platform_name in Templates.PLATFORM_NAMES})

		for search_term in search_terms.copy():

			_search_term: str = cls.remove_builds(text=search_term).strip()
			_search_term = Utilities.remove_words_in_text(words=keywords, text=search_term).strip()

			if search_term != _search_term:
				search_terms.remove(search_term)

		search_terms = set(' '.join(search_terms).split(' '))

		for search_term in search_terms.copy():

			# skip if it's just a version number (e.g. 17.0)
			# exclude terms that are just `apple` or the component name itself
			# e.g. `component.name = Siri Contacts`. Don't look up radars with `Siri` in them because we're already looking inside all of the `Siri*` components
			if search_term.lower() in {'apple', component.name.split()[0].lower()} or search_term.startswith('0x') or len(search_term) <= 3:
				search_terms.remove(search_term)

		search_terms = {re.sub(r'\(|\)|\'s|\.|^"|,|"$|`', '', search_term) for search_term in search_terms}
		search_terms_expected_count: int = int(len(search_terms) * (30 / 100))

		logger.info(f'search terms: {search_terms}')

		def _get_external_items(classifications: list[str]) -> list[ExternalItem]:
			"""
			"""

			nonlocal item
			nonlocal component
			nonlocal search_terms

			criteria: dict[str, Any] = {

				'all': [

					# e.g. if the suggested component is `Siri Contacts | New Bugs`, look up all radars in components that start with `Siri` (just `Siri`)
					# e.g. `Notifications (iOS) | New Bugs` -> `Notifications`, which will also match `UserNotificationsUI`
					{'classification': {'any': classifications}},
					{'allText': {'none': [{'phrase': {'term': 'Reason for clone:'}}]}},
					{'id': {'neq': item.raw_id}},
					{'any': [
						{'state': {'neq': 'Closed'}},
						{'resolvedAt': {'gte': (item.created_at - timedelta(days=100)).isoformat()}},
					]},

				] + [
					{'any': [
						{'any': [
							{'title': {'like': f'%{search_term}%'}},
							{'description': {'phrase': {'term': search_term, 'distance': 2}}}
						]} for search_term in search_terms]
				}],
				'orderBy': [{'field': 'id', 'order': 'descending'}],
			}

			# only closed radars
			# if exclude_closed:
			# 	criteria['all'].append({'state': {'neq': 'Closed'}})

			if include_other_components:
				criteria['all'].append({'component': {'eq': {'name' : {'like' : f'%{component.name.split()[0].split("-")[0]}%'}}}})

			else:
				criteria['all'].append({'componentId': component.id})

			if required_search_term:
				criteria['all'].append({'any': [{'title': {'like': f'%{required_search_term}%'}}, {'description': {'phrase': {'term': required_search_term}}}]})

			# only fixed radars
			if include_fixed_only:
				criteria['all'].append({'resolution': {'any': ExternalItem.RESOLUTIONS_FIXED}})

			external_items: list[ExternalItem] = RadarClient.shared.get_items_for_criteria(criteria=criteria, additional_fields=['title', 'resolvedBy'], limit=600,
																						   return_find_results_directly=True)

			# get items that have at least 3 search terms in the title/description
			for external_item in external_items[:]:

				title_description: str = f'{external_item.display_title}{external_item.first_description_display_text}'
				title_description_lower: str = title_description.lower()

				if sum([1 for search_term in search_terms if search_term.lower() in title_description_lower]) < search_terms_expected_count:
					external_items.remove(external_item)

			return external_items

		external_items: list[ExternalItem] = _get_external_items(classifications=[classification])

		if not external_items or len(external_items) <= 20:

			logger.info(f'not enough matches ({len(external_items)}). trying again with more classificationsâ€¦')

			classifications: list[str] = []

			if classification in {ExternalItem.CLASSIFICATION_SECURITY, ExternalItem.CLASSIFICATION_CHD,
								  ExternalItem.CLASSIFICATION_UI_USABIILITY, ExternalItem.CLASSIFICATION_SERIOUS_BUG, ExternalItem.CLASSIFICATION_OTHER_BUG}:

				classifications += [ExternalItem.CLASSIFICATION_SECURITY, ExternalItem.CLASSIFICATION_CHD,
									ExternalItem.CLASSIFICATION_UI_USABIILITY, ExternalItem.CLASSIFICATION_SERIOUS_BUG, ExternalItem.CLASSIFICATION_OTHER_BUG]

			elif classification in {ExternalItem.CLASSIFICATION_ENHANCEMENT, ExternalItem.CLASSIFICATION_FEATURE,
									ExternalItem.CLASSIFICATION_TASK}:

				classifications += [ExternalItem.CLASSIFICATION_ENHANCEMENT, ExternalItem.CLASSIFICATION_FEATURE,
									ExternalItem.CLASSIFICATION_UI_USABIILITY]

			external_items += _get_external_items(classifications=classifications)

		external_items = set(external_items)

		similar_items: list[SimilarItem] = []
		item_embedding: list[float] = cls.get_embedding_for_item(item=item)

		logger.info(f'getting embedding for {len(external_items)} similar itemsâ€¦')

		for external_item in external_items:

			# if external_item.external_id not in all_knowledge_source_ids:
			# 	cls.learn_from_item(item=external_item)

			distance: float = Utilities.get_cosine_distance(embedding_1=item_embedding, embedding_2=cls.get_embedding_for_item(item=external_item))
			similar_item: SimilarItem = SimilarItem(external_id=external_item.external_id, title=external_item.display_title,
													score=distance, duplicate_id=external_item.duplicate_id,
													item=external_item.item)
			similar_items.append(similar_item)

		# sort, so smallest distance is first
		similar_items = sorted(similar_items, key=lambda similar_item: similar_item.score)
		return similar_items

	@classmethod
	def get_duplicate_item_for_item(cls, item: ExternalItem, component: Component = None, classification: str = None,
									configuration: Configuration = DEFAULT_CONFIGURATION) -> tuple[SimilarItem, str]:
		"""
		Asks AI to find a duplicate radar for a given radar item
		"""

		similar_items: list[Similar] = cls.get_similar_items_for_item(item=item, component=component, classification=classification,
																	  exclude_closed=True)

		_similar_items = [similar_item for similar_item in similar_items if similar_item.score <= 0.5]

		if not _similar_items:

			logger.info('no matches under 0.5, trying againâ€¦')
			_similar_items = [similar_item for similar_item in similar_items if similar_item.score <= 0.7]

		# if any items have the highest score, return that item early
		if similar_item := next((similar_item for similar_item in similar_items if similar_item.score < 0.01), None):

			reasoning: str = 'They are very similar'

			# if the item is a duplicate, use the dupe of
			if similar_item.duplicate_id:

				# get the title of the dupe of (if we have access)
				try:

					similar_item = similar_item.duplicate_item
					similar_item = SimilarItem(external_id=similar_item.external_id, title=similar_item.title, type=ExternalItem.TYPE_RADAR)

				except:
					similar_item = SimilarItem(external_id=f'rdar://{similar_item.duplicate_id}', type=ExternalItem.TYPE_RADAR)

				return similar_item, reasoning

			return similar_item, reasoning

		# ask AI to analyze the radar, then ask if the items below are the same
		if not similar_items:
			return None, None

		conditional_statements: str = ''
		display_classification: str = cls.get_display_classification(classification=classification)

		if classification in {ExternalItem.CLASSIFICATION_CHD, ExternalItem.CLASSIFICATION_UI_USABIILITY,
							  ExternalItem.CLASSIFICATION_SERIOUS_BUG, ExternalItem.CLASSIFICATION_OTHER_BUG,
							  ExternalItem.CLASSIFICATION_PERFORMANCE, ExternalItem.CLASSIFICATION_SECURITY}:
			conditional_statements = 'Only dupe if they\'re truly the same issue. Also compare any prerequisites/steps to reproduce. If it\'s a crash, focus solely on the crash signature.'

		elif classification in {ExternalItem.CLASSIFICATION_ENHANCEMENT, ExternalItem.CLASSIFICATION_FEATURE}:
			conditional_statements = 'Only dupe if they\'re truly the same request. They are dupes if the high-level description is about the same thing. It is ok if not all details match.'

		title, description = cls.get_title_description_for_item(item=item, include_attachments=False)
		prompt: dict[str, str] = {'title': title, 'description': description}

		observation: Observation = AI.ask(prompt={**prompt, **{'display_classification': display_classification}},
															template=INITIAL_TEMPLATE)

		# TODO: all 0.0* + 3
		for similar_item in similar_items[:5]:

			logger.info(f'\033[93m {similar_item.score}, {similar_item.external_id}, {similar_item.title}')

			title, description = cls.get_title_description_for_item(item=similar_item, include_attachments=False)

			_observation: Observation = observation.ask(prompt={'title': title, 'description': description,
																'display_classification': display_classification,
																'conditional_statements': conditional_statements},
														template=configuration.data.verify_duplicate_template)

			if not isinstance(_observation.duplicate, bool):
				logger.error(f'{type(_observation.duplicate)}, {_observation.response}')

			elif _observation.duplicate:

				# if the item is a duplicate, use the dupe of
				if similar_item.duplicate_id:

					# get the title of the dupe of (if we have access)
					try:

						similar_item = similar_item.duplicate_item
						similar_item = SimilarItem(external_id=similar_item.external_id, title=similar_item.title, type=ExternalItem.TYPE_RADAR)

					except:
						similar_item = SimilarItem(external_id=f'rdar://{similar_item.duplicate_id}', type=ExternalItem.TYPE_RADAR)

					return similar_item, _observation.reasoning

				return similar_item, _observation.reasoning

			else:
				logger.warning(_observation.response)

		return None, None

	@classmethod
	def get_assignee_for_item(cls, item: ExternalItem, component: Component, items_count: int = 1,
							  person_items_map: dict[int, set] = None, configuration: Configuration = DEFAULT_CONFIGURATION) -> tuple[Person, str]:
		"""
		Finds the best person to assign a given radar item to
		"""

		if not person_items_map:
			person_items_map = defaultdict(set)

		def _get_can_assign_person(person: Person, percentage_increment: float = None) -> bool:
			"""
			Returns whether an item can be assigned to a given person
			"""

			nonlocal item
			nonlocal items_count
			nonlocal configuration
			nonlocal person_items_map

			person_items: set = person_items_map.get(person, set())

			# e.g. 8%
			percentage: float = configuration.data.assignment_percentages.get(person.dsid)

			if percentage == 0:
				return False

			if not percentage:
				percentage = (items_count / len(person_items_map)) * 100

			percentage = float(percentage)

			if percentage_increment:
				percentage += percentage_increment

			# e.g. Jane's percentage is 10%, `items_count = 15`
			# 10% of 15 = math.ceil(1.5) -> 2
			# 2 - 1 (the number of items that've already been assigned to Jane) = 1
			assignable_items_count: int = ((percentage / 100) * items_count) - len(person_items)
			assignable_items_count = math.ceil(assignable_items_count)

			return assignable_items_count > 0

		# assign a person
		assignee_person, thought = None, None

		# check if the component is being DRI's by another person
		if person_items_map:

			# if this radar is similar to a radar someone else's is DRI'ing
			person = next((person for person, items in person_items_map.items() if any(Utilities.get_cosine_distance(embedding_1=item.embedding, embedding_2=_item.embedding) <= 0.3 for _item in items)), None)

			if person:
				logger.info(f'picked {person} for {item=}')

			assignee_person = person
			thought = f'This radar is similar to other ones in the queue'

		# get the suggested classification
		classification: str = item.classification
		classification_suggestion: Suggestion = Suggestion.get_or_none(item_external_id=item.external_id, name='classification', configuration_id=configuration.id)

		if classification_suggestion:
			classification = classification_suggestion.value

		similar_items: list[SimilarItem] = cls.get_similar_items_for_item(item=item, component=component,
																		  classification=classification, include_fixed_only=True)

		# e.g. {Person: [rdar://, rdar://, â€¦]}
		person_similar_items_map: dict[Person, list] = defaultdict(list)

		for similar_item in similar_items:

			if similar_item.score <= 0.5:
				person_similar_items_map[similar_item.resolved_by].append(similar_item)

		# if not items, try with more distance
		if not person_similar_items_map:

			for similar_item in similar_items:

				if similar_item.score <= 1 and similar_item not in person_similar_items_map[similar_item.resolved_by]:
					person_similar_items_map[similar_item.resolved_by].append(similar_item)

		if person_similar_items_map:

			persons: list[Person] = list(person_similar_items_map.keys())

			# filter based on group (if specified)
			if configuration.data.assignments_person_dsids:
				persons = [person for person in persons if person.dsid in configuration.data.assignments_person_dsids]

			# exclude persons that are bots
			persons = [person for person in persons if person and person.is_bot]

			if persons:

				assignee_person = random.choice(persons)
				thought = f'Was assigned similar radars before ({ExternalItem.get_url_for_external_items(external_items=person_similar_items_map[assignee_person][:3])})'

			else:
				logger.error(f'could not find a person to assign this radar to ({item=})')

		return assignee_person, thought

	@classmethod
	def get_security_dri_for_item(cls, item: ExternalItem, component: Component, items_count: int = 1,
								  person_items_map: dict[Person, set] = None, configuration: Configuration = DEFAULT_CONFIGURATION) -> tuple[Person, str]:
		"""
		Finds the best Security DRI to assign a given radar item to
		"""

		if not person_items_map:
			person_items_map = defaultdict(set)

		def _get_can_assign_person(person: Person, percentage_increment: float = None) -> bool:
			"""
			Returns whether an item can be assigned to a given person
			"""

			nonlocal item
			nonlocal items_count
			nonlocal person_items_map

			person_items: set = person_items_map.get(person, set())

			# e.g. 8%
			percentage: float = configuration.data.assignment_percentages.get(person.dsid)

			if percentage == 0:
				return False

			if not percentage:
				percentage = (items_count / len(person_items_map)) * 100

			percentage = float(percentage)

			if percentage_increment:
				percentage += percentage_increment

			# e.g. Jane's percentage is 10%, `items_count = 15`
			# 10% of 15 = math.ceil(1.5) -> 2
			# 2 - 1 (the number of items that've already been assigned to Jane) = 1
			assignable_items_count: int = ((percentage / 100) * items_count) - len(person_items)
			assignable_items_count = math.ceil(assignable_items_count)

			return assignable_items_count > 0

		def _get_next_assignable_person(persons: list[Person], retry_count: int = 0) -> Person:

			nonlocal items_count
			nonlocal person_items_map
			_persons: list[Person] = persons[:]

			while _persons:

				random.shuffle(_persons)
				_persons.sort(key=lambda person: len(person_items_map[person]))

				person: Person = _persons[0]

				if _get_can_assign_person(person=person, percentage_increment=retry_count + 1):
					return person

				else:
					_persons.remove(person)

			if persons and retry_count < 3:

				logger.info(f'retryingâ€¦ ({retry_count=}, {[person.name for person in persons]})')
				return _get_next_assignable_person(persons=persons, retry_count=retry_count + 1)

			return None

		# set a Security DRI
		thought: str = None
		now: datetime = datetime.now()
		security_dri_person: Person = None
		year_ago: datetime = now - timedelta(days=365)

		# check if the component is being DRI's by another person
		if person_items_map:

			logger.info('trying similar radarsâ€¦')

			# if this radar is similar to a radar someone else's is DRI'ing
			person = next((person for person, items in person_items_map.items() if any(Utilities.get_cosine_distance(embedding_1=item.embedding, embedding_2=_item.embedding) <= 0.4 for _item in items)), None)

			if person and _get_can_assign_person(person=person, percentage_increment=50):

				security_dri_person = person
				thought = f'Similar to other radars'

			if not security_dri_person:

				logger.info('trying same suggested componentsâ€¦')
				should_assign_before: bool = configuration.data.assignments_order == AssignmentOrder.before

				for person, items in person_items_map.items():

					# if the component is the same as another item in the list, pick
					# the DRI that got it and assign it to them
					if any(component.id == (_item.component_id if should_assign_before else _item.suggested_component_id) for _item in items):

						if _get_can_assign_person(person=person):

							security_dri_person = person
							thought = f'DRI of radars in the same component'
							break

		if not security_dri_person:

			logger.info('trying recent DRIsâ€¦')

			# look up radars in the same component with a Security DRI set
			# skip duplicates because they might have the wrong Security DRI
			# ordering by ID is important for most recent results
			criteria: dict[str, Any] = {

				'all': [{'componentId': component.id, 'productSecurity': {'eq': {'securityDRI': {'neq': None}}}, 'resolution': {'neq': 'Duplicate'}}],
				'orderBy': [{'field': 'id', 'order': 'descending'}],
			}
			external_items: list[ExternalItem] = RadarClient.shared.get_items_for_criteria(criteria=criteria, additional_fields=['productSecurity'], limit=50,
																						   return_find_results_directly=True)

			# get DRI's from this past year
			# security_dri check is due to rdar://117228681
			external_items_subset: list[ExternalItem] = [external_item for external_item in external_items if external_item.security_dri and external_item.created_at.replace(tzinfo=None) >= year_ago and external_item.security_dri]

			# TODO: check OOO
			persons: list[Person] = [external_item.security_dri for external_item in external_items_subset if external_item.security_dri]

			if configuration.data.assignments_person_dsids:
				persons = [person for person in persons if person.dsid in configuration.data.assignments_person_dsids]

			# TODO: sort by who DRI'd them most recently and amount of radars?
			if persons and (security_dri_person := _get_next_assignable_person(persons=persons)):

				security_dri_external_items: list[ExternalItem] = [external_item for external_item in external_items_subset if external_item.security_dri.dsid == security_dri_person.dsid]
				thought = f'Recently DRIâ€™d {len(security_dri_external_items)} {component.name} radars ({ExternalItem.get_url_for_external_items(external_items=security_dri_external_items)})'

			# if no DRIs from the past year, try the entire list
			if not security_dri_person:

				logger.info('trying all previous DRIsâ€¦')

				# TODO: check OOO
				persons: list[Person] = [external_item.security_dri for external_item in external_items if external_item.security_dri]

				if configuration.data.assignments_person_dsids:
					persons = [person for person in persons if person.dsid in configuration.data.assignments_person_dsids]

				if persons and (security_dri_person := _get_next_assignable_person(persons=persons)):

					security_dri_external_items: list[ExternalItem] = [external_item for external_item in external_items if external_item.security_dri and external_item.security_dri.dsid == security_dri_person.dsid]
					thought = f'DRIâ€™d {len(security_dri_external_items)} {component.name} radars a while ago ({ExternalItem.get_url_for_external_items(external_items=security_dri_external_items)})'

		# if no DRIs, try first word in the component name
		# e.g. `Siri NLX Runtime` -> `Siri`
		if not security_dri_person and len(component.name.split()) > 1:

			component_name_first_chunk: str = component.name.split()[0]
			logger.info(f'trying first chunk of component nameâ€¦ ({component_name_first_chunk=})')

			criteria: dict[str, Any] = {

				'all': [{'component': {'eq': {'name' : {'like' : f'%{component_name_first_chunk} %'}}},
						'productSecurity': {'eq': {'securityDRI': {'neq': None}}}, 'resolution': {'neq': 'Duplicate'}}],
				'orderBy': [{'field': 'id', 'order': 'descending'}],
			}
			external_items: list[ExternalItem] = RadarClient.shared.get_items_for_criteria(criteria=criteria, additional_fields=['productSecurity'], limit=50,
																						   return_find_results_directly=True)

			# get DRI's from this past year
			external_items_subset: list[ExternalItem] = [external_item for external_item in external_items if external_item.security_dri and external_item.created_at.replace(tzinfo=None) >= year_ago and external_item.security_dri]

			# TODO: check OOO
			persons: list[Person] = [external_item.security_dri for external_item in external_items_subset if external_item.security_dri]

			if configuration.data.assignments_person_dsids:
				persons = [person for person in persons if person.dsid in configuration.data.assignments_person_dsids]

			# TODO: sort by who DRI'd them most recently and amount of radars?
			if persons and (security_dri_person := _get_next_assignable_person(persons=persons)):

				security_dri_external_items: list[ExternalItem] = [external_item for external_item in external_items_subset if external_item.security_dri.dsid == security_dri_person.dsid]
				thought = f'Recently DRIâ€™d {len(security_dri_external_items)} {component_name_first_chunk} radars ({ExternalItem.get_url_for_external_items(external_items=security_dri_external_items)})'

		# try based on similar radars (TODO)
		if not security_dri_person:
			logger.info('trying similar radarsâ€¦')

		# if we still don't have a Security DRI, try a random person
		if not security_dri_person:

			# TODO: check OOO
			if configuration.data.assignments_persons:

				logger.info('trying a random personâ€¦')
				persons = configuration.data.assignments_persons

				if persons and (security_dri_person := _get_next_assignable_person(persons=persons)):
					thought = f'Randomly chosen. No one DRIâ€™d {component.name} before'

			else:
				logger.error('could not pick a random person since there\'s no group set')

		if security_dri_person:
			logger.info(f'picked security dri (dsid={security_dri_person.dsid}, external_id={item.external_id})')

		return security_dri_person, thought

	""" Validators """

	@classmethod
	def get_response_status(cls, observation: Observation, item: ExternalItem, name: str = None,
							prompt: dict[str, str] = None, skipped_search_terms: list[str] = None) -> str:
		"""
		Checks if the component is correct

		@param observation(Observation): an observation (passed by `get_response`)
		@param item(Item): a radar
		"""

		component_name: str = observation.component_name

		if name == 'verify_component':

			if not component_name:

				if observation.fits_component:
					return

				return 'Missing radar component in response. Respond with the correct format'
		else:

			# if the component name is not referenced in the prompt, it may be a hallucination
			# only check the very first word since AI's response might have it formatted differently
			# from the item (e.g. in the item, it's `OpticID`, but AI says `Optic ID`, so we only match on `Optic`)
			if (component_name_first_chunk := component_name.raw.split()[0].lower()).removesuffix('s') not in str(prompt).lower():

				error: str = f'"{component_name_first_chunk}" was not mentioned in the report. Try again'

				logger.error(error)
				return error

		# e.g. `xnu/tools/lldbmacros/kevent.py` (rdar://112409226)
		if '/' in component_name and '.' in component_name:
			return 'Not a valid component. Component is a name, not a path or file name. Try again'

		if skipped_search_terms and component_name.raw in skipped_search_terms:
			return 'The vulnerable component is something else. Think step by step then respond in the correct format'

		# hardcoded list since some extensions may be actually helpful (e.g. `TCC.db`)
		# e.g. `.m`, `.py`
		# if '.' in component_name and pathlib.Path(component_name).suffix in {'.m', '.py', '.c', '.cpp'}:
		# 	return f'{component_name.raw} is not a valid component. Try again'

		# e.g. `iOS 17` or `iOS 17 beta`
		# if (platform_name := next((platform_name for platform_name in Templates.PLATFORM_NAMES if component_name.startswith(platform_name.lower())), None)) and  \
		# 	len(component_name.replace(device_name.lower()).split()) < 2::
		# 	# return f'The vulnerable component is not the OS itself ({platform_name}). Try again'
		# 	return 'The vulnerable component is something else. Think step by step then respond in the correct format'

		# e.g. `iPhone` or `MacBook Air password`
		if (device_name := next((device_name for device_name in Templates.DEVICE_NAMES if component_name.startswith(device_name.lower())), None)) and  \
			len(component_name.replace(device_name.lower(), '').split()) < 2:
			# return f'The vulnerable component is not the device itself ({device_name}). Try again'
			return 'The vulnerable component is something else. Think step by step then respond in the correct format'

		# # e.g. `iOS` or `iOS QR Code Scanner`
		# if (platform_name := next((platform_name for platform_name in Templates.PLATFORM_NAMES if component_name.startswith(platform_name.lower())), None)) and  \
		# 	len(component_name.replace(device_name.lower()).split()) < 2::
		# 	return f'The vulnerable component is not the OS itself ({platform_name}). Try again'

		# if any of the words ends with `ing`
		# e.g. `Printing malformed data` (rdar://116001737)
		# TODO: this might lower accuracy rate, if any of the words is a legit component (e.g. `Sharing Services`)
		if any(word for word in component_name.raw.split() if word.endswith('ing')):
			return 'The vulnerable component is something else. Think step by step then respond in the correct format'

	""" Workflows """

	@classmethod
	def assign_items(cls, items: list[ExternalItem], configuration: Configuration,
					 skip_assigned: bool = True, **kwargs) -> dict[Person, list[ExternalItem]]:
		"""
		Distributes and assigns radars to DRIs, and sends a notification with a list of assignments
		"""

		field_name: str = 'assignee' if configuration.data.assignee_behavior else 'security_dri'

		# skip items that already have suggestions
		if skip_assigned:

			items = [item for item in items if Suggestion.select().where(Suggestion.item_external_id == item.external_id, Suggestion.name == field_name,
																		 Suggestion.configuration_id == configuration.id, Suggestion.result.is_(None)).first() is None]

			# skip items that already have a security DRI
			if configuration.data.security_dri_behavior:
				items = [item for item in items if not item.security_dri]

		# filter by items that are assignable
		# then sort by component, so we assign based on components
		if configuration.data.assignments_order == AssignmentOrder.after:

			for item in items:

				component_suggestion: Suggestion = Suggestion.select().where(Suggestion.item_external_id == item.external_id,
																			 Suggestion.name == 'component', Suggestion.configuration_id == configuration.id,
																			 Suggestion.result.is_(None)).first()
				setattr(item, 'suggested_component_id', int(component_suggestion.value) if component_suggestion else item.component.id)

			items = [item for item in items if item.suggested_component_id]
			items.sort(key=lambda item: item.suggested_component_id)

		elif configuration.data.assignments_order == AssignmentOrder.before:

			items = [item for item in items if item.component_id]
			items.sort(key=lambda item: item.component_id)

		else:
			raise Exception(f'unsupported order ({configuration.data.assignments_order})')

		# sort by similar radars
		for item in items:
			setattr(item, 'embedding', cls.get_embedding_for_item(item=item))

		# TODO: is this correct? I think it should measure distance based on previous item, not first one
		items = sorted(items, key=lambda item: Utilities.get_cosine_distance(embedding_1=item.embedding, embedding_2=items[0].embedding), reverse=True)
		items_count: int = len(items)

		# maps radars to assignees/DRIs
		person_items_map: dict[Person, set] = defaultdict(set)

		for item in items:

			component_id: int = item.suggested_component_id if configuration.data.assignments_order == AssignmentOrder.after else item.component_id
			components: list[Component] = RadarClient.shared.components_for_ids(component_ids=[component_id])

			if not components:

				logger.error(component_id)
				continue

			component: Component = components[0]

			logger.section(f'assigning itemâ€¦ ({item.external_id} {item.display_title})')

			person, thought = None, None

			if configuration.data.assignee_behavior is not None:
				person, thought = cls.get_assignee_for_item(item=item, component=component,
															items_count=items_count, person_items_map=person_items_map,
															configuration=configuration)

			elif configuration.data.security_dri_behavior is not None:
				person, thought = cls.get_security_dri_for_item(item=item, component=component,
																items_count=items_count, person_items_map=person_items_map,
																configuration=configuration)
			else:

				logger.warning('neither assignee or security DRI behavior is set')
				return

			if person:

				configuration.add_suggestion(name=field_name, value=person.dsid, display_value=person.name,
											 thought=thought, item=item)

				person_items_map[person].add(item)

			else:
				logger.warning(f'no DRI assigned ({item=})')

		return person_items_map

	""" Helper functions """

	@classmethod
	def get_display_classification(cls, classification: str) -> str:
		"""
		Returns a classification to be used in prompts
		"""

		display_classification: str = 'bug'

		if classification in {ExternalItem.CLASSIFICATION_CHD, ExternalItem.CLASSIFICATION_UI_USABIILITY,
							  ExternalItem.CLASSIFICATION_SERIOUS_BUG, ExternalItem.CLASSIFICATION_OTHER_BUG,
							  ExternalItem.CLASSIFICATION_PERFORMANCE}:
			return 'bug'

		elif classification == ExternalItem.CLASSIFICATION_SECURITY:
			return 'vulnerability'

		elif classification in {ExternalItem.CLASSIFICATION_ENHANCEMENT, ExternalItem.CLASSIFICATION_FEATURE}:
			return 'enhancement request'

		elif classification == ExternalItem.CLASSIFICATION_TASK:
			return 'task'

	@classmethod
	def get_components_by_name(cls, name: str, classification: str = 'Security', include_title: bool = False,
							   knowledge_source_ids: list[int|str] = None) -> tuple[list[Component], str]:
		"""
		Returns a list of Radar for a given component name

		TODO: explore searching for "Over to {name}" in comments, and see where the component was changed to
			- e.g. `AppleIntelKBLGraphics`

		TODO: explore filtering by components we've sent radars to before
		"""

		# clean up the name
		# e.g. `Contacts.app` -> `Contacts`
		name = name.removesuffix('.app').removesuffix('.pkg').removesuffix('.framework').removesuffix('.kext')

		# e.g. `libxml2:â€¦` -> `libxml2`
		if ':' in name:
			name = name.split(':', 1)[0]

		elif '.' in name and (extension := name.rsplit('.', 1)[-1]) and len(extension) <= 3:
			name = f'{name.removesuffix(f".{extension}")} {name}'

		if (components := cls.CACHED_COMPONENTS.get(name)):
			return components, name

		name = name.replace('Wi-Fi', 'WiFi')
		actual_search_term: str = name

		def _get_components_by_name(_name: str) -> list[Component]:
			"""
			Returns a list of Radar components (sorted, and excluding excluded components)
			"""

			components: list[Component] = RadarClient.shared.get_components_by_name(name=_name)

			# prioritize "New Bugs" components
			components = sorted(components, key=lambda component: len(re.findall(cls.NEW_BUGS_PATTERN, f'{component.name} {component.version}', flags=re.IGNORECASE)) > 0 or component.name.split('(')[0].strip() == _name, reverse=True)
			components = [component for component in components if not cls.get_should_exclude_component(component=component, classification=classification)]

			# if the name is a daemon/tool, make sure we don't overmatch (e.g. `name = 'installd', component.name = 'InstallDVDSpringBoard'`)
			if cls.get_is_daemon_or_tool(name=_name):

				logger.info(f'â„¹ï¸ Name is a demon/tool. Skipping components that don\'t matchâ€¦ ({_name=}, {components=})')
				components = [component for component in components if re.findall(fr'\b{_name}\b', f'{component.name} {component.version}', flags=re.IGNORECASE)]

			# if the name is an acronym, only match components that have the same acronym
			# e.g. `name = TCC`, `component = TCC` = True
			# e.g. `name = PAM`, `component = pam_modules` = True
			# e.g. `name = PET`, `component = Petshop` = False
			if _name.isupper() and len(_name) <= 4:

				logger.info(f'â„¹ï¸ Name is an acronym. Skipping components that don\'t matchâ€¦ ({_name=}, {components=})')
				components = [component for component in components if re.findall(fr'(?:\b|-|_)({_name})(?:\b|-|_)', f'{component.name} {component.version}', flags=re.IGNORECASE)]

			return components

		components: list[Component] = _get_components_by_name(_name=name)

		if len(components) <= 0:

			name_split: str = name.split()

			# if no results, and the name is two words, try merging the two
			# e.g. `Lockdown Mode` -> `LockdownMode`
			if len(name_split) > 1:

				merged_name: str = name.replace(' ', '')
				actual_search_term = merged_name

				logger.info(f'Trying one-wordâ€¦ ({merged_name})')
				components = _get_components_by_name(_name=merged_name)

				# still no results? try the first word
				# if not components:
				# 	components = _get_components_by_name(_name=name_split[0])

			# if title case (e.g. `QuickLook`, excluding all uppercase, like `TCC`)
			# split `QuickLook` -> `Quick Look`
			elif len(name_split) == 1 and sum(1 for character in name if character.isupper()) >= 2 and not name.isupper():

				separated_name = re.sub(r'(?<=[a-z])(?=[A-Z])|(?<=[A-Z])(?=[A-Z][a-z])', ' ', name)
				actual_search_term = separated_name

				logger.info(f'Trying two wordsâ€¦ ({separated_name})')
				components = _get_components_by_name(_name=separated_name)

				# e.g. `AppleDockChannelUserClient` -> `Apple Dock Channel User Client` -> `AppleDockChannelUser` ->
				# `AppleDockChannel`
				if not components:

					# e.g. `['Apple', 'Dock', 'Channel', 'User', 'Client']`
					separated_name_split = separated_name.split()

					# `3` is to limit us from matching too many components (e.g. `Apple` or `AppleIntel` for `AppleIntelKBLGraphics`)
					while len(separated_name_split) > 3 and not components:

						separated_name_split.pop()

						separated_name_chunked: str = ''.join(separated_name_split)
						actual_search_term = separated_name_chunked

						logger.info(f'Trying chunked nameâ€¦ ({separated_name_chunked})')
						components = _get_components_by_name(_name=separated_name_chunked)

		if not include_title:
			return components, actual_search_term

		actual_search_term = name

		# try again but with title
		if not components:

			logger.info(f'ðŸ‘€ Trying title for {name}â€¦')

			criteria: dict[str, Any] = {

				# look for similar non-duplicate radars (we look up non-duplicates to avoid backports, which could lower the quality of results)
				# ordering by ID is important for more accurate/recent results
				'all': [{'title': name}, {'classification': classification}, {'resolution': {'neq': 'Duplicate'}}],
				'orderBy': [{'field': 'id', 'order': 'descending'}],
			}
			external_items: list[ExternalItem] = RadarClient.shared.get_items_for_criteria(criteria=criteria, additional_fields=['id'], limit=200,
																						   return_find_results_directly=True)

			# fetch more but this time, split the name into chunks, to give us more accurate data
			# e.g. `iCloud Keychain` -> `['iCloud', 'Keychain']`
			if len(name.split()) > 1:

				criteria: dict[str, Any] = {

					'all': [{'classification': classification}, {'resolution': {'neq': 'Duplicate'}}] + [{'title': {'like': f'%{name_chunk}%'}} for name_chunk in name.split()],
					'orderBy': [{'field': 'id', 'order': 'descending'}],
				}
				_external_items = RadarClient.shared.get_items_for_criteria(criteria=criteria, additional_fields=['id'], limit=200,
																			return_find_results_directly=True)

				for external_item in _external_items[:]:

					if not any(_external_item for _external_item in external_items if _external_item.external_id == external_item.external_id):
						external_items.append(external_item)

			# replace the component from `ExternalItem` with ones that has more fields (`isRestricted` and `isClosed`)
			components_unique: set[Component] = {external_item.component for external_item in external_items}
			components_unique = RadarClient.shared.components_for_ids(component_ids=[component.id for component in components_unique])

			external_items = [external_item for external_item in external_items if not cls.get_should_exclude_component(component=next((component for component in components_unique if component.id == external_item.component.id), external_item.component),
																														classification=classification)]
			component_names: list[str] = [external_item.component.name for external_item in external_items]

			# if there's only one instance of each component (e.g. ['Accessibility Inspector', 'ISG Admin', 'Remote Desktop'] for `auditd`)
			need_more_components: bool = sum([component_names.count(component_name) for component_name in component_names]) == len(component_names)

			# if there are no items or we need more components
			# try again but without specifying classification
			if not component_names or need_more_components:

				if not component_names:
					logger.info('No results. Trying again but without classificationâ€¦')

				elif need_more_components:
					logger.info(f'Not enough components. Trying again but without classificationâ€¦ ({component_names})')

				criteria = {

					'all': [{'title': {'like': f'%{name_chunk}%'}} for name_chunk in name.split()],
					'orderBy': [{'field': 'id', 'order': 'descending'}],
				}
				external_items = RadarClient.shared.get_items_for_criteria(criteria=criteria, additional_fields=['id', 'component'], limit=200,
																		   return_find_results_directly=True)

				# replace the component from `ExternalItem` with ones that has more fields (`isRestricted` and `isClosed`)
				components_unique: set[Component] = {external_item.component for external_item in external_items}
				components_unique = RadarClient.shared.components_for_ids(component_ids=[component.id for component in components_unique])

				external_items = [external_item for external_item in external_items if not cls.get_should_exclude_component(component=next((component for component in components_unique if component.id == external_item.component.id), external_item.component),
																															classification=classification)]
				component_names: list[str] = [external_item.component.name for external_item in external_items]

				# if we still need more components
				# e.g. `['ASE UMC Ingestion', 'TVMLKit', 'AVFoundation']` (rdar://108793390)
				if len(component_names) <= 1:

					external_items = []
					logger.info('âš ï¸ only one component matched. will not try againâ€¦')

				else:

					need_more_components = sum([component_names.count(component_name) for component_name in component_names]) == len(component_names)
					logger.info('âš ï¸ still need more components')

			# TODO: if still no components, and this is a function name, try radar description (e.g. `launch_active_user_switch` rdar://111704576)

			# ensure the external items are actually sorted by ID
			external_items.sort(key=lambda external_item: external_item.external_id, reverse=True)

			# get component names
			components = [external_item.component for external_item in external_items]
			component_names = [component.name for component in components]

			if components:

				top_component_name: str = max(set(component_names), key=component_names.count)
				top_component: Component = next(component for component in components if component.name == top_component_name)

				# sort components, so that the first one is the top component
				components = sorted(components, key=lambda component: component.name != top_component_name)
				component_names = [component.name for component in components]

				logger.info(f'picked the most frequent component ({component_names=}, {top_component})')

				# if the top component doesn't match the `name` but another component does, pick that one
				# e.g. `name = 'Notification Preview'`
				#      `top_component = 'Mail Message Body Display | New Bugs'
				#      `component_names = ['Mail â€¦', 'Notifications']
				# pick `Notifications` (e.g. rdar://115204981)
				# don't match on obvious terms, like `Apple` (e.g. `name = `Apple Mail`)
				if (name_first_chunk := name.replace('Apple ', '').split()[0]) and  \
					not re.findall(name_first_chunk, f'{top_component.name} {top_component.version}', flags=re.IGNORECASE):

					# prefix with `\b` match and don't ignore case, so we don't match `installd` with `InstallDVDSpringBoard`
					# another example is to ensure we still match `Virtual Machine` with `Virtualization`, including lowercase `virtual machine` with `Virtualization`
					if _components := [component for component in components if (re.findall(fr'\b{name_first_chunk}\b', component.name) if cls.get_is_daemon_or_tool(name=name_first_chunk) else  \
																				re.findall(fr'\b{name_first_chunk}', component.name, flags=re.IGNORECASE))]:

						components = _components
						component_names = [component.name for component in components]
						top_component_name: str = max(set(component_names), key=component_names.count)

						# TODO: ask AI which component is more accurate, the new one or old one?
						logger.info(f'picked the most frequent component x2 ({component_names=}, {top_component_name})')

		# if still no components, and the name is something
		# like "QuickLook XPC Services", try again with just "QuickLook"
		if not components:

			name_split: str = name.split()
			_name: str = None

			for word in name_split:

				# e.g. QuickLook
				if not word.isupper() and sum([1 for character in word if character.isupper()]) >= 2:

					# TODO: try "Quick Look" too (if no results)
					_name = word
					break

			# if we still don't have a name, remove the last word
			# e.g. `Foundation URL Parser` -> `Foundation URL Parser`
			if not _name:
				_name = ' '.join(name_split[:-1])

			if _name and _name != name:

				actual_search_term = _name

				logger.info(f'ðŸ‘€ Trying again with shorter nameâ€¦ ({_name=})')
				components, actual_search_term = cls.get_components_by_name(name=_name, classification=classification, include_title=include_title)

		cls.CACHED_COMPONENTS[name] = components
		return components, actual_search_term

	@classmethod
	def sort_components(cls, components: list[Component], platform_name: str = None, search_term: str = None) -> list[Component]:
		"""
		Sorts a list of components so "New Bugs" and "All" are first. If a platform is passed, it also sorts by that

		@param components(list): a list of components. The first one should be the top match
		@param platform(str): a platform name (e.g. `macOS`)
		@param search_term(str): the original lookup name/query used to get the list of components
		"""

		# if no components or not enough to sort
		if not components or len(components) <= 1:
			return components

		# since this function expects the first component to be the top match, filter any components that
		# don't cross-match any of the words in the first component name
		# e.g. `['Photos', 'Sandbox', 'Photos Backend iCloud']` -> `['Photos', 'Photos Backend iCloud']` (e.g. rdar://112277943)
		first_component: Component = components[0]
		first_component_lower_name_chunk: list[str] = [first_component.name.lower().split()[0]]
		components = [first_component] + [component for component in components[1:] if bool(set(component.name.lower().split()) & set(first_component_lower_name_chunk))]

		if search_term:

			# if the name has `Apple ` in it, remove it for higher accuracy
			# e.g. `name = 'Apple Mail'` but the components are `['Mail', 'Mail â€¦', 'Lorem Mail â€¦']`
			# since we have filtering based on name
			if not any(component for component in components if re.findall(fr'^({component.name}|{component.version})$', search_term, flags=re.IGNORECASE)):
				search_term = search_term.replace('Apple ', '')

			logger.info('âž¡ï¸ filtering by search queryâ€¦')

			_components: list[Component] = []

			for component in components:

				# check if the search term is identical to either name or version
				if re.findall(fr'^({component.name}|{component.version})$', search_term, flags=re.IGNORECASE):
					_components.append(component)

				# TODO: unsure what the sub does
				elif re.findall(fr'^({component.name}|{component.version})$', re.sub(r'([a-z])([A-Z])', r'\1 \2', search_term), flags=re.IGNORECASE):
					_components.append(component)

			if _components:
				components = _components

		def _sort(component: Component, platform_names: set[str] = None):

			component_name_version: str = f'{component.name} {component.version}'

			# use regex patterns to avoid detecting `all` in `wallet` (for example)
			matches_name: str = component.name.lower().startswith(search_term.lower()) if search_term else False
			has_new_bugs: bool = len(re.findall(cls.NEW_BUGS_PATTERN, component_name_version, flags=re.IGNORECASE)) > 0
			has_platform_name: bool = len(re.findall(fr'{r"|".join(platform_names)}', component_name_version, flags=re.IGNORECASE)) > 0 if platform_names else False

			if platform_names:

				if has_new_bugs and has_platform_name:
					return 0

				elif has_new_bugs:
					return 1

				# if all we have is components with the same name but different platform versions, sort by our platform
				# e.g. platform_name = `macOS`
				#      components = `['BarcodeSupport (iOS)', 'BarcodeSupport (macOS)', 'BarcodeSupport (iOS)']`
				elif has_platform_name:
					return 2

				else:
					return 3

			if has_new_bugs:
				return 0

			return 1 if has_platform_name else 2

		# if no platform is passed and none of the components have a "New Bugs" component, sort by all platforms
		# e.g. `['Reminders (Framework)', 'Reminders (iOS)']` -> `['Reminders (iOS)', 'Reminders (Framework)']`
		if not platform_name and not any(re.findall(cls.NEW_BUGS_PATTERN, f'{component.name} {component.version}', flags=re.IGNORECASE) for component in components):
			return sorted(components, key=lambda component: _sort(component=component, platform_names=Templates.PLATFORM_NAMES))

		return sorted(components, key=lambda component: _sort(component=component, platform_names={platform_name} if platform_name else Templates.PLATFORM_NAMES))

	@classmethod
	def get_is_search_term_valid(cls, search_term: str) -> bool:
		"""
		Checks whether a search query is likely valid

		e.g. `iOS` -> False
			 `Safari` -> True
			 `iOS 17` -> False
		"""

		# if the component name is too long
		if len(search_term.split()) > 3:
			return False

		search_term_lower: str = search_term.lower()

		# component names should be at least alphanumeric
		# e.g. allow `ANE_ProgramSendCachedRequest()`
		if not search_term_lower.replace(' ', '').replace('.', '').replace('-', '').  \
			replace('()', '').replace('_', '').replace('::', '').isalnum():

			# allow some names (e.g. `libxml2:regexp`)
			if not search_term_lower.startswith(('lib')):
				return False

		# CVEs are not components
		if search_term_lower.startswith('cve-'):
			return False

		# platform names (e.g. iOS)
		if re.findall(fr'^({"|".join(Templates.PLATFORM_NAMES)})$', search_term, flags=re.IGNORECASE):
			return False

		# platforms with versions (e.g. iOS 17 or iOS 17 bug)
		if re.findall(fr'({"|".join(Templates.PLATFORM_NAMES)}) [0-9]', search_term, flags=re.IGNORECASE):
			return False

		# words
		if ' of ' in search_term_lower or ' in ' in search_term_lower:
			return False

		return True

	@classmethod
	def get_should_exclude_component(cls, component: Component, classification: str,
									 check_radars: bool = True) -> bool:
		"""
		Checks whether a component name is excluded
		"""

		if component.id in cls.CACHED_CHECKED_COMPONENT_IDS:
			return cls.CACHED_CHECKED_COMPONENT_IDS[component.id]

		def _get_is_words_in_text(words: set[str], text: str) -> bool:

			_text: str = Utilities.remove_words_in_text(words=words, text=text).strip()
			return not _text or _text != text

		should_exclude_component: bool = False

		if _get_is_words_in_text(words=cls.EXCLUDED_COMPONENT_NAMES, text=component.name):

			logger.info(f'excluding invalid name component ({component.name=}, {component.version=})')
			should_exclude_component = True

		if not should_exclude_component and _get_is_words_in_text(words=cls.EXCLUDED_COMPONENT_VERSIONS, text=component.version):

			logger.info(f'excluding invalid version component ({component.name=}, {component.version=})')
			should_exclude_component = True

		# skip any localization component by checking if it has any locale/region codes (e.g. `en_US`)
		locale_codes: set[str] = {code for code in locale.locale_alias.keys() if '_' in code and '.' not in code and '@' not in code}

		if re.findall(fr'\b({r"|".join(locale_codes)})\b', f'{component.name} {component.version}', flags=re.IGNORECASE):

			logger.info(f'excluding localization component ({component.name=}, {component.version=})')
			should_exclude_component = True

		# try looking up the component to see if it had any security radars before
		# e.g. we want to skip components like `iFrame Publisher | 1.0`
		if not should_exclude_component:

			# make sure the component is restricted + not closed
			# restricted = high chance of it being a disclosed component
			if check_radars and (not isinstance(getattr(component, 'isClosed', None), bool) or not isinstance(getattr(component, 'isRestricted', None), bool)):

				components: list[Component] = RadarClient.shared.components_for_ids(component_ids=[component.id])

				if not components:

					logger.warning(f'could not get component by ID ({component=})')
					should_exclude_component = True

				else:
					component = components[0]

			if component.isClosed:

				logger.info(f'excluding closed component ({component.name=}, {component.version=})')
				should_exclude_component = True

			if not should_exclude_component and not component.isRestricted:

				logger.info(f'excluding non-restricted component ({component.name=}, {component.version=})')
				should_exclude_component = True

			if not should_exclude_component and check_radars:

				criteria: dict[str, Any] = {

					'all': [{'classification': classification, 'componentId': component.id}],
					'orderBy': [{'field': 'id', 'order': 'descending'}],
				}
				external_items: list[ExternalItem] = RadarClient.shared.get_items_for_criteria(criteria=criteria, additional_fields=['id'], limit=1,
																							   return_find_results_directly=True)

				if len(external_items) <= 0:

					logger.info(f'excluding component because it has no radarsâ€¦ ({component.name=}, {component.version=})')
					should_exclude_component = True

		cls.CACHED_CHECKED_COMPONENT_IDS[component.id] = should_exclude_component
		return should_exclude_component

	@classmethod
	def get_updated_summary(cls, summary: str) -> str:
		"""
		Updates the text of a given summary comment
		"""

		# replace release names
		# releases: list[Release] = Release.select(Release.name, Release.marketing_name).  \
		# 								  where(Release.published_fcs_date >= datetime.now() - timedelta(weeks=200),
		# 										(Release.marketing_name.contains('iOS ') | Release.marketing_name.contains('macOS ') | Release.marketing_name.contains('tvOS ') |
		# 										 Release.marketing_name.contains('watchOS ') | Release.marketing_name.contains('visionOS ')),
		# 										~(Release.name.contains('Sec')), ~(Release.name.contains('RRU'))).  \
		# 								  distinct(Release.marketing_name).order_by(-Release.marketing_name)

		# for release in releases:

		# 	# e.g. `iOS 16.4.1 (a), iPadOS 16.4.1 (a), and macOS 13.3.1 (a)`
		# 	if ',' in release.marketing_name:
		# 		continue

		# 	# e.g. iOS 16.5 and iPadOS 16.5
		# 	elif ' and ' in release.marketing_name:

		# 		marketing_names: list[str] = release.marketing_name.split(' and ')

		# 		for marketing_name in marketing_names:
		# 			summary = summary.replace(marketing_name, release.name)

		# 			# if there's (for any reason), a trailing number (e.g. TrainE.1), remove the `.1`
		# 			summary = re.sub(fr'({release.name})(\.[0-9])', r'\1', summary, flags=re.IGNORECASE | re.MULTILINE)

		# 		continue

		# 	elif 'Security Update' in release.marketing_name:
		# 		continue

		# 	elif release.marketing_name.startswith('macOS '):

		# 		marketing_names: list[str] = [release.marketing_name]

		# 		# e.g. `macOS Ventura 13.6` -> `macOS 13.6`
		# 		marketing_names.append(f'macOS {release.marketing_name.rsplit(" ", 1)[-1]}')

		# 		# e.g. `macOS Ventura 13.6` -> `macOS Ventura`
		# 		marketing_names.append(f'macOS {release.marketing_name.rsplit(" ", 1)[0]}')

		# 		# e.g. `macOS Ventura 13.6` -> `Ventura`
		# 		marketing_names.append(f'{release.marketing_name.split(" ", 1)[-1].rsplit(" ", 1)[0]}')

		# 		for marketing_name in marketing_names:

		# 			summary = summary.replace(marketing_name, release.name)

		# 			# if there's (for any reason), a trailing number (e.g. TrainE.1), remove the `.1`
		# 			summary = re.sub(fr'({release.name})(\.[0-9])', r'\1', summary, flags=re.IGNORECASE | re.MULTILINE)

		# 		continue

		# 	summary = summary.replace(release.marketing_name, release.name)

		# 	# if there's (for any reason), a trailing number (e.g. TrainE.1), remove the `.1`
		# 	summary = re.sub(fr'({release.name})(\.[0-9])', r'\1', summary, flags=re.IGNORECASE | re.MULTILINE)

		# if the summary is too long
		if (period_count := summary.count('. ')) > 2:
			summary = summary.rsplit('. ', 2)[0]

		# replace repetitive use of "The researcher"
		if summary.count('The researcher') > 1:

			first_part, second_part = summary.split('The researcher', 1)
			second_part = second_part.replace('The researcher was', 'They were').replace('The researcher', 'They')
			summary = f'{first_part}The researcher{second_part}'

		# make wording sound more casual
		summary = re.sub('alleges|outlines', 'mentions', summary)
		summary = summary.replace('submission', 'radar')
		summary = summary.replace('bug report', 'radar')

		# Operating system -> OS
		summary = summary.replace('operating systems', 'OSes').replace('operating system', 'OS')

		# e.g. `Apple's iOS` -> `iOS`
		summary = summary.replace('Apple\'s ', '')

		# e.g. `the Apple Messages app` -> `the Messages app`
		summary = re.sub(r'the Apple ([A-Z]+)', r'the \1', summary, flags=re.IGNORECASE | re.MULTILINE)

		# device names
		# e.g. `in the iPhone's Camera.app` -> `in the Camera.app`
		summary = re.sub(fr'({r"|".join(Templates.DEVICE_NAMES)})(\'|â€™)s\W', '', summary)

		# ensure correct casing for platform names
		# e.g. `IOS` -> `iOS`
		for platform_name in Templates.PLATFORM_NAMES:
			summary = re.sub(platform_name, platform_name, summary, flags=re.IGNORECASE)

		# e.g. `in the <name> feature` -> `in <name>`
		summary = re.sub(r'in the ([A-Z]+) feature', r'in \1', summary, flags=re.IGNORECASE | re.MULTILINE)

		# e.g. `in InstallAssistant of macOS` -> `in InstallAssistant`
		summary = re.sub(fr'in ([A-Z]+) of ({r"|".join(Templates.PLATFORM_NAMES)})', r'in \1', summary, flags=re.IGNORECASE | re.MULTILINE)

		# only use acronyms instead of full form (e.g. OOB instead of out-of-bounds)
		summary = Utilities.remove_acronyms(text=summary)

		return summary.strip()

	@classmethod
	def stage_seed_feedback_item(cls, item: ExternalItem, comment_text: str, configuration: Configuration) -> None:
		"""
		Stages an item for SEED feedback

		@param item(Item): a radar `Item`
		"""

		configuration.add_suggestion(name='internal_comment', value=f'{comment_text}. Back to Issue Pool', item=item)
		configuration.add_suggestion(name='component', value=cls.ISSUE_POOL_COMPONENT.id, display_value=f'{cls.ISSUE_POOL_COMPONENT.name} | {cls.ISSUE_POOL_COMPONENT.version}',
									 thought=comment_text, item=item)

		if configuration.data.classification_behavior is not None:
			configuration.add_suggestion(name='security_type', value=ExternalItem.PRODUCT_SECURITY_TYPE_NONE, item=item)

	@classmethod
	def remove_builds(cls, text: str) -> str:
		"""
		Removes build numbers from a given text

		@param text(str): any text (e.g. radar title)
		@return (str): text without a build number
		"""

		# e.g. 00A00
		return re.sub(r'[0-9]{1,2}[A-Z][0-9]{1,4}(?:[a-z]|)', '', text, flags=re.IGNORECASE | re.MULTILINE)

	@classmethod
	def get_is_daemon_or_tool(cls, name: str) -> bool:
		"""
		Returns whether a given name is a daemon, tool name, library, or framework

		e.g. `installd` = True
			 `ldmtool` = True
			 `Computer` = False
			 `Surfboard` = False
			 `iCloud diagnostics tool` = False

		@param name(str): a component query name
		@return (bool): whether it's a daemon or tool
		"""

		if ' ' in name:
			return False

		# daemon names (e.g. `installd`)
		# names that with `ad` are less likely to be a daemon name (e.g. `payload`)
		if name.islower() and name.endswith('d') and not name.endswith('ad'):
			return True

		name_lower: str = name.lower()
		return name_lower.endswith(('agent', 'ctl', 'tool', 'framework', 'kit')) or name_lower.startswith('lib')

	@classmethod
	def get_invalid_enum_options(cls) -> set[str]:

		if not hasattr(cls, '_INVALID_ENUM_OPTIONS'):

			# TODO: consider adding verbs that end with `*ing` (e.g. `Copying`, rdar://111922796)
			cls._INVALID_ENUM_OPTIONS = {'Google Chrome*', 'Microsoft *', 'html', 'GWP-ASan',
										 'iCloud', '*Vulnerability*', '*Bug*', '*Radar*', 'Documentation', 'Authorization',
										 'Authentication', 'Apple', 'escape', 'device', 'App', 'glitch', 'buffer overflow',
										 'overflow', 'sandboxed process', 'sandboxed app', 'library', 'app', 'privacy', 'security',
										 'unauthorized'}

			cls._INVALID_ENUM_OPTIONS = cls._INVALID_ENUM_OPTIONS.union({f'{device_name}*' for device_name in Templates.DEVICE_NAMES})
			cls._INVALID_ENUM_OPTIONS = cls._INVALID_ENUM_OPTIONS.union({f'{platform_name}*' for platform_name in Templates.PLATFORM_NAMES})

			# TODO: add macOS marketing release names (e.g. `Ventura`, `Sonoma`)

		return cls._INVALID_ENUM_OPTIONS
