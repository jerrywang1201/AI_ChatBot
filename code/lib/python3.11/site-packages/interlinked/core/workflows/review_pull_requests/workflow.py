import os
import re
import json
import logging
import requests
import traceback
from typing import Any, Dict, List, Optional, Tuple, Union
from sqlalchemy import text
from pydantic import BaseModel
from sqlalchemy.orm import Session
from collections import defaultdict
from concurrent.futures import ThreadPoolExecutor, as_completed


from interlinked.core.config import Config
from interlinked.core.ai import AI, Observation
from interlinked.core.utilities import Utilities
from interlinked.core.clients.ajaxclient import AJAXClient
from interlinked.core.clients.ollamaclient import OllamaClient
from interlinked.core.clients.githubclient import GitHubClient
from interlinked.core.clients.stashwebclient import StashWebClient
from interlinked.core.clients.customradarclient import RadarClient
from interlinked.core.classes import ExternalItem, SimilarItem, Person
from interlinked.core.workflows.review_pull_requests.templates import *
from interlinked.ui.models import BaseWorkflow, BaseConfiguration, Suggestion, Configuration as DatabaseConfiguration

logger = logging.getLogger(__name__)




class Persona(BaseModel):

	name: str
	template: str


class ConfigurationData(BaseModel):

	# the URL of the repo
	repository_url: str

	# API token for StashWeb (BitBucket)
	api_token: Optional[str]

	personas: list[Persona] = [

		Persona(name='AI Test Engineer: Reviewer', template=PERSONA_TESTING_TEMPLATE),
		Persona(name='AI Source Code: Change Reviewer', template=PERSONA_REVIEWER_TEMPLATE),
		Persona(name='AI Security Reviewer: Exploit Prevention', template=PERSON_SECURITY_TEMPLATE),
	]


class Configuration(BaseConfiguration):

	data: ConfigurationData


class PullRequest(BaseModel):

	id: int
	url: str
	org: Optional[str] = None
	repo: Optional[str] = None


class PRReviewer(BaseWorkflow):

	# commit_hash_pattern = re.compile(
	# 	r'(?:Fixed with commit|to master in commit|commit:|Commit:\s+)([a-f0-9]{40})'
	# )

	commit_hash_pattern = re.compile(
		r'(?:Fixed with commit|to master in commit|commit:|Commit:\s+|commit\s+)([a-f0-9]{6,40})'
	)


	hash_pattern = re.compile(r'commits/([a-f0-9]+)')

	url_pattern = re.compile(
		r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*(),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+(?![^<]*?>)'
	)

	@classmethod
	def handle_api(cls, path: str, data: dict[str, str], request: 'Request') -> dict:
		"""
		Handle all webhook events
		"""
		user_agent: str = request.headers.get('user-agent')

		if 'GitHub-Hookshot' in user_agent:

			event: str = request.headers.get('X-GitHub-Event')
			if 'pull_request' in data.get('issue', {}) or 'pull_request' in data:
				cls.handle_github_event(event=event, data=data)
			else:
				return

		elif 'Atlassian' in user_agent:

			event: str = request.headers.get('X-Event-Key')
			cls.handle_atlassian_event(event=event, data=data)

		return {'response': 'ok'}

	@classmethod
	def handle_github_event(cls, event: str, data: dict[str, str]) -> None:
		"""
		Handle webhook events coming from GitHub.
		"""

		if event == 'pull_request':

			pull_request_action = data['action']

			if pull_request_action in {'reopened', 'opened'}:

				repository_url: str = data['repository']['html_url']
				pull_request_url: str = data['pull_request']['html_url']

				configuration: Configuration = DatabaseConfiguration.select().where(DatabaseConfiguration.data.op('->>')('repository_url') == repository_url).first()

				if configuration:

					configuration = Configuration(**configuration.model_dump())
					cls.post_initial_comment(pull_request_url=pull_request_url, configuration=configuration)

		elif event in {'pull_request_review_comment', 'issue_comment'}:

			comment_body: str = data['comment']['body']
			comment_url: str = data['comment']['html_url']
			repository_url: str = data['repository']['html_url']

			# TODO: check when this occurs
			if not 'issue' in data:
				return

			pull_request_url = data['issue']['pull_request']['html_url']
			
			configuration: Configuration = DatabaseConfiguration.select().where(DatabaseConfiguration.data.op('->>')('repository_url') == repository_url).first()

			if configuration:

				configuration = Configuration(**configuration.model_dump())

				if comment_body.lower().startswith('@ai-security'):
					cls.review_pull_request_security_persona(pull_request_url=pull_request_url, configuration=configuration)

				elif comment_body.lower().startswith('@ai-all'):
					cls.review_pull_request(pull_request_url=pull_request_url, configuration=configuration)

				elif comment_body.lower().startswith('@criteria'):
					cls.review_pull_request_criteria(pull_request_url=pull_request_url, configuration=configuration)

				elif comment_body.lower().startswith('@interlinked') or comment_body.lower().startswith('@ai'):
					cls.respond_to_user_comment(user_comment=comment_body, comment_url=comment_url, pull_request_url=pull_request_url, configuration=configuration)

	@classmethod
	def handle_atlassian_event(cls, event: str, data: dict[str, str]) -> None:
		"""
		Handle webhook events coming from Atlassian BitBucket/Stash.
		"""

		if event == 'pr:opened' or event == 'pr:comment:added':

			configuration: Configuration = None

			pull_request_url: str = data['pullRequest']['links']['self'][0]['href']
			repository_self_url: str = data['pullRequest']['toRef']['repository']['links']['self'][0]['href']
			repository_url: str = repository_self_url.replace('/browse', '')

			logging.info(f'repository_url from event is {repository_url}')

			configuration: DatabaseConfiguration = DatabaseConfiguration.select().where(DatabaseConfiguration.data.op('->>')('repository_url') == repository_url).first()

			if configuration:

				configuration = Configuration(data=ConfigurationData(**configuration.data))
				logging.info(f'configuration.data.repository_url is {configuration.data.repository_url}')

		if event == 'pr:opened':
			cls.post_initial_comment(pull_request_url=pull_request_url, configuration=configuration)

		elif event == 'pr:comment:added':

			if event == 'pr:comment:added':

				comment_body = data['comment']['text']

				if comment_body.lower().startswith('@ai-security'):
					cls.review_pull_request_security_persona(pull_request_url=pull_request_url, configuration=configuration)

				elif comment_body.lower().startswith('@ai-all'):
					cls.review_pull_request(pull_request_url=pull_request_url, configuration=configuration)

				elif comment_body.lower().startswith('@criteria'):
					cls.review_pull_request_criteria(pull_request_url=pull_request_url, configuration=configuration)

				elif comment_body.lower().startswith('@interlinked') or comment_body.lower().startswith('@ai'):
					cls.respond_to_user_comment(user_comment=comment_body, comment_url=pull_request_url, pull_request_url=pull_request_url, configuration=configuration) 

	@classmethod
	def review_pull_request_security_persona(cls, pull_request_url: str, configuration: Configuration = None, **kwargs) -> None:
		"""
		Review a pull request specifically for security items, comment on potential fixes
		TODO: stash
		"""
		pull_request_id: int = pull_request_url.rsplit('/', 1)[-1] 

		client: GitHubClient | StashWebClient = None  

		if 'github.pie.apple.com' in pull_request_url:

			client = GitHubClient()
			org, repo = GitHubClient.parse_repository_url(pull_request_url)
			client.installation_id = client.get_installation_id(org=org, repo=repo)

			pull_request: PullRequest = PullRequest(url=pull_request_url, id=pull_request_id, org=org, repo=repo)
			
			diffs, diff_patch, pull_request_change_details= client.generate_diff(org=pull_request.org, repo=pull_request.repo, pull_request_number=pull_request.id)
			
			for item in pull_request_change_details:

				patch_for_review: str = item['patch']
				observation: Observation = AI.ask(prompt={'patch_for_review': patch_for_review}, temperature=0.4, template=SECURITY_REVIEWER_PERSONA_TEMPLATE)

				technical_summary = observation.summary

				logging.info(f'observation.summary is {observation.summary}')
				logging.info(f'observation.category is {observation.category}')

				final_response: str = None

				if observation.category.is_no_security_issue:

					final_response = 'Looks good! No security issues identified.'
					client.post_comment_to_pull_request(org=pull_request.org, repo=pull_request.repo, pull_request_number=pull_request.id, comment=final_response)
					client.approve_pull_request(org=org, repo=repo, pull_request_number=pull_request_id)

				else:

					# security issue identified
					observation = observation.ask(prompt={'patch_for_review': patch_for_review, 'technical_summary':technical_summary},
												  template=SECURITY_REVIEWER_PERSONA_INVESTIGATE_FURTHER_TEMPLATE)

					security_summary: str = observation.summary
					variables_impacted: str = observation.filename

					logging.info(f'variables_impacted is {variables_impacted}')

					variables_impacted_list, identified_impacted_line_numbers = cls.identify_vulnerable_lines(patch=item['patch'], variables_impacted_string=variables_impacted)

					logging.info(f'identified_impacted_line_numbers is {identified_impacted_line_numbers}')
					
					def process_variable(vulnerable_variable):

						observation = AI.ask(prompt={'security_summary': security_summary,
													 'vulnerable_variable': vulnerable_variable,
													 'patch_for_review': patch_for_review}, template=SECURITY_REVIEWER_PERSONA_INVESTIGATE_FIX_TEMPLATE)

						response: str = pattern.sub(r'\b\w+```', '```', observation.response.raw)

						client.post_file_comment_to_pull_request(org=org, repo=repo, pull_request_number=pull_request_id,
																 path=item['filename'], position=identified_impacted_line_numbers[vulnerable_variable][-1],
																 commit_id=item['commit_sha'], comment=response)

					for item in variables_impacted_list:
						process_variable(item)

					final_summary_comment = f'**Security Summary**: {security_summary}'

					client.post_comment_to_pull_request(org=pull_request.org, repo=pull_request.repo, pull_request_number=pull_request.id,
														comment=final_summary_comment)

	@classmethod
	def review_pull_request_criteria(cls, pull_request_url: str, configuration: Optional[Configuration] = None, **kwargs) -> None:
		"""
		Review a pull request and post comments for the criteria that require attention,
		and ask AI to summarize the findings.
		"""
		pull_request_id: int = int(pull_request_url.rsplit('/', 1)[-1])
		client: GitHubClient | StashWebClient = None  

		if 'github.pie.apple.com' in pull_request_url:
			client = GitHubClient()
			org, repo = GitHubClient.parse_repository_url(pull_request_url)
			client.installation_id = client.get_installation_id(org=org, repo=repo)
			pull_request = PullRequest(url=pull_request_url, id=pull_request_id, org=org, repo=repo)
			diffs, diff_patch, pull_request_change_details = client.generate_diff(org=org, repo=repo, pull_request_number=pull_request_id)

		elif 'stashweb.sd.apple.com' in pull_request_url:
			client = StashWebClient(api_token=configuration.data['api_token'], pull_request_url=pull_request_url) if configuration else None
			pull_request = PullRequest(url=pull_request_url, id=pull_request_id)
			diffs, diff_patch = client.generate_diff(pull_request_id)

		else:
			raise Exception('Unsupported Git URL')

		persona_criteria = {var_name: value for var_name, value in globals().items() if '_CRITERIA_TEMPLATE' in var_name}
		list_of_persona_criteria = list(persona_criteria.keys())  

		threads = min(10, len(list_of_persona_criteria))
		criteria_observations = []

		with ThreadPoolExecutor(max_workers=threads) as executor:
			future_to_item = {executor.submit(
				lambda item, template=persona_criteria[item]: AI.ask(prompt={'patch_for_review': diff_patch}, template=template, temperature=0.2),
				item
			): item for item in list_of_persona_criteria}
			
			for future in as_completed(future_to_item):
				item = future_to_item[future]
				try:
					observation = future.result()
					print(f'Item: {item}, Attention: {observation.needsattention}, Summary: {observation.summary}')
					if observation.needsattention == 'true':
						criteria_observations.append(f'Item: {item}, Summary: {observation.summary}')
				except Exception as exc:
					print(f'{item} generated an exception: {exc}')
		

		print(f'criteria_observations is {criteria_observations}')

		for item in criteria_observations:
			print(item)

		if criteria_observations:
			observation = AI.ask(prompt={'patch_for_review': diff_patch, 'findings': criteria_observations}, template=SUMMARIZE_PERSONA_FINDINGS_INVESTIGATE_FIX_TEMPLATE, temperature=0.2)
			comment_for_pr = observation.summary

		post_result = client.post_comment_to_pull_request(org=pull_request.org, repo=pull_request.repo, pull_request_number=pull_request.id, comment=comment_for_pr)


	@classmethod
	def find_patch_from_pull_request_url(cls, pull_request_url) -> str:

		client: GitHubClient | StashWebClient
		
		if 'stashweb.sd.apple.com' in pull_request_url:
			stash_web_api_token = os.environ['stash_api_token']
			client = StashWebClient(api_token=stash_web_api_token, pull_request_url=pull_request_url)
			base_url, pull_request_id_str = cls.extract_pull_request_details(pull_request_url)
					
			try:
				diffs, diff_patch = client.generate_diff(pull_request_id_str)
			except Exception as e:
				print(f"Error generating diff for PR {pull_request_id_str}: {e}")

		if 'github.pie.apple.com' in pull_request_url:
			client = GitHubClient()
			org, repo = GitHubClient.parse_repository_url(pull_request_url)
			client.installation_id = client.get_installation_id(org=org, repo=repo)
			pull_request = PullRequest(url=pull_request_url, id=pull_request_id, org=org, repo=repo)
			diffs, diff_patch, pull_request_change_details = client.generate_diff(org=org, repo=repo, pull_request_number=pull_request_id)

		return diff_patch


	@classmethod
	def review_pull_request(cls, pull_request_url: str, configuration: Configuration = None, **kwargs) -> None:
		"""
		Review a pull request and post comments for the personas
		"""

		pull_request_id: int = int(pull_request_url.rsplit('/', 1)[-1])
		client: GitHubClient | StashWebClient

		if 'github.pie.apple.com' in pull_request_url:

			client = GitHubClient()
			org, repo = GitHubClient.parse_repository_url(pull_request_url)
			client.installation_id = client.get_installation_id(org=org, repo=repo)

			pull_request = PullRequest(url=pull_request_url, id=pull_request_id, org=org, repo=repo)
			diffs, diff_patch, pull_request_change_details = client.generate_diff(org=org, repo=repo, pull_request_number=pull_request_id)

		elif 'stashweb.sd.apple.com' in pull_request_url:

			client = StashWebClient(api_token=configuration.data.api_token, pull_request_url=pull_request_url)

			pull_request = PullRequest(url=pull_request_url, id=pull_request_id)
			diffs, diff_patch = client.generate_diff(pull_request_id)

		else:
			raise Exception('Unsupported Git URL')

		cls.generate_prompt_and_comment(diff_patch=diff_patch, personas=configuration.data.personas,
										pull_request=pull_request, client=client)

		if Config.current.is_development:

			logging.info(f'diffs: {diffs}')
			logging.info(f'diff patch: {diff_patch}')

	@classmethod
	def post_initial_comment(cls, pull_request_url: str, configuration: Configuration = None, **kwargs) -> None:
		"""
		Post an initial comment to pull request
		"""

		client: GitHubClient | StashWebClient = None

		if 'github.pie.apple.com' in pull_request_url:

			pull_request_id: int = pull_request_url.rsplit('/', 1)[-1] 

			client = GitHubClient()
			org, repo = GitHubClient.parse_repository_url(pull_request_url)

			# set installation ID for the client, related to this repo
			client.installation_id = client.get_installation_id(org=org, repo=repo)

			pull_request: PullRequest = PullRequest(url=pull_request_url, id=pull_request_id, org=org, repo=repo)
			diffs, diff_patch, pull_request_change_details= client.generate_diff(org=pull_request.org, repo=pull_request.repo,
																				 pull_request_number=pull_request.id) 

		elif 'stashweb.sd.apple.com' in pull_request_url:

			pull_request_id: int = pull_request_url.rsplit('/', 1)[-1] 

			client = StashWebClient(api_token=configuration.data.api_token, pull_request_url=pull_request_url)
			pull_request: PullRequest = PullRequest(url=pull_request_url, id=pull_request_id)

			diffs, diff_patch = client.generate_diff(pull_request_id)

		else:
			raise Exception('unsupported git url')

		length_of_patch = len(diff_patch.split('\n'))

		initial_comment = INITIAL_AI_PR_REVIEWER_COMMENT.format(length_of_patch=length_of_patch)
		
		if isinstance(client, GitHubClient):

			post_result = client.post_comment_to_pull_request(org=pull_request.org, repo=pull_request.repo, pull_request_number=pull_request.id,
															  comment=initial_comment)
		else:

			post_result = client.post_comment_to_pull_request(pull_request_id=pull_request.id, comment=initial_comment)

	@classmethod
	def filter_relevant_urls(cls, urls: List[str]) -> Tuple[List[str], List[str], List[str]]:
		"""
		Filters URLs into three categories: commit URLs, pull request URLs, and all Apple URLs.

		Args:
			urls: A list of URLs to be filtered.

		Returns:
			A tuple containing lists of commit URLs, pull request URLs, and all Apple URLs.
		"""
		# print(f'urls is {urls}')
		commit_urls, pull_request_urls, all_apple_urls = [], [], []
		for url in urls:
			if 'apple' in url:
				all_apple_urls.append(url)
			if any(keyword in url for keyword in ['github', 'stashweb', 'stash']):
				if 'commits' in url:
					commit_urls.append(url)
				if 'pull' in url or 'pull-requests' in url:
					pull_request_urls.append(url)
		return commit_urls, pull_request_urls, all_apple_urls

	@classmethod
	def find_commit_hash_in_merge_note(cls, source_patch_diff: str) -> List[str]:
		"""
		Searches for commit hashes in the source patch diff.

		Args:
			source_patch_diff: A string containing the patch diff text.

		Returns:
			A list of commit hashes if found, otherwise an empty list.
		"""
		# Regular expression pattern to match a SHA-1 hash
		commit_hash_pattern = re.compile(r'\b[0-9a-f]{40}\b')

		# Find all occurrences of the pattern in the given string
		return commit_hash_pattern.findall(source_patch_diff)

	@classmethod
	def find_commit_hash_in_diagnosis(cls, diagnosis_lines: List[str]) -> Optional[str]:
		"""
		Searches for a commit hash in the diagnosis lines.

		Args:
			diagnosis_lines: A list of strings, each representing a line of diagnosis text.

		Returns:
			The commit hash if found, otherwise None.
		"""
		for line in reversed(diagnosis_lines):
			match = cls.commit_hash_pattern.search(line)
			if match:
				return match.group(1)
		return None

	@classmethod
	def find_urls_in_text(cls, text: str) -> List[str]:
		"""
		Finds all URLs in a given text.

		Args:
			text: A string that may contain URLs.

		Returns:
			A list of URLs found in the text.
		"""
		return cls.url_pattern.findall(text)



	@classmethod
	def extract_commit_hashes_from_urls(cls, urls: List[str]) -> List[str]:
		"""
		Extracts commit hashes from a list of commit URLs.

		Args:
			urls: A list of URLs that may contain commit hashes.

		Returns:
			A list of extracted commit hashes.
		"""
		return [match.group(1) for url in urls if (match := cls.hash_pattern.search(url))]

	@classmethod
	def extract_pull_request_details(cls, url: str) -> Tuple[Optional[str], Optional[str]]:
		"""
		Extracts the base URL and pull request ID from a given URL. 
		
		Args:
		url (str): The full URL to parse.
		
		Returns:
		Tuple[Optional[str], Optional[str]]: A tuple containing the base URL and pull 
											 request ID if found, or (None, None) if not.
		"""
		url_without_fragment = url.split('#', 1)[0]
		url_without_query = url_without_fragment.split('?', 1)[0]
		
		url_parts = url_without_query.split('/')
		
		try:
			pr_index = url_parts.index('pull-requests')
			pull_request_id = url_parts[pr_index + 1]
			base_url = '/'.join(url_parts[:pr_index + 2])
			return base_url, pull_request_id
		except ValueError:
			print("The URL does not contain 'pull-requests'.")
		except IndexError:
			print("No pull request ID found in URL.")
		
		return None, None

	@classmethod
	def extract_repo_and_org_from_urls(
		cls,
		commit_urls: List[str], 
		pr_urls: List[str], 
		all_apple_urls: List[str]
	) -> Tuple[Optional[str], Optional[str], Optional[str]]:
		"""
		Extracts the organization name, repository name, and host from a list of URLs.

		Parameters:
		- commit_urls: A list of URLs for commits.
		- pr_urls: A list of URLs for pull requests.
		- all_apple_urls: A list of URLs related to Apple.

		Returns:
		A tuple containing the organization name, repository name, and host if found; 
		otherwise, returns a tuple of three None values.
		"""

		all_urls = commit_urls + pr_urls + all_apple_urls

		# print(f'all_urls is {all_urls}')
		# print(f'commit_urls is {commit_urls}')
		# print(f'pr_urls is {pr_urls}')

		for url in all_urls:
			if 'github' in url:
				# Match GitHub URLs
				match = re.search(
					r'github\.([^/]+\.apple\.com)/([^/]+)/([^/]+)/', url
				)
				if match:
					host = match.group(0)
					org_name = match.group(2)
					repo_name = match.group(3)
					return org_name, repo_name, host
			elif 'stashweb' in url or 'stash' in url:

				match = re.search(
					r'(stash(web)?\.sd\.apple\.com)/projects/([^/]+)/repos/([^/]+)', url
				)
				if match:
					host = 'stashweb' #match.group(1)
					org_name = match.group(3)
					repo_name = match.group(4)
					return org_name, repo_name, host

		# If no matches found return None for all
		return None, None, None

	@classmethod
	def review_report_and_changes_for_summary(cls, title: str, component: str, description: str, sourceChanges: str, client):
		"""
		Review a report and its source changes to describe the root cause and description of fix
		"""
		initial_observation: Observation = AI.ask(prompt={'report_title': title, 'project_name': component, 'reported_issue': description, 'project_name': component}, template=REVIEW_REPORT_TEMPLATE, client=client)

		final_observation: Observation = initial_observation.ask(prompt={'proposed_changes': sourceChanges}, template=REVIEW_REPORT_CHANGES_TEMPLATE)

		return initial_observation.response_as_dictionary, final_observation.response_as_dictionary



	@classmethod
	def respond_to_user_comment(cls, user_comment: str, pull_request_url: str, configuration: Configuration = None, **kwargs) -> None:
		"""
		Respond to a user's comment on the pull request
		"""
		client: GitHubClient | StashWebClient = None 

		if 'github.pie.apple.com' in pull_request_url:

			pull_request_id: int = pull_request_url.rsplit('/', 1)[-1] 

			client = GitHubClient()
			org, repo = GitHubClient.parse_repository_url(pull_request_url)

			pull_request: PullRequest = PullRequest(url=pull_request_url, id=pull_request_id, org=org, repo=repo)

			# set installation ID for the client, related to this repo
			client.installation_id = client.get_installation_id(org=org, repo=repo)
			diffs, diff_patch, pull_request_change_details = client.generate_diff(org=pull_request.org, repo=pull_request.repo, pull_request_number=pull_request.id)

		elif 'stashweb.sd.apple.com' in pull_request_url:

			pull_request_id: int = pull_request_url.rsplit('/', 1)[-1] 

			client = StashWebClient(api_token=configuration.data.api_token, pull_request_url=pull_request_url)
			pull_request: PullRequest = PullRequest(url=pull_request_url, id=pull_request_id)

			diffs, diff_patch = client.generate_diff(pull_request_id)

		else:
			raise Exception('unsupported git url')

		model_pattern = re.compile(r"model='(.*?)'")
		ollama_pattern = re.compile(r"ollama='(https?://.*?:\d+)/?'")

		model_match = model_pattern.search(user_comment)
		ollama_match = ollama_pattern.search(user_comment)

		is_ollama: bool = False
		base_url: str = 'ajax'
		model_name: str = 'ajax'

		if ollama_match and model_match:

			is_ollama = True
			base_url = ollama_match.group(1)
			model_name = model_match.group(1)

		cleanup_pattern = re.compile(r"ollama='https?://.*?:\d+/?'|model='.*?'|@interlinked|@ai")
		user_comment = cleanup_pattern.sub('', user_comment).strip()

		logging.info(f'base_url is {base_url}, is_ollama is {is_ollama}')

		final_response: str = ''
		diff_patch_too_large: bool = False

		if not is_ollama:

			try:
				observation: Observation = AI.ask(prompt={'patch': diff_patch, 'user_comment': user_comment}, template=QUESTION_ABOUT_PATCH_TEMPLATE)
				final_response = observation.response.raw

			except Exception as exception:

				logging.error('an error occurred', exc_info=True)
				diff_patch_too_large = True
				final_response = CANNOT_PROCESS_PROMPT

		elif is_ollama:

			observation = AI.ask(prompt={'patch': diff_patch, 'user_comment': user_comment}, template=QUESTION_ABOUT_PATCH_TEMPLATE,
								 temperature=0.8, client=OllamaClient(model_name=model_name, base_url=base_url))

		if diff_patch_too_large:
			cls.post_comment(client, pull_request, CANNOT_PROCESS_PROMPT)

		else:

			if isinstance(client, GitHubClient):

				client.post_comment_to_pull_request(org=pull_request.org, repo=pull_request.repo, pull_request_number=pull_request.id,
													comment=final_response)

			else:

				final_response = observation.response.raw 
				client.post_comment_to_pull_request(pull_request_id=pull_request.id, comment=final_response)

	@classmethod
	def identify_vulnerable_lines(cls, patch: str, variables_impacted_string: str):
		"""
		Identify lines that have variables_impacted_string
		"""
		variables_impacted_list = [var.strip() for var in variables_impacted_string.split(',')]
		logging.info(f'variables_impacted_list is {variables_impacted_list}')

		variables_impacted_list_no_ext = [re.sub(r'\.[^.]*$', '', var).strip('`') for var in variables_impacted_list]
		logging.info(f'variables_impacted_list_no_ext is {variables_impacted_list_no_ext}')

		identified_impacted_line_numbers = {}

		starting_line_number = None

		added_lines_in_new_file = 0

		for line in patch.split('\n'):

			if line.startswith('@@'):

				hunk_header_match = re.search(r'\+([0-9]+)', line)

				if hunk_header_match:

					starting_line_number = int(hunk_header_match.group(1))
					added_lines_in_new_file = 0  

			elif line.startswith('+') and not line.startswith('++'): 

				added_lines_in_new_file += 1
				current_line_number = starting_line_number + added_lines_in_new_file 

				for variable in variables_impacted_list_no_ext:

					if variable in line:

						if variable not in identified_impacted_line_numbers:
							identified_impacted_line_numbers[variable] = []

						identified_impacted_line_numbers[variable].append(current_line_number)

			elif line.startswith('-'):
				pass

			else:
				starting_line_number += 1

		return variables_impacted_list_no_ext, identified_impacted_line_numbers

	@classmethod
	def get_response_for_prompt(cls, template: str, prompt_content: str) -> str:
		"""
		Prompt the LLM for a response
		"""
		diff_patch_too_large = False

		prompt: str = template + prompt_content
		
		if Config.current.is_development:
			logging.info(f'prompt is {prompt}...')

		# AjaxGPT
		try:

			observation = AI.ask(prompt=prompt, temperature=0.8)
			response = observation.response.raw
			return response

		except Exception as exception:

			logging.error(f'An error occurred: {exception}')
			diff_patch_too_large = True
			return CANNOT_PROCESS_PROMPT

		# Ollama 
		# options = {}
		# observation = AI.ask(prompt=prompt, temperature=0.8, client=OllamaClient(model_name='dolphin-mixtral'))
		# response = observation.response

		if Config.current.is_development:

			logging.info(f'Prompt: {prompt}')
			logging.info('Successfully generated prompt and API response.')
			logging.info(f'Response: {response}')

		return response

	@classmethod
	def generate_prompt_and_comment(cls, diff_patch: str, personas: list[Persona], pull_request: PullRequest, client: GitHubClient | StashWebClient) -> None:
		"""
		Generate the prompt for the LLM and comment on pull request
		"""
		responses: dict[str, str] = dict()
		
		def get_response_for_persona(persona: Persona) -> tuple[str, str]:

			formatted_diff: str = f'Patch: {diff_patch}'
			response: str = cls.get_response_for_prompt(template=persona.template, prompt_content=formatted_diff)
			return persona.name, response
		
		with ThreadPoolExecutor() as executor:

			for persona_name, response in executor.map(get_response_for_persona, personas):
				responses[persona_name] = response

		all_persona_responses: str = ''
		
		summarize_personas = False

		if summarize_personas:
			all_persona_responses = 'Your task is to re-format this information using markdown style, including bullets or numbers, code blocks, headers and subheaders.\n\n'

		for persona_name, response in responses.items():
			all_persona_responses += f'## **AI {persona_name} Persona**\n\n{response}\n\n'
		
		if CANNOT_PROCESS_PROMPT in all_persona_responses:

			cls.post_comment(client, pull_request, CANNOT_PROCESS_PROMPT)
			return

		if summarize_personas:

			final_summary_response: str = cls.get_response_for_prompt(template='', prompt_content=all_persona_responses)
			cls.post_comment(client, pull_request, final_summary_response)

		else:
			cls.post_comment(client, pull_request, all_persona_responses)
	

	@classmethod
	def post_comment(cls, client: GitHubClient | StashWebClient, pull_request: PullRequest, comment: str) -> None:

		# The previous implementation for posting the comment remains unchanged
		logger.info('Posting commentâ€¦')

		if isinstance(client, GitHubClient):
			client.post_comment_to_pull_request(org=pull_request.org, repo=pull_request.repo, pull_request_number=pull_request.id, comment=comment)

		elif isinstance(client, StashWebClient):
			client.post_comment_to_pull_request(pull_request_id=pull_request.id, comment=comment)


if __name__ == '__main__':
	
	PRReviewer.review_pull_request(pull_request_url='', configuration=None)
