import re
import os
import sys
import random
import logging
from typing import Any
from pathlib import Path
from typing import Optional
from urllib.parse import urlparse
from datetime import datetime, timedelta
from requests.exceptions import HTTPError
from pydantic import BaseModel, ValidationError

from interlinked.core.config import Config
from interlinked.core.utilities import Utilities
from interlinked.core.clients.boxclient import BoxClient
from interlinked.core.parsers.quipparser import QuipParser
from interlinked.core.parsers.htmlparser import HTMLParser
from interlinked.core.clients.ajaxclient import AJAXClient
from interlinked.core.workflows.knowledge.templates import *
from interlinked.core.clients.slackclient import SlackClient
from interlinked.core.clients.githubclient import GitHubClient
from interlinked.core.parsers.chorusparser import ChorusParser
from interlinked.core.parsers.docbookparser import DocBookParser
from interlinked.core.parsers.markdownparser import MarkdownParser
from interlinked.core.parsers.confluenceparser import ConfluenceParser
from interlinked.core.parsers.restructuredparser import RestructuredParser
from interlinked.core.clients.quipclient import QuipClient, Thread, Folder
from interlinked.core.parsers.stackoverflowparser import StackOverflowParser
from interlinked.core.clients.stackoverflowclient import StackOverflowClient
from interlinked.core.clients.confluenceclient import ConfluenceClient, Page
from interlinked.core.workflows.knowledge.sources.pdfsource import PDFSource
from interlinked.core.clients.chorusclient import ChorusClient, Page as ChorusPage
from interlinked.core.clients.appledirectoryclient import AppleDirectoryClient, Person
from interlinked.core.ai import AI, Observation, Template, Knowledge, Section, UserError
from interlinked.ui.models import BaseWorkflow, BaseConfiguration, KnowledgeSource, KnowledgeSourceEnum,  \
									Thread, ThreadSource, Message, Configuration as DatabaseConfiguration

logger = logging.getLogger(__name__)


class ConfigurationData(BaseModel):

	# the external ID/URL of the source
	external_id: str
	source: KnowledgeSourceEnum = KnowledgeSourceEnum.quip

	# the Apple Directory group that can modify this configuration
	admin_group_dsid: Optional[int] = None

	# if `True`, a fine-tuned model will be created on the Knowledge
	fine_tune: bool = False

	# Chorus/Quip/Confluence-specific
	include_nested: bool = True

	# GitHub/Stashweb-specific
	branch_name: Optional[str] = None

	def custom_validate(self, values: dict[str, Any], previous: 'ConfigurationData' = None, dsid: int = None) -> None:
		"""
		Validates a dictionary of fields that match the fields in this class

		@param previous(ConfigurationData): the previous instance of this configuration
		@param dsid(int): the DSID of the user making the changes
		"""

		data: dict[str, Any] = values.get('data')

		if not data.get('external_id'):
			raise Exception('Missing required field')

		for field_name, value in data.items():

			if field_name.endswith('_template') and value != getattr(self, field_name):

				built_in_template: Template = Template(text=getattr(sys.modules[__name__], field_name.upper()))
				new_template: Template = Template(text=value)

				if len(built_in_template.fields) > len(new_template.fields):
					raise Exception(f'Your "{field_name}" template is missing fields that were in the original one')

			elif field_name == 'source' and value == KnowledgeSourceEnum.quip:

				data['external_id'] = data['external_id'].rsplit('/')[-1]

				# make sure we have access to the folder/document
				is_folder: bool = QuipClient.shared.get_is_folder(id=data['external_id'])

				if not is_folder:
					QuipClient.shared.get_thread(id=data['external_id'])

			elif field_name == 'source' and value == KnowledgeSourceEnum.confluence:

				# convert any display URL to one with `pageId`
				external_id: str = ConfluenceClient.shared.get_page_id_url(url=data['external_id'])
				external_id = external_id.split('?pageId=')[-1]

				if not Config.current.is_development and not ConfluenceClient.shared.get_has_access(id=external_id, dsid=dsid):
					raise Exception('You do not have access to this page')

			elif field_name == 'source' and value == KnowledgeSourceEnum.chorus:

				external_id: str = data['external_id']
				has_access: bool = True

				if 'page' in external_id:

					try:
						ChorusClient.shared.get_page(id=external_id.rsplit('/', 1)[-1])

					except HTTPError as error:

						has_access = False
						logger.warning(f'no access to Chorus page ({external_id=}, {dsid=}, {error=})')

				elif 'space' in external_id:

					try:
						ChorusClient.shared.get_space(id=external_id.rsplit('/', 1)[-1])

					except HTTPError as error:

						has_access = False
						logger.warning(f'no access to Chorus space ({external_id=}, {dsid=}, {error=})')

				if not has_access:

					raise Exception('AI needs access to your Chorus Space.\n\nPlease ask a Space owner to follow the steps for Chorus '
									'in https://quip-apple.com/Xb3bABDwjmv0, then paste the following in the '
									f'"One Time A3 Token" field:\n\n{ChorusClient.shared.get_a3_token()}')

				# make sure the user has access to the Space/page
				if not Config.current.is_development and  \
				   not ChorusClient.shared.get_has_access(id=external_id.rsplit('/', 1)[-1], dsid=dsid,
				   										  type='space' if 'space' in external_id else 'page', skip_sensitive=True):
					raise Exception('You do not have access to this Space/page or the page is marked as "Highly Sensitive"')

			elif field_name == 'source' and value == KnowledgeSourceEnum.github:

				# make sure we have access to the repo
				org, repository = GitHubClient.parse_repository_url(url=self.external_id)

				if not GitHubClient().get_installation_id(org=org, repo=repository):

					logger.error(f'Interlinked is not added to {org} {repository}')
					raise Exception(f'Please add Interlinked to your repo via https://github.pie.apple.com/github-apps/interlinked/installations/new')

				# make sure the user has access to the repo
				if not Config.current.is_development:

					opendirectory_username: str = AppleDirectoryClient.shared.get_opendirectory_username_for_dsid(dsid=dsid)

					if not opendirectory_username:
						raise Exception(f'Could not get your OpenDirectory user name')

					permission: str = GitHubClient().get_permission_for(user_name=opendirectory_username.replace('_', '-'), org=org,
																		repository=repository)

					if not permission or permission == 'none':
						raise Exception(f'Sorry! You do not have access to this repository')

			elif field_name == 'source' and value == KnowledgeSourceEnum.slack:

				if not previous:

					# set enabled to false by default until someone in the channel verifies access/intent
					values['enabled'] = False

					# post a message in the channel
					person = Person(dsid=dsid)
					by_line: str = f' by <@{person.slack_member_id}>' if person and person.slack_member_id else ''

					SlackClient.shared.send_message(channel=data['external_id'].rsplit('/')[-1],
													text=f':wave-d: Hi! I was added to this channel{by_line}.\n\n'
														 ':arrow_forward: I can start learning from new questions in this channel as '
														 'soon as you reply to this thread with *"I approve"*.')

			elif field_name == 'admin_group_dsid' and value:

				# if there was an admin group DSID and make sure the user is part of it
				if not Config.current.is_development and ((previous and previous.admin_group_dsid != value) or not previous):

					if previous:

						persons: list['Person'] = AppleDirectoryClient.shared.get_persons_for_group_dsid(dsid=previous.admin_group_dsid)

						if not any(person for person in persons if person.dsid == dsid):
							raise Exception(f'You must be part of {previous.admin_group_dsid} group to change the Admin Directory Group ID')

					# make sure the user is part of the new group
					persons: list['Person'] = AppleDirectoryClient.shared.get_persons_for_group_dsid(dsid=value)

					if not any(person for person in persons if person.dsid == dsid):
						raise Exception(f'You must be part of {previous.admin_group_dsid} group to modify this Knowledge')

					# make sure the group is flat (does not have nested groups)
					if AppleDirectoryClient.shared.get_is_group_has_nested(dsid=value):
						raise Exception(f'The group "{value}" has nested groups. For added security, we only support non-nested groups')

			elif field_name == 'group_dsid':

				# make sure the group is flat (does not have nested groups)
				if AppleDirectoryClient.shared.get_is_group_has_nested(dsid=value):
					raise Exception(f'The group "{value}" has nested groups. For added security, we only support non-nested groups')


class Configuration(BaseConfiguration):

	data: ConfigurationData


class CollectKnowledge(BaseWorkflow):

	WORKFLOW_NAME: str = 'knowledge'

	@classmethod
	def run(cls, configuration_id: int = None, **kwargs) -> None:
		"""
		Collects Knowledge from a given `Configuration` (set up in the UI) or `KnowledgeSource` (GitHub, Quip, etc. via the CLI)
		"""

		from_: str = kwargs.get('from_')
		configuration: Configuration = None
		source: KnowledgeSourceEnum = KnowledgeSourceEnum.from_raw(raw=from_) if from_ else None

		# used for collecting knowledge via the CLI
		# e.g. `interlinked knowledge --from="TxCjAJRACNlJ"`
		if from_:

			# if this is a file path, use the full path
			if source == KnowledgeSourceEnum.file:
				from_ = str(Path(from_).resolve())

			database_configuration, _ = DatabaseConfiguration.get_or_create(workflow_name=cls.WORKFLOW_NAME, group_dsid=-1,
																			data=ConfigurationData(external_id=from_, source=source).model_dump())
			configuration = Configuration(**database_configuration.model_dump())

		# passed via code (automatically called in `tasks`)
		elif configuration_id is not None:

			configuration = Configuration(**DatabaseConfiguration.get_or_none(id=configuration_id).model_dump())

			if not configuration:
				raise Exception(f'configuration not found ({configuration_id=})')

		else:
			raise UserError('Please pass either `--from="…"`, or a `configuration_id`.')

		# knowledge sources to keep (that were created below or existing ones)
		knowledge_sources: list[KnowledgeSource] = []

		# Quip
		if configuration.data.source == KnowledgeSourceEnum.quip:

			external_id: str = configuration.data.external_id
			external_id = external_id.rsplit('/', 1)[-1]

			is_folder: bool = QuipClient.shared.get_is_folder(id=external_id)
			children: list[Thread|Folder] = None

			# if this is a folder, get the documents within the folder
			children_external_ids: list[str] = []

			if is_folder:

				children = QuipClient.shared.get_folder(id=external_id).children

				# sort, so folders are last
				children = sorted(children, key=lambda child: isinstance(child, Folder))

			else:
				children = [QuipClient.shared.get_thread(id=external_id)]

			def _learn_from_threads(children: list[Thread|Folder], configuration: Configuration):

				for thread in children:

					# if this is a folder, process all of the children
					if isinstance(thread, Folder):

						if not configuration.data.include_nested:

							logger.info(f'skipping folder since `include_nested` is off (nested_id={thread.id}, nested_title={thread.title!r})…')
							continue

						_learn_from_threads(children=thread.children, configuration=configuration)
						continue

					if thread.type != 'document':

						logger.info(f'skipping non-document thread (id={thread.id}, title={thread.title!r}, type={thread.type})…')
						continue

					# skip pages where the creator of the configuration does not have access to
					if configuration.created_by and not Config.current.is_development and  \
					   not QuipClient.shared.get_has_access(id=thread.id, dsid=configuration.created_by):

						logger.info(f'skipping restricted Quip doc… ({thread.id=}, {configuration.id=})')
						continue

					# look up or create a KnowledgeSource for the `thread`
					# note: Quip IDs can change. for example, opening `quip-apple.com/mkx8Ajl4UlbV` returns ID `TPd9AAEsmRJ`
					# this is mitigated by using `thread.id`
					knowledge_source, is_new = KnowledgeSource.get_or_create(external_id=thread.id, source=configuration.data.source,
																			 configuration_id=configuration.id)
					knowledge_sources.append(knowledge_source)

					# if we already have the source stored, check if the hash changed
					# quip's html changes every request (where some tag attributes may be in a different location)
					# so, we use datetime instead
					content_hash: str = Utilities.get_sha256_hash(value=(thread.updated_at or thread.created_at).isoformat())

					if not is_new and knowledge_source.content_hash == content_hash:

						logger.info(f'skipping Quip doc. no changes (title={thread.title!r})')
						continue

					# generate a hash
					knowledge_source.name = thread.title
					knowledge_source.content_hash = content_hash
					knowledge_source.external_created_at = thread.created_at
					knowledge_source.external_modified_at = thread.updated_at
					knowledge_source.save()

					section: Section = QuipParser.get_section_for_html(content=thread.html)
					sections: list[Section] = section.get_all()

					logger.section(f'learning from Quip doc (id={thread.id}, title={thread.title!r}, sections={len(sections)})…')

					# list of knowledge that is either new or same
					knowledges_to_keep: list[Knowledge] = AI.learn(from_=section, knowledge_source_id=knowledge_source.id)

					# delete all outdated knowledge
					Knowledge.delete_all(knowledge_source_ids=[knowledge_source.id], keep=knowledges_to_keep)

					# generate examples prompts
					cls.populate_examples_for_knowledges(knowledges=knowledges_to_keep)

			_learn_from_threads(children=children, configuration=configuration)

		# Confluence
		elif configuration.data.source == KnowledgeSourceEnum.confluence:

			external_id: str = configuration.data.external_id
			external_id = external_id.split('?pageId=')[-1]

			_page: Page = ConfluenceClient.shared.get_page(id=external_id)
			pages: list[Page] = [_page]

			if configuration.data.include_nested:
				pages += _page.children

			for page in pages:

				# skip pages where the creator of the configuration does not have access to
				if configuration.created_by and not Config.current.is_development and  \
				   not ConfluenceClient.shared.get_has_access(id=page.id, dsid=configuration.created_by):

					logger.info(f'skipping restricted Confluence page… ({page.id=}, {configuration.id=})')
					continue

				# look up or create a KnowledgeSource for the `thread`
				knowledge_source, is_new = KnowledgeSource.get_or_create(external_id=page.url, source=configuration.data.source,
																		 configuration_id=configuration.id)
				knowledge_sources.append(knowledge_source)

				# if we already have the source stored, check if the hash changed
				content_hash: str = Utilities.get_sha256_hash(value=page.html)

				if not is_new and knowledge_source.content_hash == content_hash:

					logger.info(f'skipping Confluence page. no changes (title={page.title!r})')
					continue

				# generate a hash
				knowledge_source.content_hash = content_hash
				knowledge_source.name = page.title
				knowledge_source.external_created_at = page.created_at
				knowledge_source.external_modified_at = page.last_updated_at
				knowledge_source.save()

				section: Section = ConfluenceParser.get_section_for_html(content=page.html, page=page)
				sections: list[Section] = section.get_all()

				logger.section(f'learning from Confluence page (id={page.id}, title={page.title!r}, sections={len(sections)})…')

				# list of knowledge that is either new or same
				knowledges_to_keep: list[Knowledge] = AI.learn(from_=section, knowledge_source_id=knowledge_source.id)

				# delete all outdated knowledge
				Knowledge.delete_all(knowledge_source_ids=[knowledge_source.id], keep=knowledges_to_keep)

				# generate examples prompts
				cls.populate_examples_for_knowledges(knowledges=knowledges_to_keep)

		# Chorus
		elif configuration.data.source == KnowledgeSourceEnum.chorus:

			external_id: str = configuration.data.external_id.rsplit('/')[-1]
			pages: list[Page] = []

			if '/page' in configuration.data.external_id:
				pages = [ChorusClient.shared.get_page(id=external_id)]

			else:
				pages = ChorusClient.shared.get_space(id=external_id).pages

			for page in pages:

				# skip pages where the creator of the configuration does not have access to
				if configuration.created_by and not Config.current.is_development and  \
					not ChorusClient.shared.get_has_access(id=page.id, dsid=configuration.created_by, type='page', skip_sensitive=True):

					logger.info(f'skipping sensitive Chorus page… ({page.id=}, {configuration.id=})')
					continue

				# look up or create a KnowledgeSource for the `thread`
				knowledge_source, is_new = KnowledgeSource.get_or_create(external_id=str(page.id), source=configuration.data.source,
																		 configuration_id=configuration.id)
				knowledge_sources.append(knowledge_source)

				# if we already have the source stored, check if the hash changed
				content_hash: str = Utilities.get_sha256_hash(value=page.html)

				if not is_new and knowledge_source.content_hash == content_hash:

					logger.info(f'skipping Chorus page. no changes (title={page.title!r})')
					continue

				# generate a hash
				knowledge_source.name = page.title
				knowledge_source.content_hash = content_hash
				knowledge_source.external_created_at = page.created_at
				knowledge_source.external_modified_at = page.changed_at
				knowledge_source.save()

				section: Section = ChorusParser.get_section_for_html(content=page.html)
				sections: list[Section] = section.get_all()

				logger.section(f'learning from Chorus page (id={page.id}, title={page.title!r}, sections={len(sections)})…')

				# list of knowledge that is either new or same
				knowledges_to_keep: list[Knowledge] = AI.learn(from_=section, knowledge_source_id=knowledge_source.id)

				# delete all outdated knowledge
				Knowledge.delete_all(knowledge_source_ids=[knowledge_source.id], keep=knowledges_to_keep)

				# generate examples prompts
				cls.populate_examples_for_knowledges(knowledges=knowledges_to_keep)

		# StackOverflow
		elif configuration.data.source == KnowledgeSourceEnum.stackoverflow:

			external_id: str = configuration.data.external_id
			article_ids: list[int] = StackOverflowClient.shared.get_articles_ids_for_tags(tags=external_id.split())

			for article_id in article_ids:

				article: Article = StackOverflowClient.shared.get_article(id=article_id)

				# look up or create a KnowledgeSource for the `article`
				knowledge_source, is_new = KnowledgeSource.get_or_create(external_id=f'article:{article.id}', source=configuration.data.source,
																		 configuration_id=configuration.id)
				knowledge_sources.append(knowledge_source)

				# if we already have the source stored, check if the hash changed
				content_hash: str = Utilities.get_sha256_hash(value=article.body)

				if not is_new and knowledge_source.content_hash == content_hash:

					logger.info('skipping knowledge source. no changes.')
					continue

				# generate a hash
				knowledge_source.name = article.title
				knowledge_source.content_hash = content_hash
				knowledge_source.external_created_at = article.created_at
				knowledge_source.external_modified_at = article.last_activity_at
				knowledge_source.save()

				section: Section = StackOverflowParser.get_section_for_html(content=article.body, article=article)
				logger.section(f'learning from StackOverflow article (id={article.id}, title={article.title!r}, sections={len(section.get_all())})…')

				# list of knowledge that is either new or same
				knowledges_to_keep: list[Knowledge] = AI.learn(from_=section, knowledge_source_id=knowledge_source.id)

				# delete all outdated knowledge
				Knowledge.delete_all(knowledge_source_ids=[knowledge_source.id], keep=knowledges_to_keep)

				# generate examples prompts
				cls.populate_examples_for_knowledges(knowledges=knowledges_to_keep)

		# Box
		elif configuration.data.source == KnowledgeSourceEnum.box:

			external_id: str = configuration.data.external_id
			external_id = external_id.rsplit('/', 1)[-1]

			is_folder: bool = BoxClient.shared.get_is_folder(id=external_id)
			threads: list[Thread] = None

			# if this is a folder, get the documents within the folder
			if is_folder:
				threads = BoxClient.shared.get_folder(id=external_id).flattened_threads

			else:
				threads = [BoxClient.shared.get_thread(id=external_id)]

			for thread in threads:

				if thread.type != 'document':

					logger.info(f'skipping non-document thread (id={thread.id}, title={thread.title!r}, type={thread.type})…')
					continue

				# look up or create a KnowledgeSource for the `thread`
				knowledge_source, is_new = KnowledgeSource.get_or_create(external_id=thread.id, source=configuration.data.source,
																		 configuration_id=configuration.id)
				knowledge_sources.append(knowledge_source)

				# if we already have the source stored, check if the hash changed
				content_hash: str = Utilities.get_sha256_hash(value=thread.html)

				if not is_new and knowledge_source.content_hash == content_hash:

					logger.info('skipping knowledge source. no changes.')
					continue

				# generate a hash
				knowledge_source.content_hash = content_hash
				knowledge_source.save()

				section: Section = HTMLParser.get_section_for_html(content=thread.html)
				sections: list[Section] = section.get_all()

				logger.section(f'learning from Box doc (id={thread.id}, title={thread.title!r}, sections={len(sections)})…')

				# list of knowledge that is either new or same
				knowledges_to_keep: list[Knowledge] = AI.learn(from_=section, knowledge_source_id=knowledge_source.id)

				# delete all outdated knowledge
				Knowledge.delete_all(knowledge_source_ids=[knowledge_source.id], keep=knowledges_to_keep)

				# generate examples prompts
				cls.populate_examples_for_knowledges(knowledges=knowledges_to_keep)

		# GitHub
		elif configuration.data.source == KnowledgeSourceEnum.github:

			external_id: str = configuration.data.external_id

			org, repository = GitHubClient.parse_repository_url(url=external_id)
			url_parsed: Any = urlparse(external_id if external_id.startswith('http') else f'https://{external_id}')

			github_client: GitHubClient = GitHubClient()

			branch_name: str = configuration.data.branch_name or 'main'
			files: list[dict[str, Any]] = github_client.get_files(org=org, repository=repository, file_extensions=['rst', 'md'],
																  branch=branch_name)

			# each file is a KnowledgeSource
			for file in files:

				# the path to the file (e.g. `interlinked/…/….md`)
				file_path: str = file.get('path')

				logger.section(f'learning from GitHub file (file_path={file_path})…')

				# look up or create a KnowledgeSource for the file
				external_id: str = f'{org}/{repository}/blob/{branch_name}/{file_path}'
				knowledge_source, is_new = KnowledgeSource.get_or_create(external_id=f'https://{url_parsed.netloc}/{external_id}',
																		 source=configuration.data.source,
																		 configuration_id=configuration.id)
				knowledge_sources.append(knowledge_source)

				# if we already have the source stored, check if the hash changed
				content_hash: str = file.get('sha')

				if not is_new and knowledge_source.content_hash == content_hash:

					logger.info('skipping knowledge source. no changes.')
					continue

				# save the hash from GitHub
				knowledge_source.content_hash = content_hash
				knowledge_source.name = file_path
				knowledge_source.save()

				section: Section = None
				file_content: str = github_client.get_file_content(org=org, repository=repository, path=file_path)

				if file_path.endswith('.rst'):
					section = RestructuredParser.get_section_for_restructured(content=file_content)

				elif file_path.endswith('.md'):
					section = MarkdownParser.get_section_for_markdown(content=file_content)

				else:
					raise NotImplementedError()

				# list of knowledge that is either new or same
				knowledges_to_keep: list[Knowledge] = AI.learn(from_=section, knowledge_source_id=knowledge_source.id)

				# delete all outdated knowledge
				Knowledge.delete_all(knowledge_source_ids=[knowledge_source.id], keep=knowledges_to_keep)

				# generate examples prompts
				cls.populate_examples_for_knowledges(knowledges=knowledges_to_keep)

		# Slack
		elif configuration.data.source == KnowledgeSourceEnum.slack:

			now: datetime = datetime.now()
			days: int = 0 if Config.current.is_development else 2

			# find all threads whose last message was over a day ago
			threads: list[Thread] = Thread.select().join(Message).  \
										   where(Thread.configuration_id == configuration.id, Thread.converted_at.is_(None),
										   		 Message.created_at <= now - timedelta(days=days)).  \
										   distinct().all()

			for thread in threads:

				# TODO: this should be part of the query above instead
				if not thread.messages[-1].created_at <= now - timedelta(days=days):
					continue

				messages_text: str = '\n---\n'.join([message.raw['text'] for message in thread.messages])

				knowledge_source, is_new = KnowledgeSource.get_or_create(external_id=thread.external_id, source=configuration.data.source,
																		 configuration_id=configuration.id)

				# if we already have the source stored, check if the hash changed
				# should never happen
				content_hash: str = Utilities.get_sha256_hash(value=messages_text)

				if not is_new and knowledge_source.content_hash == content_hash:

					logger.info('skipping Slack thread. no changes.')
					continue

				# generate a hash
				knowledge_source.name = f'{thread.messages[0].raw["text"][:50]}…'
				knowledge_source.content_hash = content_hash
				knowledge_source.external_created_at = thread.messages[-1].created_at
				knowledge_source.save()

				# summarize the thread and convert it to a list of questions and answers
				observation: Observation = AI.ask(prompt={'messages': messages_text}, template=THREAD_INFO_TEMPLATE)

				if observation.question_count:

					observation = observation.ask(template=THREAD_TO_QA_TEMPLATE)

					if observation.options:

						options: list[str] = [option.replace(' Answer: ', ' ') for option in observation.options if '?' in option]

						logger.section(f'learning from Slack thread (id={thread.id}, questions={len(options)})…')

						# convert each question/answer into a section
						for option in options:

							question, answer = option.rsplit('?', 1)
							section: Section = Section(title=question, content=[answer])

							AI.learn(from_=section, knowledge_source_id=knowledge_source.id)

				thread.converted_at = now
				thread.save()

			# return early, so no knowledge source is deleted
			return

		# files
		elif configuration.data.source == KnowledgeSourceEnum.file:

			knowledge_source, is_new = KnowledgeSource.get_or_create(external_id=configuration.data.external_id, source=configuration.data.source,
																	 configuration_id=configuration.id)

			# if we already have the source stored, check if the hash changed
			# should never happen
			content_hash: str = None

			with open(configuration.data.external_id, 'r') as file:
				content_hash = Utilities.get_sha256_hash(value=file.read())

			if not is_new and knowledge_source.content_hash == content_hash:

				logger.info('skipping file. no changes.')
				return

			# generate a hash
			knowledge_source.name = from_
			knowledge_source.content_hash = content_hash
			knowledge_source.save()

			knowledge_sources.append(knowledge_source)

			from_: str|Section = None

			# currently, a hardcoded check for DocBook
			if configuration.data.external_id.endswith('.xml'):
				from_ = DocBookParser.get_section_for_docbook(content=open(configuration.data.external_id, 'r').read())

			else:
				from_ = configuration.data.external_id

			# list of knowledge that is either new or same
			knowledges_to_keep: list[Knowledge] = AI.learn(from_=from_, knowledge_source_id=knowledge_source.id)

			# delete all outdated knowledge
			Knowledge.delete_all(knowledge_source_ids=[knowledge_source.id], keep=knowledges_to_keep)

			# generate examples prompts
			cls.populate_examples_for_knowledges(knowledges=knowledges_to_keep)

		else:
			raise Exception(f'unsupported source ({configuration.data.source})')

		# delete any knowledge source that was deleted in the external source
		KnowledgeSource.delete().where(KnowledgeSource.configuration_id == configuration.id,
									   KnowledgeSource.id.not_in([knowledge_source.id for knowledge_source in knowledge_sources])).execute()

	@classmethod
	def handle_api(cls, path: str, data: dict[str, str], request: 'Request') -> dict:

		# check if the user has access to this knowledge
		from interlinked.ui.app import get_current_user

		external_id: str = data.get('external_id')
		knowledge_source_enum: str = data.get('knowledge_source_enum')

		dsid: int = get_current_user(request=request).dsid

		if knowledge_source_enum == KnowledgeSourceEnum.quip:

			if not Config.current.is_development and not QuipClient.shared.get_has_access(id=external_id, dsid=dsid):
				raise Exception('You do not have access to this document')

			is_folder: bool = QuipClient.shared.get_is_folder(id=external_id)

			if is_folder:
				raise Exception('View Content is not available for Quip folders')

			thread: Thread = QuipClient.shared.get_thread(id=external_id)
			return HTMLParser.get_section_for_html(content=thread.html).model_dump(exclude={'parent'})

		elif knowledge_source_enum == KnowledgeSourceEnum.confluence:

			external_id = ConfluenceClient.shared.get_page_id_url(url=external_id)
			external_id = external_id.split('?pageId=')[-1]

			if not Config.current.is_development and not ConfluenceClient.shared.get_has_access(id=external_id, dsid=dsid):
				raise Exception('You do not have access to this page')

			page: Page = ConfluenceClient.shared.get_page(id=external_id)
			return ConfluenceParser.get_section_for_html(content=page.html, page=page).model_dump(exclude={'parent'})

	@classmethod
	def handle_slack_message(cls, text: str, channel_id: str, thread_ts: str, is_reply: bool,
							 sender: Person, configuration: DatabaseConfiguration) -> None:
		"""
		Learns from a Slack message
		"""

		# if the configuration is not enabled, check if the reply is for approving/enabling it
		if not configuration.enabled:

			if 'i approve' in text.lower():

				# enable, then reply to the thread
				# TODO: add a check so we only look for replies in the same thread
				configuration.enabled = True
				configuration.save()

				logger.info(f'approving channel: {channel_id}')

				by_line: str = f', <@{sender.slack_member_id}>' if sender and sender.slack_member_id else ''
				SlackClient.shared.send_message(channel=channel_id, text=f':yay-d: Awesome! Thanks for approving{by_line}!', thread_ts=thread_ts)

			return

		thread: Thread = None

		# if this is a reply, look up the thread
		if is_reply:

			thread = Thread.get_or_none(configuration_id=configuration.id, external_id=thread_ts, source=ThreadSource.slack)

			if not thread:

				logger.info(f'ignoring reply to an unknown thread ({thread_ts=}, {channel_id=})…')
				return
		else:
			thread, _ = Thread.get_or_create(configuration_id=configuration.id, external_id=thread_ts, source=ThreadSource.slack)

		Message.create(thread_id=thread.id, raw={'text': text})

	""" Functions """

	@classmethod
	def populate_examples_for_knowledges(cls, knowledges: list[Knowledge]):
		"""
		Creates example prompts for a given knowledge

		@prompt knowledge(Knowledge): a knowledge
		@return (list): example prompts (e.g. "How do I do …?")
		"""

		if not knowledges:
			return

		# skip knowledge without much content
		knowledges = [knowledge for knowledge in knowledges if len(knowledge.content.split()) > 50]

		example_count: int = min(len(knowledges), 4)

		if not example_count:
			return

		logger.info(f'generating {example_count} examples…')

		for knowledge in random.sample(knowledges, example_count):

			examples: list[str] = AI.ask(prompt={'knowledge_content': knowledge.content}, template=EXAMPLES_TEMPLATE,
										 client=AJAXClient(model_name='afm-text-30b-instruct-latest')).options or []

			# filter knowledge that doesn't have IDs or date/time
			# since it may not be relevant to show the user example questions
			# with a radar ID from a random document
			examples = [example for example in examples if not re.findall(r'(\d{4,}|(Jan|Feb|Mar|Apr|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\w+|\:\d+pm|:\d+am|in the|of the|for the|on the|when|\btime\b|\bdate\b)', example, flags=re.IGNORECASE)]
			examples = [example for example in examples if 'provided' not in example]

			# skip examples that contain questions like `can you help me with [project name]?`
			examples = [example for example in examples if '[' not in example]

			# some models may get confused (e.g. say `Hi`)
			examples = [example for example in examples if not example.startswith(('Hi', 'Hey', 'Hello'))]

			# if any example is suffixed with an answer, remove it
			# e.g. `What is __? Answer`
			# unless the example has multiple questions (e.g. `What is __? And how does __?`)
			examples = [f'{example.split("?")[0]}?' if '?' in example else example for example in examples]

			# remove `the ___ project` -> `___`
			# since AI may not currently know if `___` is actually a project or something else
			# e.g. `What is the ___ project?` -> `What is ___?`
			# TODO: does not work if there are multiple words between `the` and `project`
			examples = [re.sub(r'\bthe\s+(\w+)\s+project\b', r'\1', example, flags=re.IGNORECASE) for example in examples]

			# use apostrophes
			examples = [example.replace('What is ', 'What’s ') for example in examples]

			# don't assume pronouns
			examples = [re.sub(r'\b(he|she)\b', 'they', example, flags=re.IGNORECASE) for example in examples]
			examples = [re.sub(r'\b(her|him)\b', 'them', example, flags=re.IGNORECASE) for example in examples]
			examples = [re.sub(r'\b(his|hers)\b', 'theirs', example, flags=re.IGNORECASE) for example in examples]

			# remove markdown from each example
			# e.g. `**text**` -> `text` or `**text` -> `text` (the latter can happen because of `?` splitting above)
			examples = [re.sub(r'\*\*(.*?)(?:\*\*|)', r'\1', example) for example in examples]
			examples = [example.replace('\\_', '_') for example in examples]

			# replace "Can you …"
			# e.g. "Can you give me an example of …" -> "Give me an example of …"
			examples = [re.sub(r'Can you (.*?)\?', r'\1', example).strip() for example in examples]

			# e.g. "Provide me a …" -> "Give me a …"
			examples = [re.sub(r'^provide (.*?)\?', r'Give \1', example).strip() for example in examples]
			examples = [example for example in examples if example]

			# ensure the first word is capitalized
			for example_index, example in enumerate(examples):

				if example[0].islower():

					example_split: list[str] = example.split()
					examples[example_index] = f'{example_split[0].title()} {" ".join(example_split[1:])}'

			# remove any periods
			examples = [example.strip('.') for example in examples]

			# skip anything that is just two words or less
			examples = [example for example in examples if len(example.split()) > 2]

			knowledge.examples = examples
			knowledge.save()


if __name__ == '__main__':

	# quip
	external_id, source = '2CCuOdybq1dH', KnowledgeSourceEnum.quip

	# github
	# external_id, source = 'https://github.pie.apple.com/clopez1/coreflow', KnowledgeSourceEnum.github

	# stackoverflow
	# external_id, source = 'help-rubix', KnowledgeSourceEnum.stackoverflow

	# confluence
	# external_id, source = 'https://confluence.sd.apple.com/pages/viewpage.action?pageId=892572254', KnowledgeSourceEnum.confluence

	# chorus
	# external_id, source = 'https://chorus.apple.com/space/526694', KnowledgeSourceEnum.chorus

	# box
	# external_id, source = '1440887482986', KnowledgeSourceEnum.box

	# slack
	# external_id, source = 'apple-test.enterprise.slack.com/archives/C069HMW2B6Y', KnowledgeSourceEnum.slack

	configuration_data: ConfigurationData = ConfigurationData(external_id=external_id, source=source)
	configuration, is_new = DatabaseConfiguration.get_or_create(workflow_name='knowledge', group_dsid=-1, data=configuration_data.model_dump())
	configuration.run()
