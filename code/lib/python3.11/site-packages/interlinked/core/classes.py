import json
import logging
from time import sleep
from typing import Any
from datetime import datetime
from dataclasses import dataclass
from urllib.error import URLError
from http.client import RemoteDisconnected
from radarclient import Radar, Component, KeywordAssociation, DiagnosisEntry,  \
                        DictionaryBasedModel, CollectionProperty, DescriptionEntry,  \
                        Attachment, OtherRelatedItem, UnsuccessfulResponseException,  \
                        response_code_is_success

from interlinked.core.config import Config
from interlinked.core.utilities import Utilities
from interlinked.core.clients.appledirectoryclient import AppleDirectoryClient, Person

logger = logging.getLogger(__name__)


class UnsupportedError(Exception):
    pass


class BaseItem:

    TYPE_RADAR: int = 0
    TYPE_OAKDALE_TICKET: int = 1

    title: str = None

    @property
    def display_title(self) -> str:
        return self.title

    @property
    def entries(self):
        raise NotImplementedError()

    @property
    def attachments(self):
        raise NotImplementedError()


class ExternalItem(BaseItem):
    """
    Represents an item from another system (e.g. Radar)
    """

    STATE_ANALYZE: str = 'Analyze'
    STATE_INTEGRATE: str = 'Integrate'
    STATE_BUILD: str = 'Build'
    STATE_VERIFY: str = 'Verify'
    STATE_CLOSED: str = 'Closed'

    RESOLUTION_UNRESOLVED: str = 'Unresolved'
    RESOLUTION_SOFTWARE_CHANGED: str = 'Software Changed'
    RESOLUTION_DOCUMENTATION_CHANGED: str = 'Documentation Changed'
    RESOLUTION_DATA_CHANGED: str = 'Data Changed'
    RESOLUTION_HARDWARE_CHANGED: str = 'Hardware Changed'
    RESOLUTION_CONFIGURATION_CHANGED: str = 'Configuration Changed'
    RESOLUTION_FEATURE_REMOVED: str = 'Feature Removed'
    RESOLUTION_DUPLICATE: str = 'Duplicate'
    RESOLUTION_CANNOT_REPRODUCE: str = 'Cannot Reproduce'
    RESOLUTION_BEHAVES_CORRECTLY: str = 'Behaves Correctly'
    RESOLUTION_NTBF: str = 'Not To Be Fixed'
    RESOLUTION_3RD_PARTY_TO_RESOLVE: str = '3rd Party To Resolve'
    RESOLUTION_FIRMWARE_CHANGED: str = 'Firmware Changed'
    RESOLUTION_VENDOR_DISQUALIFIED: str = 'Vendor Disqualified'
    RESOLUTION_PROCESS_CHANGED: str = 'Process Changed'
    RESOLUTION_INSUFFICIENT_INFORMATION: str = 'Insufficient Information'
    RESOLUTION_ITEM_COMPLETED: str = 'Item Completed'
    RESOLUTION_NOT_APPLICABLE: str = 'Not Applicable'

    RESOLUTIONS_FIXED: list[str] = [

        RESOLUTION_SOFTWARE_CHANGED,
        RESOLUTION_DOCUMENTATION_CHANGED,
        RESOLUTION_DATA_CHANGED,
        RESOLUTION_HARDWARE_CHANGED,
        RESOLUTION_CONFIGURATION_CHANGED,
        RESOLUTION_FEATURE_REMOVED,
        RESOLUTION_FIRMWARE_CHANGED,
        RESOLUTION_PROCESS_CHANGED,
        RESOLUTION_ITEM_COMPLETED,
    ]

    CLASSIFICATION_SECURITY: str = 'Security'
    CLASSIFICATION_CHD: str = 'Crash/Hang/Data Loss'
    CLASSIFICATION_POWER: str = 'Power'
    CLASSIFICATION_PERFORMANCE: str = 'Performance'
    CLASSIFICATION_UI_USABIILITY: str = 'UI/Usability'
    CLASSIFICATION_SERIOUS_BUG: str = 'Serious Bug'
    CLASSIFICATION_OTHER_BUG: str = 'Other Bug'
    CLASSIFICATION_FEATURE: str = 'Feature (New)'
    CLASSIFICATION_ENHANCEMENT: str = 'Enhancement'
    CLASSIFICATION_TASK: str = 'Task'

    PRODUCT_SECURITY_TYPE_NOT_SET = 'Not Set'
    PRODUCT_SECURITY_TYPE_NONE = 'None'
    PRODUCT_SECURITY_TYPE_MITIGATION = 'Mitigation'
    PRODUCT_SECURITY_TYPE_EXPOSURE = 'Exposure'

    title: str = ''
    product_security: dict[str, Any] = None
    vulnerability_classification: dict[str, Any] = None

    changed_key_values: dict[str, Any]
    updated_product_security: dict[str, Any]
    updated_vulnerability_classification: dict[str, Any]

    def __init__(self, item: Any, type: int):

        self.type = type

        self.product_security = {}
        self.vulnerability_classification = {}

        self.changed_key_values = {}
        self.added_reporters = []
        self.changed_reporters = {}

        self.updated_product_security = {}
        self.updated_vulnerability_classification = {}

        self.added_references = []
        self.removed_references = []

        if type not in {self.TYPE_RADAR}:
            raise UnsupportedError()

        self.item = item
        self.raw_id = item.id

        if type == self.TYPE_RADAR:
            self.external_id = f'rdar://{item.id}'

        else:
            self.external_id = item.id

        # self.last_updated = self.last_modified
        # self.created_at: datetime = self.item.createdAt
        # self.originator = self.item.originator

        if self.type == self.TYPE_RADAR:

            # it is not always guaranteed that productSecurity will be set
            # this happens when the item is not fully fetched (to save time/API calls)
            self.product_security = getattr(item, 'productSecurity', {})
            self.vulnerability_classification = self.product_security.get('vulnerabilityClassification', {})

    @classmethod
    def create(cls, type, processor, title: str, description: str, **kwargs):
        """
        Creates a new item

        @param type(str): `TYPE_RADAR` or `TYPE_OAKDALE_TICKET`
        @param processor(Processor): an instance of a Processor
        @param title(str): item title
        @param description(str): item description
        @param ...: args vary based on type
        @return: TODO
        """

        if type == cls.TYPE_RADAR:

            data: dict = {

                'title': title,
                'description': description,
            }

            # add 'data' from kwargs (if available)
            data = {**data, **kwargs['data']} if 'data' in kwargs else data

            if 'component' not in data:

                # auto add the team component to the radar
                data['component'] = {'name': RADAR_SCREENER_COMPONENT_NAME, 'version': RADAR_SCREENER_COMPONENT_VERSION}

            if 'classification' not in data:
                data['classification'] = RADAR_CLASSIFICATION_SECURITY

            try:
                return processor.create_radar_from_dictionary(dictionary=data)

            except Exception as exception:
                logger.error(f'could not create radar. exception: {exception}', exc_info=True)

    @classmethod
    def get_url_for_external_items(cls, external_items: list['ExternalItem']) -> str:
        """
        Converts a list of `ExternalItem` to one link

        e.g. `[rdar://123456789, rdar://987654321]` -> `rdar://123456789&987654321`
        """

        if not external_items:
            return ''

        scheme: str = f'{external_items[0].external_id.rsplit("/", 1)[0]}/'
        url: str = '&'.join([str(external_item.external_id.removeprefix(scheme)) for external_item in external_items])
        return f'{scheme}{url}'

    def clone(self, **kwargs) -> 'ExternalItem':
        """
        [Radar] Clones this item

        @return (ExternalItem): the new cloned item
        """

        if self.type != ExternalItem.TYPE_RADAR:
            raise UnsupportedError()

        return ExternalItem(item=RadarClient.shared.clone_radar(original_radar_id=self.external_id, **kwargs), type=self.type)

    @property
    def title(self) -> str:
        return getattr(self.item, 'title', None)

    @property
    def created_at(self) -> datetime:

        if self.type == ExternalItem.TYPE_RADAR:
            return getattr(self.item, 'createdAt', None)

        raise UnsupportedError()

    @property
    def keyword_associations(self) -> list:
        """
        [Radar] Returns this item's keyword associations

        @return (list): a list of keyword associations
        """

        if self.type != self.TYPE_RADAR:
            raise UnsupportedError()

        if not hasattr(self, '_keyword_associations'):

            try:
                self._keyword_associations = self.item.keyword_associations()

            except UnsuccessfulResponseException as exception:

                # try again (sometimes, network issues)
                if exception.code == 502:

                    sleep(1)
                    self._keyword_associations = self.item.keyword_associations()

        return self._keyword_associations

    @property
    def is_umbrella(self) -> bool:
        """
        [Radar] checks if this radar is an umbrella by checking
        the title for an umbrella emoji

        umbrella: a radar with subtasks/sub-radars

        @return (bool): radar is an umbrella
        """

        return '☔️' in self.title or '☂️' in self.title

    @property
    def is_security(self) -> bool:
        """
        [Radar] Checks if the classification of this is 'Security'

        """

        return self.classification == RADAR_CLASSIFICATION_SECURITY

    @property
    def is_verify(self) -> bool:
        """
        This *only* works on 'Build', 'Verify' or 'Closed' | '* Changed' or '* Completed'
        This does *not* work on dupes and is not intended to

        @return (bool): True if needs to be verified
        """

        return (self.state in [cls.STATE_BUILD, cls.STATE_VERIFY, cls.STATE_CLOSED]) and \
            ('Changed' in self.resolution or 'Completed' in self.resolution)

    @property
    def is_duplicate(self) -> bool:
        """
        [Radar, Oakdale Ticket] checks if this is a duplicate of another issue
        """
        return self.item.resolution == RESOLUTION_DUPLICATE

    @property
    def key_values(self) -> list['KeyValuePair']:
        """
        [Radar, Oakdale Ticket] returns the key/value fields of this item

        @return (dict): key/value fields
        """

        if self.type != self.TYPE_RADAR:
            raise UnsupportedError()

        from interlinked.core.clients.customradarclient import RadarClient

        if not hasattr(self, '_key_values'):
            
            self._key_values = RadarClient.shared.key_values_for_radar_id(radar_id=self.item.id)
            self._key_values.load_pairs_for_keys()
            self._key_values = self._key_values.loaded_pairs()

        return self._key_values

    @property
    def impact_summary(self) -> str:
        """
        [Radar] returns the impact summary text of this item

        @return (str): impact summary
        """

        if self.type != self.TYPE_RADAR:
            raise UnsupportedError()

        if not hasattr(self, '_impact_summary'):
            self._impact_summary = self.key_values.get('product-security-impact')

        return self._impact_summary

    @property
    def impact_description(self) -> str:
        """
        [Radar] returns the impact description text of this item

        @return (str): impact description
        """

        if self.type != self.TYPE_RADAR:
            raise UnsupportedError()

        if not hasattr(self, '_impact_description'):
            self._impact_description = self.key_values.get('product-security-description')

        return self._impact_description

    def get_keyword_associations(self, daw_cookie: str = None) -> list:
        """
        [Radar] returns KeywordAssociations using DAW cookie

        @param daw_cookie(str): if passed, the changes will be saved on behalf of the DAW cookie owner
        @return (list): a list of keyword associations
        """

        if self.type != self.TYPE_RADAR:
            raise UnsupportedError()

        if daw_cookie is not None:
            object.__setattr__(self.item,
                               'client', self.processor.get_radar_client_for_daw_cookie(daw_cookie=daw_cookie))

        return self.item.keyword_associations()

    @property
    def keywords(self) -> list:
        """
        [Radar, Oakdale Ticket] returns a list of keywords
        """

        if not hasattr(self, '_keywords'):
            self._keywords = self.item.keywords()

        return self._keywords

    @property
    def keyword_ids(self) -> set[int]:
        """
        [Radar, Oakdale Ticket] Returns a set of keywords IDs
        """

        if not hasattr(self, '_keyword_ids'):
            self._keyword_ids = {keyword.id for keyword in self.keywords}

        return self._keyword_ids

    @property
    def attachments(self):
        """
        [Radar] Returns attachments in this item
        """

        if self.type != ExternalItem.TYPE_RADAR:
            raise UnsupportedError()

        try:
            return self.item.attachments.items()

        except URLError as urlerror:

            # try again
            return self.item.attachments.items()

    @property
    def component(self) -> Component:
        """
        [Radar] returns the Component for this item
        """

        if self.type != self.TYPE_RADAR:
            raise UnsupportedError()

        if not hasattr(self, '_component'):

            # for some reason, component is sometimes a dict
            # and sometimes a Component object
            if isinstance(self.item.component, dict):
                self._component = Component(dictionary_representation=self.item.component)

            else:
                self._component = self.item.component

        return self._component

    @property
    def security_dri(self) -> Person:
        """
        [Radar] Returns a dictionary of the current Security DRI using the Security DRI field

        @return (dict): contains name, email, etc
        """

        if self.type != self.TYPE_RADAR:
            raise UnsupportedError()

        security_dri: dict = self.product_security.get('securityDRI', None)

        security_dri_person: Person = None

        if security_dri:
            security_dri_person = Person(dsid=security_dri['dsid'], first_name=security_dri['firstName'], last_name=security_dri['lastName'], email=security_dri['email'])

        return security_dri_person

    @security_dri.setter
    def security_dri(self, person: Person):
        """
        [Radar] changes the Security DRI of this item

        @param assignee(Person): person
        """

        if self.type != self.TYPE_RADAR:
            raise UnsupportedError()

        # unset the security_dri if the person is None
        if person is None:

            self.product_security['securityDRI'] = None
            self.updated_product_security['securityDRI'] = None
            return

        first_name: str = getattr(person, 'firstName', None)
        last_name: str = getattr(person, 'lastName', None)

        self.product_security['securityDRI'] = {

            'dsid': person.dsid,
            'email': getattr(person, 'email', None),
            'firstName': getattr(person, 'firstName', None),
            'lastName': getattr(person, 'lastName', None)
        }
        self.updated_product_security['securityDRI'] = person.dsid

    @property
    def assignee(self) -> Person:
        """
        [Radar, Oakdale Ticket] Returns the assignee for this item
        """
        return Person(first_name=self.item.assignee.firstName, last_name=self.item.assignee.lastName, dsid=self.item.assignee.dsid,
                      email=self.item.assignee.email)

    @assignee.setter
    def assignee(self, person: Person):
        """
        [Radar, Oakdale Ticket] Changes the assignee of this item

        @param assignee(Person): person
        """

        self.item.assignee = person

    @property
    def resolved_by(self) -> Person:
        """
        [Radar] Returns the person who resolved (pushed a PR) this item
        """

        if person := self.item.resolvedBy:
            return Person(first_name=person.firstName, last_name=person.lastName, dsid=person.dsid)

    @property
    def state(self) -> int:
        """
        [Radar] Returns the state of this item
        """

        return self.item.state

    @state.setter
    def state(self, state: str):
        """
        [Radar] Changes the state of this item

        @param state(str): state
        """

        self.item.state = state

    @property
    def resolution(self) -> int:
        """
        [Radar, Oakdale Ticket] Returns the resolution for this item
        """

        if self.type != self.TYPE_RADAR:
            raise UnsupportedError()

        return self.item.resolution

    @resolution.setter
    def resolution(self, resolution: str) -> str:
        """
        [Radar, Oakdale Ticket] Changes the resolution of this item

        @param resolution(str): resolution
        """

        self.item.resolution = resolution

    @property
    def security_type(self) -> str:
        """
        [Radar] Returns the Product Security type

        @param (str): type (e.g. Exposure)
        """

        if self.type != self.TYPE_RADAR:
            raise UnsupportedError()

        return self.product_security.get('type', None)

    @security_type.setter
    def security_type(self, value: str):
        """
        [Radar] Sets the Product Security type

        @param (str): type (e.g. Exposure)
        """

        if self.type != self.TYPE_RADAR:
            raise UnsupportedError()

        self.product_security['type'] = value
        self.updated_product_security['type'] = value

    def get_days_since_last_update(self) -> int:
        """
        Returns the number of days since this item has been updated

        @return (int): number of days
        """

        return (datetime.now(timezone.utc) - self.last_modified).days

    @property
    def days_since_created(self) -> int:
        """
        Returns the number of days since this item was created

        @return (int): number of days
        """

        return (datetime.now(timezone.utc) - self.item.createdAt).days

    def get_keyword_association(self, name: str) -> KeywordAssociation:
        """
        Returns a keyword association if it matches the name is in this Radar

        @param name(str): keyword name (supports wild cards % at start or end index)
        @return (KeywordAssociation): keyword association
        """

        name = name.lower()

        keyword_associations: list = self.keyword_associations

        if '%' not in name:
            return next((association for association in keyword_associations if association.keyword.name.lower() == name), None)
        else:

            no_wildcard_name: str = name.replace('%', '')

            if name.startswith('%'):
                return next((association for association in keyword_associations if association.keyword.name.lower().endswith(no_wildcard_name)), None)
            elif name.endswith('%'):

                return next((association for association in keyword_associations if association.keyword.name.lower().startswith(no_wildcard_name)), None)
            else:

                logger.error(f'get_keyword_association wildcards are only supported at start or end index')
                return None

        return None

    def get_keyword_association_by_id(self, id: int) -> KeywordAssociation:
        """
        Returns a keyword association if it matches the ID is in this Radar

        @param id(id): keyword ID
        @return (KeywordAssociation): keyword association
        """

        keyword_associations: list = self.keyword_associations

        return next((association for association in keyword_associations if association.keyword.id == id), None)

    @property
    def first_description_text(self) -> str:
        """
        First (raw) description entry in this item
        """

        if not hasattr(self, '_first_description_text'):

            descriptions: list = self.descriptions
            self._first_description_text = descriptions[0].text if len(descriptions) > 0 else None

        return self._first_description_text

    @property
    def first_description_display_text(self) -> str:
        """
        First display description entry in this item
        """
        return self.first_description_text

    @property
    def duplicate_id(self) -> int:
        """
        [Radar] returns the main radar ID (if this is a dup)

        @return (int): the ID of the item this item is duplicate of
        """

        return self.item.duplicateOfProblemID

    @duplicate_id.setter
    def duplicate_id(self, id: int | str) -> None:
        """
        [Radar] sets this item as a duplicate of another item

        @param external_id(str): the ID this item will be duped to (numerical part of the ID. No urls)
        """

        id = int(str(id).split('/')[-1])

        if self.type != self.TYPE_RADAR:
            raise UnsupportedError()

        self.state = cls.STATE_VERIFY
        self.resolution = RESOLUTION_DUPLICATE
        self.item.duplicateOfProblemID = id

        # self.product_security['securityPrimaryID'] = id
        # self.updated_product_security['securityPrimaryID'] = id

    @property
    def duplicate_item(self) -> int:
        """
        [Radar] Returns the main radar (if this is a dup)

        @return (ExternalItem): the item this item is duplicate of
        """

        from interlinked.core.clients.customradarclient import RadarClient
        return RadarClient.shared.get_item_for_radar_id(id=self.item.duplicateOfProblemID)

    @property
    def last_modified(self) -> datetime:
        """
        [Radar, Oakdale Ticket] Returns the last date/time this item was updated

        @return (datetime): last update datetime
        """

        return self.item.lastModifiedAt

    def get_components(self) -> list:
        """
        [Radar] Returns a list of components this item has

        @return TODO
        """

        if self.type != self.TYPE_RADAR:
            raise UnsupportedError()

        return [change['component'] for change in self.item.history]

    def get_previous_component(self) -> str:
        """
        Returns the previous component
        """

        unique_components = []
        components_names = []

        for change in self.item.history:

            component = change['component']
            component_name = component['name']

            if component_name not in components_names:

                unique_components.append(component)
                components_names.append(component_name)

        return unique_components[-2] if len(unique_components) >= 2 else None

    def get_assignees(self) -> list:
        """
        Returns a list of assingees this Radar has

        @return TODO
        """

        return [change['assignee'] for change in self.item.history]

    def get_previous_assignee(self) -> str:
        """
        Returns the previous assignee

        """

        assignees_emails = []
        unique_assignees = []

        for assignee in self.get_assignees():

            assignee_email = assignee['email']

            if assignee_email not in assignees_emails:

                unique_assignees.append(assignee)
                assignees_emails.append(assignee_email)

        return unique_assignees[-2] if len(unique_assignees) >= 2 else None

    @property
    def descriptions(self) -> list:
        """
        [Radar] returns a list of DescriptionEntry(s)

        @return (DescriptionEntry): descriptions
        """

        if not hasattr(self, '_descriptions'):

            self._descriptions: list = []

            if self.type == self.TYPE_RADAR:

                retry: bool = False

                try:
                    self._descriptions = self.item.description.items()

                except UnsuccessfulResponseException as exception:

                    # try again (sometimes, network issues)
                    if exception.code == 502:
                        retry = True

                except (URLError, RemoteDisconnected, TimeoutError) as error:
                    retry = True

                if retry:

                    sleep(1)
                    self._descriptions = self.item.description.items()

            else:
                raise UnsupportedError()

        return self._descriptions

    @property
    def comments(self) -> list:
        """
        [Radar] Returns a list of DiagnosisEntry(s)

        @return (DiagnosisEntry): comments
        """

        if not hasattr(self, '_comments'):

            self._comments: list = []

            if self.type == ExternalItem.TYPE_RADAR:
                self._comments = self.item.diagnosis.items(type='user')

            else:
                raise UnsupportedError()

        return self._comments

    def set_component_by_id(self, id: int):
        """
        [Radar] Sets the component for this item

        @param id(int): the ID of the Radar component
        """

        if self.type != ExternalItem.TYPE_RADAR:
             raise UnsupportedError()

        self.item.componentID = int(id)

    def set_assignee_by_dsid(self, dsid: str):
        """
        [Radar] sets the assignee of this item using their DSID

        @param dsid(str): the assignee's DSID
        """

        if self.type != ExternalItem.TYPE_RADAR:
             raise UnsupportedError()

        self.item.assignee = Person(dsid=dsid)

    def set_security_dri_by_dsid(self, dsid: str):
        """
        [Radar] sets the security DRI of this item using their DSID

        @param dsid(str): the security DRI's DSID
        """

        if self.type != ExternalItem.TYPE_RADAR:
             raise UnsupportedError()

        self.security_dri = Person(dsid=dsid)

    @property
    def references(self) -> list[dict]:
        """
        [Radar] Returns a list of external IDs for this item

        @return (list): `{'external': CVE-1234-5678, 'id': 000}, {'external_id': 'CVE-123-…', 'id': 000}...`
        """

        if not hasattr(self, '_references'):

            if self.type == ExternalItem.TYPE_RADAR:

                if self.processor is None:
                    raise Exception('processor is not set. Please set `.processor` before calling reporters')

                # e.g. https://xxxxx.com/problems/92689262/externals
                url = self.processor.radar_client.webservice_url_for_path_components('problems', self.external_id, 'product-security/externals')

                request = self.processor.radar_client.request_for_json_url(url=url)

                response_status, response_data = self.processor.radar_client.send_request(request)

                if not response_code_is_success(response_status):

                    logger.error(f'could not get list of reporters. response_data: {response_data}')
                    self._references = []

                else:
                    self._references = response_data

            else:
                 raise UnsupportedError()

        return self._references

    def add_reference(self, reference_external_id: str) -> None:
        """
        [Radar] Adds an external ID (e.g. CVE-123..) to this item
        """

        if self.type != ExternalItem.TYPE_RADAR:
             raise UnsupportedError()

        self.added_references.append(reference_external_id)

    def remove_reference(self, reference_id: str) -> None:
        """
        [Radar] Removes a reference (using its raw in radar ID, not external ID) from this item
        """

        if self.type != ExternalItem.TYPE_RADAR:
             raise UnsupportedError()

        self.removed_references.append(reference_id)

    @property
    def classification(self) -> str:
        """
        [Radar] Returns the classification of this item

        @return (str): classification (e.g. Security, Serious Bug, etc)
        """

        if self.type != ExternalItem.TYPE_RADAR:
            return None

        return self.item.classification

    @classification.setter
    def classification(self, value) -> bool:
        """
        [Radar] Sets the classification for this item

        @param value(str): can be Security, Serious Bug, etc
        """

        if self.type != ExternalItem.TYPE_RADAR:
             raise UnsupportedError()

        self.item.classification = value

    @property
    def reproducible(self) -> str:
        """
        [Radar] Returns the reproducibility of this item

        @return (str): reproducibility (e.g. Always, Rarely, etc)
        """

        if self.type != ExternalItem.TYPE_RADAR:
             raise UnsupportedError()

        return self.item.reproducible

    @reproducible.setter
    def reproducible(self, value) -> bool:
        """
        [Radar] Sets the reproducibility for this item

        @param value(str): can be Always, Rarely, etc
        """

        if self.type != ExternalItem.TYPE_RADAR:
             raise UnsupportedError()

        self.item.reproducible = value

    def add_keyword_by_name(self, name: str):
        """
        [Radar] Adds a keyword to a Radar

        @param name(str): keyword name
        """

        from interlinked.core.clients.customradarclient import RadarClient

        keywords: list = RadarClient.shared.keywords_for_name(keyword_name=name)

        if not keywords:
            raise Exception('keyword not found')

        for keyword in keywords:

            if keyword.name == name:

                self.item.add_keyword(keyword)
                break

    def add_keyword_by_id(self, id: str) -> None:
        """
        [Radar] Adds a keyword to a Radar

        @param id(str): keyword id
        @return (None): none
        """

        if self.type != ExternalItem.TYPE_RADAR:
             raise UnsupportedError()

        keyword: Keyword = Keyword({'id': id})
        self.item.add_keyword(keyword)

    def remove_keyword_by_id(self, id: str) -> bool:
        """
        [Radar] Removes a keyword to a Radar

        @param id(str): keyword id
        @return (bool): result
        """

        logger.info(f'removing keyword… ({id=}, {self.external_id=})')

        keyword: Keyword = Keyword({'id': id})
        self.item.remove_keyword(keyword)

    def add_internal_comment(self, text: str) -> None:
        """
        [Radar, Oakdale] Adds an internal comment/note

        @param text(str): comment text
        """

        entry: DiagnosisEntry = DiagnosisEntry({'text': text})
        self.item.diagnosis.add(entry)

    def add_attachment(self, file_name: str, content: bytes) -> None:
        """
        [Radar] Adds/Upload an attachment

        @param text(str): comment text
        @return (bool): status
        """

        if self.type != ExternalItem.TYPE_RADAR:
             raise UnsupportedError()

        attachment: Attachment = self.item.new_attachment(file_name)
        attachment.set_upload_content(content)

        self.item.attachments.add(attachment)

    def add_security_group(self, group_name: str) -> None:
        """
        [Radar] adds a security group to this item

        @param group_name(str): security group name
        @return (bool): result
        """

        self.item.add_group_to_security_list(group_name=group_name)

    def get_related_radar_ids(self, relationship_types: list = None) -> list:
        """
        [Radar] returns a list of radar ids based on the relationship

        @param relationship_types(list): types can be found in radarclient's Relationship types
        """

        if self.type != ExternalItem.TYPE_RADAR:
             raise UnsupportedError()

        try:
            return [relationship.related_radar_id for relationship in self.item.relationships(types=relationship_types)]

        except UnsuccessfulResponseException as exception:

            # try again (sometimes, network issues)
            if exception.code == 502:

                sleep(1)
                return [relationship.related_radar_id for relationship in self.item.relationships(types=relationship_types)]

    def get_relationships(self, relationship_types: list = None) -> list:
        """
        [Radar] returns a list of this radar's relationships
        """

        if self.type != ExternalItem.TYPE_RADAR:
             raise UnsupportedError()

        if isinstance(self.item.loaded_relationships, list) and len(self.item.loaded_relationships) <= 0:
            self.item.loaded_relationships = None

            # setting `loaded_relationships` above creates an unnecessary change_record that errors out later
            self.item.change_records = [change_record for change_record in self.item.change_records if getattr(change_record, 'property_name', None) != 'loaded_relationships']

        return self.item.relationships(types=relationship_types)

    def set_key_value(self, key: str, value: Any) -> None:
        """
        Sets a key and a value

        @param key(str): name of the key (e.g. product-security-impact)
        @param (Any): the value for the given key
        @return (None): none
        """

        # radar does not support int values
        # so, we convert them to strings
        if isinstance(value, int):
            value = str(value)

        # radar does not allow storing empty strings
        if isinstance(value, str) and len(value) <= 0:

            logger.error('empty string key/value fields are not allowed')
            return

        self.changed_key_values[key] = value

    def save_key_value(self, key: str, value: any, _retry_count: int = 0) -> None:
        """
        [Radar] sets the value of a given key

        @param radar_id(int/string): Radar ID number
        @param key(str): name of the key (e.g. product-security-impact)
        @param value(str): the value for the given key
        @return (bool): status
        """

        if _retry_count > 3:
            raise Exception(f'retried to save key/values too many times ({key=}, {value=}, {_retry_count=})')

        # if the value is None, delete the key
        if value is None:

            # e.g. /problems/92689262/key-values/product-security-impact..
            url = self.item.client.webservice_url_for_path_components('problems', self.item.id, 'key-values', key)
            request = self.item.client.request_for_json_url(url=url, method='DELETE')

        else:

            data: dict[str, Any] = {

                'name': key,
                'value': str(value),
                'valueType': self.get_data_type(object=value)
            }

            # e.g. https://xxxxx.com/problems/92689262/key-values
            url = self.item.client.webservice_url_for_path_components('problems', self.item.id, 'key-values')
            request = self.item.client.request_for_json_url(url=url, json_string=json.dumps(data), method='POST')

        try:
            response_status, response_data = self.item.client.send_request(request)

        except UnsuccessfulResponseException as exception:

            # 409 means the key already exists
            # we should update it instead
            if exception.code == 409:

                # radar doesn't like unnecessary keys
                data.pop('name')

                # e.g. /problems/92689262/key-values/product-security-impact..
                url = self.item.client.webservice_url_for_path_components('problems', self.item.id, 'key-values', key)
                request = self.item.client.request_for_json_url(url=url, json_string=json.dumps(data), method='PUT')

                try:
                    response_status, response_data = self.item.client.send_request(request)

                except UnsuccessfulResponseException as exception:

                    if str(exception.code).startswith('5'):
                        self.save_key_value(key=key, value=value, _retry_count=_retry_count + 1)

            else:
                raise

        if not response_code_is_success(response_status):
            raise Exception(f'set_radar_value_for_key failed. response_data: {response_data}')

    def save(self, daw_cookie: str = None) -> tuple[str, bool]:
        """
        Saves changes made to this item

        @param daw_cookie(str): if passed, the changes will be saved on behalf of the DAW cookie owner
        @return (str, bool): str: response text (if failed), bool: if saving the item was successful
        """

        message: str = ''
        success: bool = True

        def commit_safely():

            message: str = ''
            success: bool = True

            try:
                self.item.commit_changes()

            except UnsuccessfulResponseException as exception:  # Radar-only exception

                re_commit = False
                logger.warning(f'radar exception when saving ({exception.reason=}, {exception.code=})')

                # client error
                if exception.code == 400:

                    # clean up the exception reason
                    if exception.reason.endswith('already exists in the bundle'):

                        # mark as success but return the message
                        # we mark as success so we always continue processing other tasks
                        success = True
                        message = 'The attachment you are trying to upload is already uploaded. If this is a different attachment, please rename it then try uploading again'

                        return message, success

                    elif exception.reason.endswith('product security type is set to \'None\'.'):

                        # unset the Security Type. This allows us to make changes
                        # to the Product Security fields if the radar has type: 'None'
                        self.security_type = RADAR_PRODUCT_SECURITY_TYPE_NOT_SET
                        re_commit = True

                    elif exception.reason.startswith('The state cannot be changed to this value'):
                        message = 'Cannot make changes to this item. It is already closed'

                    raise exception

                # 409 conflict
                elif exception.code == 409:

                    # when removing keyword that isn't even in the radar
                    if (matches := re.findall(pattern=r'Keyword \'(\d+)\' is not attached to the problem', string=exception.reason, flags=re.IGNORECASE)) and (keyword_id := matches[0]):

                        change_record: RadarChangeRecord = next((change_record for change_record in self.item.change_records if isinstance(change_record, RemoveKeywordRadarChangeRecord) and change_record.keyword_association.keyword.id == int(keyword_id)), None)

                        if change_record:

                            self.item.change_records.remove(change_record)

                            # also remove any comments to prevent adding them twice
                            change_record = next((_change_record for _change_record in self.item.change_records if isinstance(_change_record, AddDiagnosisEntryRadarChangeRecord)), None)

                            if change_record:
                                self.item.change_records.remove(change_record)

                            re_commit = True

                        else:
                            raise Exception('could not find keyword ID')

                    else:
                        print(exception.reason)

                if re_commit:
                    messsage, success = commit_safely()
                else:

                    logger.error(f'will not try to recommit after an unsucessful response: {exception}', exc_info=True)

                    success = False
                    message = message if message else str(exception)

            except ConnectionError as exception:

                logger.error(f'save: encountered a connection error when saving. Exception: {exception}')
                success = False
                message = f'Connection error. Try again! {exception}'

            # clean up the message
            message = message.replace('Non-200 response code 400:', '').strip()

            return message, success

        if self.type == ExternalItem.TYPE_RADAR:

            # add the vulnerability classification dictionary to the updated product security dict
            if len(self.updated_vulnerability_classification) > 0:
                self.updated_product_security['vulnerabilityClassification'] = self.updated_vulnerability_classification

            if len(self.updated_product_security) > 0:
                self.item.productSecurity = self.updated_product_security

        message, success = commit_safely()

        if not success:
            return message, success

        if self.type == self.TYPE_RADAR:

            # check if any key/values changed
            if len(self.changed_key_values) > 0:

                for key, value in list(self.changed_key_values.items()):

                    if value is None or (isinstance(value, str) and len(value) <= 0):

                        message = f'Radar does not allow the value of {key} to be empty'
                        success = False
                        continue

                    if not self.save_key_value(key=key, value=value):

                        message = f'could not save_key_value(radar_id={self.item.id}, key={key}, value={value})'
                        success = False

                    elif key in self.changed_key_values:
                        del self.changed_key_values[key]

                if success:
                    self.changed_key_values.clear()

            # check if we have any reporters added
            if len(self.added_reporters) > 0:

                for reporter in self.added_reporters[:]:

                    if not processor.add_radar_reporter(radar_id=self.item.id, reporter=reporter):

                        message = f'could not add_radar_reporter(radar_id={self.item.id}, key={key}, value={value})'
                        success = False

                    else:
                        self.added_reporters.remove(reporter)

            # check if we have any reporters were changed
            if len(self.changed_reporters) > 0:

                for reporter_id, reporter in list(self.changed_reporters.items()):

                    if not processor.add_radar_reporter(radar_id=self.item.id, reporter=reporter,
                                                        reporter_id=reporter_id):

                        message = f'could not add_radar_reporter(radar_id={self.item.id}, reporter_id={reporter_id}, reporter={reporter})'
                        success = False

                    else:
                        del self.changed_reporters[reporter_id]

            # check if we have any references added
            if len(self.added_references) > 0:

                # e.g. https://xxxxx.com/problems/92689262/externals
                url = self.processor.radar_client.webservice_url_for_path_components(
                    'problems', self.external_id, 'product-security/externals')

                for reference_external_id in list(set(self.added_references))[:]:

                    request = processor.radar_client.request_for_json_url(url=url,
                        json_string=json.dumps({'external': reference_external_id}), method='POST')

                    response_status, response_data = self.processor.radar_client.send_request(request)

                    if not response_code_is_success(response_status):

                        message = f'could not add reference ({self.url=}, {reference_external_id=}, {response_data=})'
                        success = False

                    else:
                        self.added_references.remove(reference_external_id)

            # check if we have any references removed
            if len(self.removed_references) > 0:

                for reference_id in list(set(self.removed_references))[:]:

                    # e.g. https://xxxxx.com/problems/92689262/externals
                    url = self.processor.radar_client.webservice_url_for_path_components(
                        'problems', self.external_id, 'product-security/externals', reference_id)

                    request = processor.radar_client.request_for_json_url(url=url, method='DELETE')
                    response_status, response_data = self.processor.radar_client.send_request(request)

                    if not response_code_is_success(response_status):

                        logger.error(f'{response_status}: {response_data}')
                        message = f'could not remove reference ({self.url=}, {reference_id=}, {response_data=})'
                        success = False

                    else:
                        self.removed_references.remove(reference_id)

        if success:

            self.updated_product_security.clear()
            self.updated_vulnerability_classification.clear()
            self.added_reporters.clear()
            self.changed_reporters.clear()

        return message, success

    """ Utilities """

    def get_data_type(self, object: Any) -> str:
        """
        Returns the Radar data type of a given object

        e.g. str object -> 'String'
             float object -> 'Float'

        @param object(Any): any supported object
        @return (str): Radar data type
        """

        value_type = None

        # TODO: support more types
        # https://radar-api-docs.apple.com/api/documentation/latest/#object-type
        if isinstance(object, str):
            return 'String'
        elif isinstance(object, bool):
            return 'Boolean'
        elif isinstance(object, int):
            return 'Integer'
        elif isinstance(object, datetime):
            return 'Date'
        elif isinstance(object, float):
            return 'Float'
        elif isinstance(object, list):
            return 'List'
        elif object is None:
            return None

        else:
            logger.error(f'radar_data_type_of_object failed. {type(object)} is not a supported valueType yet')

        return None

    def __eq__(self, other: 'ExternalItem') -> bool:
        return isinstance(other, ExternalItem) and getattr(other, 'external_id', None) == self.external_id

    def __hash__(self) -> str:
        return hash(self.external_id)

    def __str__(self) -> str:
        return f'<ExternalItem external_id={self.external_id}, title={self.title}">'

    __repr__ = __str__


class RadarPlaceholder(Radar, DictionaryBasedModel):
    """
    A custom version of radarclient.RadarPlaceholder
    """

    lastModifiedAt: datetime = None

    IGNORED_KEYS = ['client']

    def __init__(self, dictionary_representation: dict = {}):

        self.reset_keyword_associations()

        self.id = dictionary_representation.get('id', None)
        self.client = dictionary_representation.get('client', None)

        self.description = CollectionProperty('description', self, DescriptionEntry)
        self.diagnosis = CollectionProperty('description', self, DiagnosisEntry)
        self.attachments = CollectionProperty('attachments', self, Attachment)
        self.other_related_items = CollectionProperty('other_related_items', self, OtherRelatedItem)

        self.productSecurity = {}

        self.requested_fields = []
        self.dictionary_representation_data = {}
        self.change_records = []
        self.loaded_relationships = []
        self.added_relationships = []

    def __setattr__(self, key: str, value: Any):

        if key in self.IGNORED_KEYS:

            super(Radar, self).__setattr__(key, value)
            return

        # ignore if the value is an empty dictionary/list
        if ((isinstance(value, dict) or isinstance(value, list)) and len(value) <= 0) or \
                (key == 'loaded_keyword_associations' and value is None):

            super(Radar, self).__setattr__(key, value)
            return

        change_record_class = self.change_record_class_for_property(key)
        self.add_change_record(change_record_class(self, key))
        super(Radar, self).__setattr__(key, value)

    @classmethod
    def is_placeholder(cls):
        return True


@dataclass
class SimilarItem(ExternalItem):
    """
    This class is same as `ExternalItem` but adds additional fields
    """

    thought: str = None
    score: float = None

    # e.g. `12345678`
    duplicate_id: str = None

    item: Any = None
    title: str = None
    external_id: str = None
    type: str = ExternalItem.TYPE_RADAR
