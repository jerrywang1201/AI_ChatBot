import re
import ast
import json
import inspect
import logging
import requests
from textwrap import dedent
from functools import wraps
from requests import Response
from typing import Any, Callable

from interlinked.core.tool import Tool
from interlinked.core.config import Config
from interlinked.core.utilities import Utilities
from interlinked.core.dynamic.functions import FunctionSignature, Function

logger = logging.getLogger(__name__)


class DynamicLogger:

	@Utilities.dynamic
	def info(self, msg: str, name: str = None):
		"""
		Logs an informational message

		@param msg(str): the message to log
		@param name(str): no need to set this. It will be automatically set
		"""
		if Config.current.is_development:

			logger.info(msg)
			return

		logger.info(json.dumps({

			'name': name,
			'message': str(msg),
		}))

	@Utilities.dynamic
	def error(self, msg: str, name: str = None):
		"""
		Logs an error message

		@param msg(str): the message to log
		@param name(str): no need to set this. It will be automatically set
		"""

		if Config.current.is_development:

			logger.error(msg)
			return

		logger.error(json.dumps({

			'name': name,
			'message': msg,
		}))


class DynamicDict(dict):

	@Utilities.dynamic
	def items(self) -> tuple:
		"""
		Returns the items in this dictionary
		"""
		return self.items()


class DynamicList(list):

	@Utilities.dynamic
	def append(self, item: Any):
		"""
		Appends an element to this list
		"""
		self.append(item)

	@Utilities.dynamic
	def remove(self, item: Any):
		"""
		Removes an element from this list
		"""
		if item in self:
			self.remove(item)


class DynamicStr(str):

	@classmethod
	@Utilities.dynamic
	def to_string(self, value: Any) -> str:
		"""
		Converts any value to string
		"""
		return str(value)

	@Utilities.dynamic
	def split(self, separator: str) -> list[str]:
		"""
		Separates a string and turns it into a list
		"""
		return str(self).split(separator)

	@Utilities.dynamic
	def join(self, iterable: list) -> tuple:
		"""
		Joins a string
		"""
		return str(self).join(iterable)

	@Utilities.dynamic
	def replace(self, old: str, new: str) -> str:
		"""
		Replaces a given string with a new one
		"""
		return str(self).replace(old, new)

	@Utilities.dynamic
	def strip(self) -> str:
		"""
		Removes leading and training spaces from the string
		e.g. ` Lorem ` -> `Lorem`
		"""
		return str(self).strip()


class DynamicRe:
	"""
	Allows you to use Regex patterns in Python
	"""

	@classmethod
	@Utilities.dynamic
	def findall(cls, pattern: str, string: str) -> tuple:
		"""
		Finds matches in a string using a given regex pattern
		"""
		return re.findall(pattern=pattern, string=string)

	@classmethod
	@Utilities.dynamic
	def sub(cls, pattern: str, repl: str, string: str) -> tuple:
		"""
		Replaces matches of a regex pattern with a string
		"""
		return re.sub(pattern=pattern, repl=repl, string=string)


class DynamicRequests:

	@classmethod
	@Utilities.dynamic
	def get(cls, url: str, params: dict = None, headers: dict = None) -> Response:

		# allows requests to the internet
		proxies: dict[str, str] = {'https': 'http://dps.iso.apple.com:443'} if not Config.current.is_development else {}

		return requests.get(url=url, params=params, headers=headers, proxies=proxies)

	@classmethod
	@Utilities.dynamic
	def post(cls, url: str, data: dict = None, json: str = None, headers: dict = None) -> Response:

		# allows requests to the internet
		proxies: dict[str, str] = {'https': 'http://dps.iso.apple.com:443'} if not Config.current.is_development else {}

		return requests.post(url=url, data=data, json=json, headers=headers, proxies=proxies)

	@classmethod
	@Utilities.dynamic
	def put(cls, url: str, data: dict = None, headers: dict = None) -> Response:

		# allows requests to the internet
		proxies: dict[str, str] = {'https': 'http://dps.iso.apple.com:443'} if not Config.current.is_development else {}

		return requests.put(url=url, data=data, headers=headers, proxies=proxies)


class DynamicInterpreter:

	RESTRICTED_CLASSES: dict[str, Any] = {}

	def log_exceptions(function: Callable) -> Callable:
		"""
		If an error occurs in `run_code`, this decorator will log the error to Splunk with the plugin name
		"""

		@wraps(function)
		def decorator(*args, **kwargs):

			try:
				return function(*args, **kwargs)

			except Exception as exception:

				# if there's a tool passed to `run_code`, log the error with
				# the tool's name
				tool: Tool = kwargs.get('tool')

				if tool:
					DynamicLogger().error(msg=str(exception), name=tool.name)

				raise exception

		return decorator

	@classmethod
	def get_is_function_call(cls, line: str) -> bool:
		"""
		Returns whether a given string is a function call
		"""

		# check if the line has `function_name()`. Make sure it ends with () to avoid mismatching things
		# like f-strings (e.g. `f'{ping()}'`)
		return len(re.findall(r'[A-Z0-9_]+\(.*\)', line, flags=re.IGNORECASE)) > 0 and line.endswith(')')

	@classmethod
	def get_argument_map_from_function_call(cls, line: str) -> dict[str, Any]:
		"""
		Reads a function call and returns a dictionary of argument names, and their values

		e.g. `SlackClient.send_message(channel='some-channel', message=f'Item: {item}')`
			  `{'channel': 'some-channel', 'message': 'f"Item: {item}"'}`

		@param line(str): a function call
		@return (dict): a dictionary of argument names and values
		"""
		argument_map: dict[str, Any] = {}

		# replace `[NEW_LINE]` token with actual `\n`
		line = line.replace('[NEW_LINE]', '\n')

		tree: ast.Module = ast.parse(line)
		keywords: list[ast.keyword] = tree.body[0].value.keywords

		# ability to parse function calls without named arguments
		# e.g. `SlackClient.send_message('some-channel', f'Item: {item}', …)`
		if len(keywords) <= 0:

			args: list[ast.arg] = tree.body[0].value.args

			for index, arg in enumerate(args):
				keywords.append(ast.keyword(arg=index, value=arg))

		for keyword in keywords:

			value: Any = keyword.value

			if isinstance(value, ast.Constant):
				argument_map[keyword.arg] = value.value

			elif isinstance(value, ast.JoinedStr):
				argument_map[keyword.arg] = ast.get_source_segment(line, value)

			elif isinstance(value, ast.Attribute):

				# e.g. `item.title` -> `<#item.title#>`
				argument_map[keyword.arg] = f'<#{ast.get_source_segment(line, value)}#>'

			elif isinstance(value, ast.List):

				values: list[Any] = []

				# e.g. `"['123']"` -> `['123']`
				# TODO: this does not handle f-strings or `JoinedStr` in lists (e.g. `[item]`)
				for _value in value.elts:

					# e.g. `status` (TODO: better example)
					if isinstance(_value, ast.Name):
						values.append(f'<#{_value.id}#>')

					# e.g. `item.title` -> `<#item.title#>`
					elif isinstance(_value, ast.Attribute):
						values.append(f'<#{ast.get_source_segment(line, _value)}#>')

					else:
						values.append(_value.value)

				argument_map[keyword.arg] = values

			elif isinstance(value, ast.Dict):

				dictionary: dict = {}

				for key_index, key in enumerate(value.keys):
					dictionary[key.value] = value.values[key_index].value

				argument_map[keyword.arg] = dictionary

			else:

				# e.g. `item` or `_optional_`
				keyword_value_id: str = value.id

				# skip arguments with `_optional_` value, as that is used to indicate
				# that we want the argument's default value
				if keyword_value_id == '_optional_':
					continue

				argument_map[keyword.arg] = f'<#{keyword_value_id}#>'

		return argument_map

	@classmethod
	def get_value_from_raw_value(cls, raw_value: Any) -> Any:
		"""
		Converts a raw argument string value to an actual value
		"""

		if raw_value is None:
			return raw_value

		raw_value = raw_value.strip()

		# raw_value could be empty, so we return an empty string instead of `None`
		# because an empty string indicates nothing while `None` would indicate that there's
		# a value and that value is `None` (which is not accurate)
		if len(raw_value) <= 0:
			return ''

		# str or r-str
		if raw_value.startswith(('"', '\'', 'r"', 'r\'')):
			return raw_value.replace('"', '').replace('\'', '').replace('r"', '').replace('r\'', '')

		# f-str
		if raw_value.startswith(('f"', 'f\'')):

			# remove the `f` prefix then replace all values with tokens
			raw_value = raw_value.removeprefix('f').replace('"', '').replace('\'', '')

			for match in re.findall(r'{.*?}', raw_value):
				raw_value = raw_value.replace(match, f'<#{match.removeprefix("{").removesuffix("}")}#>')

			return raw_value

		# list or dict
		elif raw_value.startswith(('[', '{')):

			# convert into a Python list
			# tokenize variables/properties (e.g. `item.title` -> `"<#item.title#>"`)
			raw_value = re.sub(r'\: ([A-Za-z0-9_.]+)', r': "<#\1#>"', raw_value)

			# the regex above unintentionally tokenized numerical values, so we untokenize them
			# e.g. `{'test_key': "<#2#>"}` -> `{'test_key': 2}`
			raw_value = re.sub(r'\: "<#([0-9]+)#>"', r': \1', raw_value)
			raw_value = raw_value.replace('True', 'true').replace('False', 'false')

			# replace all f-strings
			for f_string in re.findall(r'f(?:"|\').*?(?:"|\')', raw_value):
				raw_value = raw_value.replace(f_string, f'"{cls.get_value_from_raw_value(raw_value=f_string)}"')

			value: dict[str, str] = json.loads(raw_value)

			return value

		# float
		elif '.' in raw_value and raw_value.replace('.', '').isnumeric():
			return float(raw_value)

		# int
		elif raw_value.isnumeric():
			return int(raw_value)

		# bool
		elif raw_value in {'True', 'False'}:
			return raw_value == 'True'

		# None
		elif raw_value == 'None':
			return None

		# custom object
		else:
			return f'<#{raw_value}#>'

		return None

	@classmethod
	def set_value_for_raw_property(cls, raw_property: str, value: Any, variables: dict[str, dict], restricted: bool = False) -> None:
		"""
		Sets the value of a given raw property name
		e.g. `item.title`

		@param raw_property(str): a raw property name (e.g. `item.security_type`)
		@param value(Any): any value
		@param variables(dict): a dictionary of variables (must contain the property's instance (e.g. `item`))
		"""

		is_subscript: bool = False
		instance_name, property_name = None, None

		# e.g. `item.title` ->
		#		instance_name = `item`
		#		property_name = `title`
		if '.' in raw_property:
			instance_name, property_name = raw_property.split('.', 1)

		# e.g. item_dictionary['title']
		#	   instance_name = `item_dictionary
		#	   property_name = `title
		elif raw_property.endswith(']'):

			instance_name, property_name = raw_property.split('[', 1)
			property_name = property_name.removesuffix(']')

			# convert the property_name to its value
			# e.g. `items_dictionary[external_id]` -> `items_dictionary['OE1…']`
			# `external_id` in this example is a variable that was defined earlier in the code (e.g. `external_id = 'O1…'`)
			property_name = cls.get_value_from_raw_value(raw_value=property_name)
			property_name = cls.get_variable_value_for_token(token=property_name, variables=variables, restricted=restricted)

			is_subscript = True

		if instance_name not in variables:
			raise Exception(f'cannot set property "{property_name}" because {instance_name} is not a defined variable')

		# disallow setting any internal properties
		if property_name.startswith('_'):
			raise Exception(f'cannot set internal property "{property_name}"')

		instance_type: Any = type(variables[instance_name])

		# e.g. `item_dictionary['title'] = 'An item title'`
		if is_subscript:

			if instance_type not in {dict, list}:
				raise Exception(f'cannot set subscript property "{property_name}" for "{instance_name}"')

			variables[instance_name][property_name] = value

		else:
			# check if the property is allow-listed
			automation_functions: dict = Dynamic.get_functions_in_class(class_=type(variables[instance_name]), classmethods=False, dynamic_only=True)

			if property_name not in automation_functions:
				raise Exception(f'cannot set property "{property_name}". not a valid property of {instance_name}')

			setattr(variables[instance_name], property_name, value)

	@classmethod
	def get_function_call_signature(cls, code: str) -> tuple[str, str, list[str]]:
		"""
		Returns the signature of a function call

		e.g. `SlackClient.send_message(arg1="123", arg2="456")` -> `('SlackClient', 'send_message', {'arg1': '123', 'arg2': '456'})`

		@param code(str): raw function code
		@return (str): function signature
		"""

		full_function_name = code.split('(', 1)[0]

		if full_function_name == 'print':

			full_function_name = 'logger.info'
			code = code.replace('print(', f'{full_function_name}(msg=')

		elif full_function_name == 'str':

			full_function_name = 'DynamicStr.to_string'
			code = re.sub(r'\bstr\(', f'{full_function_name}(value=', code, flags=re.MULTILINE)

		class_name, function_name = full_function_name.split('.') if '.' in full_function_name else (None, full_function_name)

		# if this is a class initialization, append `__init__` (as the frontend does not include that)
		if class_name is None and function_name:

			if function_name[0].isupper():

				class_name = function_name
				function_name = '__init__'

		# get the arguments
		arguments: dict[str, Any] = {}

		for argument_name, argument_value in cls.get_argument_map_from_function_call(line=code).items():

			if argument_name in arguments:
				raise Exception(f'repeated argument ({argument_name=})')

			# convert argument_value to the corresponding value
			if isinstance(argument_value, str) and argument_value.startswith(('\'', '"', 'f\'', 'f"')):
				arguments[argument_name] = cls.get_value_from_raw_value(raw_value=argument_value)

			else:
				arguments[argument_name] = argument_value

		return class_name, function_name, arguments

	@classmethod
	def get_value_for_variable_name(cls, variable_name: str, variables: dict[str, Any], restricted: bool = False) -> Any:
		"""
		"""

		# `<#item.display_title#>` -> `item.display_title`
		variable_name = variable_name.removeprefix('<#').removesuffix('#>')

		variable_property: Any = None
		is_variable_property_subscript: bool = False

		# if the variable has a property (e.g. `item.title`)
		if '.' in variable_name:
			variable_name, variable_property = variable_name.split('.', 1)

		# subscript (e.g. `components[0]`)
		elif '[' in variable_name:

			is_variable_property_subscript = True

			# e.g. `item_details['some_property']` -> `'some_property'`
			variable_property = re.findall(r'\[.*?\]', variable_name)[0]
			variable_name = variable_name.replace(variable_property, '')

			variable_property = variable_property.removeprefix('[').removesuffix(']')
			variable_property = cls.get_value_from_raw_value(raw_value=variable_property)
			variable_property = cls.get_variable_value_for_token(token=variable_property, variables=variables, restricted=restricted)

		if variable_name not in variables:
			raise NameError(f'name \'{variable_name}\' is not defined')

		variable_value: Any = variables[variable_name]

		# if there's a property, get that instead
		# the None check is important here because `variable_property` could be an int 0
		if variable_property is not None:

			property_subproperty: Any = None

			# if this is a nested property (e.g. `item.security_dri.name`)
			# where property is `security_dri.name`, get the value of that first
			if '.' in variable_property:
				variable_property, property_subproperty = variable_property.split('.', 1)

			# if the property is a subscript (e.g. `item_details['some_property']`), return that
			if is_variable_property_subscript:

				try:
					return variable_value[variable_property]

				except KeyError as error:
					raise Exception(f'`{variable_property}` does not exist in `{variable_name}`')

			# if the property is a function call (e.g. `dictionary.items()`), return the result of the function
			is_variable_property_call: bool = cls.get_is_function_call(line=variable_property)

			if is_variable_property_call:
				raise Exception(f'cannot call {variable_name} function. Please define it as a variable ({variable_property=})')

			# only check if the property is valid, if the class is unrestricted
			if type(variable_value) not in Dynamic.get_unrestricted_classes():

				# make sure the property has a `@Utilities.dynamic` decorator
				automation_functions: dict = Dynamic.get_functions_in_class(class_=type(variable_value), classmethods=False, dynamic_only=True)

				if variable_property not in automation_functions:
					raise Exception(f'not a valid property ({variable_property=}, {variable_value=})')

			# do not allow access to internal properties (e.g. `__dict__`)
			if isinstance(variable_property, str) and variable_property.startswith('_'):
				raise Exception(f'property is internal ({variable_property=}, {variable_value=})')

			# e.g. `item.title`
			if property_subproperty:
				return getattr(getattr(variable_value, variable_property), property_subproperty)

			else:
				return getattr(variable_value, variable_property)

		return variable_value

	@classmethod
	def get_variable_value_for_token(cls, token: str|list|dict, variables: dict[str, Any],
									 functions: dict[str, dict] = None, tool: Tool = None, restricted: bool = False) -> Any:
		"""
		Converts a `<#…#>` token to a variable value
		(e.g. `item.title` -> `Lorem Ipsum Dolor`)
		"""

		if isinstance(token, list):
			return [cls.get_variable_value_for_token(token=_token, variables=variables, restricted=restricted) for _token in token if _token]

		if isinstance(token, dict):
			return {key: cls.get_variable_value_for_token(token=value, variables=variables, restricted=restricted) for key, value in token.items()}

		# we expect the token to be a string
		if not isinstance(token, str):
			return token

		# extract all of the tokens
		tokens: list[str] = re.findall(r'\<#.*?#\>', token)

		if len(tokens) <= 0:
			return token

		# if the string has multiple tokens or the length of the string without the token
		# is not the same (e.g. `len('test <#item.display_title#>') <= len(`test `)`)
		# e.g.
		# token = 'test <#item.display_title#>'
		# len(token) = …
		# tokens[0] = '<#item.display_title#>'
		# token.replace(tokens[0], '') -> 'test '
		# len('test <#item.display_title#>') <= len('test ')
		is_f_string: bool = len(tokens) > 1

		if not is_f_string:

			# e.g. `test <#item.display_title#>` -> `test ` or `<#item.display_title#> -> ``
			token_without_first_token: str = token.replace(tokens[0], '')
			is_f_string = len(token_without_first_token) > 0 and len(token) >= len(token_without_first_token)

		# if this is not an f-string, return the value immediately
		if not is_f_string:

			variable_name: str = token.removeprefix('<#').removesuffix('#>')

			if variable_name == 'true':
				return True

			elif variable_name == 'false':
				return False

			return cls.get_value_for_variable_name(variable_name=variable_name, variables=variables, restricted=restricted)

		# this will initially have the token as is (e.g. `test <#item.display_title#>`)
		# then each token will be replaced with the actual value (e.g. `test Vulnerability Report`)
		variable_value: Any = token

		for _token in tokens:

			# `<#item.display_title#>` -> `item.display_title`
			variable_name: str = _token.removeprefix('<#').removesuffix('#>')

			# resolve `item.display_title` to its actual value
			actual_value: Any = None

			if cls.get_is_function_call(line=variable_name):

				actual_value = cls.call_function(function_code=variable_name, variables=variables,
												 functions=functions, tool=tool, restricted=restricted)

			else:
				actual_value = cls.get_value_for_variable_name(variable_name=variable_name, variables=variables, restricted=restricted)

			# we cast the replacement as str (just like Python's f-string)
			variable_value = variable_value.replace(_token, str(actual_value))

		return variable_value

	@classmethod
	def call_function(cls, function_code: str, variables: dict[str, Any] = None,
					  functions: dict[str, dict] = None, tool: Tool = None, restricted: bool = False) -> Any:
		"""
		Calls a given function and returns the value. Works on class initialization too

		@param function_code(str): Python code (including signature)
		@param tool(Tool): an optional Tool used to help find logs related to this
		@param restricted(bool): if `True`, the function will return test data (if the class/function is restricted)
		"""

		class_name, function_name, arguments = cls.get_function_call_signature(code=function_code)
		__class_name = str(class_name)

		function: Function = None

		self_: Any = None
		override_as_nonclassmethod: bool = False

		# check if the function was defined earlier in the code vs from another class/module
		if class_name is None:

			if function_name not in functions:
				raise Exception(f'unknown function ({function_name=})')

			# means this function was defined dynamically earlier
			function = functions[function_name]

		else:

			if class_name is None:
				raise Exception(f'class_name is None ({class_name=}, {function_name=})')

			# e.g. `dictionary` in `dictionary.items()` where `dictionary` was
			# defined earlier as `dictionary = {'key': 'value'}`
			if class_name in variables:

				self_ = variables[class_name]

				# turn the `class_name` to its type (then name), so when we call `get_class_for_class_name`,
				# we get the class's functions
				# e.g. `dictionary` (defined earlier as a dictionary), turns into `dict`
				if isinstance(self_, (str, list, dict, int)):

					class_name = type(self_).__name__

					# if isinstance(self_, (ExternalItem)):
					# 	override_as_nonclassmethod = True

			# get completions for module to ensure that we can call the function
			class_: Any = Dynamic.get_class_for_class_name(class_name=class_name)

			if class_ is None:

				# TODO: this should not be needed, but used as a workaround because the code above
				# fails when running `test_status = Status(title='…'); test_status.append('test')`
				class_name = type(self_).__name__
				class_: Any = Dynamic.get_class_for_class_name(class_name=class_name)
				override_as_nonclassmethod = True

				if class_ is None:

					# this could also mean that the value of the variable (`variables[class_name]`) is `None`
					# which may be expected based on the data. To fix that have the plugin code have an `if` check
					raise Exception(f'class is invalid ({class_name=}, {function_name=}, {self_=})')

			# if the class_ is an object, cast it to
			is_classmethod: bool = False

			if not override_as_nonclassmethod:

				is_classmethod = isinstance(class_, type)

				if not is_classmethod:

					# raw types require `self_` to be `None`
					if not isinstance(self_, (str, list, dict, int)):
						self_ = class_

					class_ = type(class_)

			dynamic_functions: dict[str, Function] = Dynamic.get_functions_in_class(class_=class_, classmethods=is_classmethod, dynamic_only=True)
			function = dynamic_functions.get(function_name)

		if function is None:

			# if we're calling `__init__` but the class doesn't have one explicitly defined,
			# override the function. The type returned will be `wrapper_descriptor`
			if function_name == '__init__':
				function = Function(signature=FunctionSignature(name='__init__', arguments=[], return_type=__class_name, has_kwargs=False),
									is_dynamic=False, decorators=[])

			else:
				raise AttributeError(f'\'{__class_name}\' object has no attribute \'{function_name}\'')

		# get the valid arguments for this function
		function_arguments: list[dict[str, Any]] = function.signature.arguments
		function_arguments_names: list = [function_argument.get('name') for function_argument in function_arguments]

		# compare them with the ones in the code (all must be valid)
		for index, argument in enumerate(list(arguments.items())):

			argument_name, argument_value = argument

			if not function.signature.has_kwargs:

				if isinstance(argument_name, str):

					if argument_name not in function_arguments_names:
						raise Exception(f'invalid argument ({argument_name=})')

				elif isinstance(argument_name, int):

					# convert arg index to its name
					# this happens when the function we're running doesn't have named arguments
					# e.g. `SlackClient.send_message('channel-name', …)`, where argument_name is 0 (`'channel-name'`)
					# so, we convert the 0 to `channel_name` (which is the actual argument name)
					_argument_name = function_arguments_names[argument_name]
					del arguments[argument_name]

					argument_name = _argument_name

			# populate `<#…#>` arguments with previous variables (if needed)
			argument_value = cls.get_variable_value_for_token(token=argument_value, variables=variables, restricted=restricted)
			arguments[argument_name] = argument_value

		# will be assigned the return value of the function we're calling
		variable_value: Any = None

		# call the function
		if not function.is_dynamic:

			actual_function: Callable = None

			# if we're running in restricted mode, check if the function
			# has an override
			if restricted and class_name in cls.RESTRICTED_CLASSES:
				actual_function = getattr(cls.RESTRICTED_CLASSES[class_name], function_name, None)

			# `function` is `None` in most cases. It's only not `None` if
			# it was overridden above
			if actual_function is None:
				actual_function = getattr(class_, function_name, None)

			# if this is a `logger` function, append the reference name as an argument
			if class_name == 'logger':
				arguments['name'] = tool.name if tool else 'Tool'

			# if this is a class initalization, initalize the class
			if function_name == '__init__':
				variable_value = class_(**arguments)

			elif is_classmethod:
				variable_value = actual_function(**arguments)

			# if this is not a classmethod, pass `self` as the first arg
			else:
				variable_value = actual_function(self_, **arguments)

		# dynamic
		else:

			# call the function and pass the arguments
			variable_value = function(**arguments | variables, tool=tool, restricted=restricted)

		return variable_value

	@classmethod
	@log_exceptions
	def run_code(cls, code: str, variables: dict[str, Any] = None, functions: dict[str, dict] = None,
				 tool: Tool = None, restricted: bool = False) -> Any:
		"""
		Interprets and runs allow-listed code from a given string

		@param code(str): Python code
		@param variables(dict): a dictionary of variable names and their values that the code may reference
		@param functions(dict): a dictionary of function names and their definition that the code may reference
		@param tool(Tool): an optional Tool used to help find logs related to this
		@param restricted(bool): if `True`, some functions will return test data instead
		"""

		# raise an exception if we're importing a package/library
		if re.findall(r'^(import|from) ', code, flags=re.MULTILINE):
			raise Exception('importing packages is not allowed')

		# track variables in the code and their values
		if variables is None:
			variables = {}

		# track functions, their decorators, and indexes
		if functions is None:
			functions = {}

		skip_indented: bool = False

		# whether `skip_indented` was set because we were parsing a `for` loop
		loop_range_start: int = None

		# temporary variables used in loops
		# e.g. `for item in items:` -> [`item`]
		# e.g. `for key, value in dictionary.items():` -> [`key`, `value`]
		loop_variable_names: list[str] = []
		loop_call_or_variable_name: str = None

		# TODO: move this to `functions`?
		decorators: list[str] = []

		# treat `;` as new lines
		code = code.replace(';', '\n').replace('\n\n', '\n')

		# convert ''' to ', and deindent
		for match in re.findall(r"(?s)'''(.*)'''", code, re.MULTILINE):
			code = code.replace(match, re.sub(r'\n(\t)', '\n', match.strip(), re.DOTALL | re.MULTILINE).replace('\n', '[NEW_LINE]').strip())

		# replace all inline comments (at the end of lines)
		for match in re.findall(r' (# .*?)\n', code):
			code = code.replace(match, '')

		# merge lines that end with `,`
		# e.g. a function call with arguments that continue on the next line
		code = re.sub(r',\n(\t+)', ', ', code)

		# merge lines that end with `\`
		# e.g. a multi-line string variable definition
		code = re.sub(r'(?:\w|)\\\n', '', code)

		# merge multi-line dicts/JSON into one line
		code = re.sub(r'(?:),\n', ', ', code)

		code = code.strip()

		# *= operators are not supported
		unsupported_operator: str = next((operator for operator in {'+=', '-='} if operator in code), None)

		if unsupported_operator:
			raise Exception(f'Dynamic does not have support for {unsupported_operator} operator. Use f-strings instead')

		# we add an empty line at the end to allow loops to run (if there's nothing after them)
		code = f'{code}\n'

		code_lines: list[str] = code.split('\n')

		for line_index, line in enumerate(code_lines):

			# check if we're indented
			# we only strip spaces so we can still check if the line starts with a tab
			is_indented_or_comment: bool = line.strip(' ').startswith('\t') or line.strip().startswith(('#', '"""', '\'\'\''))

			logger.debug(f'reading line: ({line_index=}, {line=}, {is_indented_or_comment=}, {skip_indented=})')

			if is_indented_or_comment:

				if skip_indented:
					continue

			elif skip_indented:

				skip_indented = False

				# we just finished running over a `for` loop, run the code in the loop now
				if loop_range_start is not None:

					# get the code (the indented block after the `for … in …:` line)
					loop_code_lines: list[str] = code_lines[loop_range_start:line_index]

					# unindent the code of the function
					loop_code: str = '\n'.join([loop_line.removeprefix('\t') for loop_line in loop_code_lines])

					# this is the call or variable after `in` in a loop
					# e.g. `items` in `for item in items:`
					loop_call_or_variable: Any = cls.get_value_from_raw_value(raw_value=loop_call_or_variable_name)
					loop_call_or_variable = cls.get_variable_value_for_token(token=loop_call_or_variable, variables=variables, restricted=restricted)

					# run the loop
					for loop_value in loop_call_or_variable:

						if not isinstance(loop_value, tuple):
							loop_value = (loop_value, )

						if len(loop_value) != len(loop_variable_names):
							raise Exception(f'the loop outputs a different number of variables ({code_lines[loop_range_start - 1]})')

						# zip the names with their values
						# e.g. loop_variable_names = ['key', 'value']
						#	   loop_value = ('title', 'a title')
						#	   loop_variables = {'key': 'title', 'value': 'a title'}
						loop_variables: dict[str, Any] = dict(zip(loop_variable_names, loop_value))

						cls.run_code(code=loop_code, variables=variables | loop_variables, tool=tool, restricted=restricted)

					loop_range_start = None

				else:

					# check if we were in a function definition (e.g. `def …:`)
					function_name, function = next(((function_name, function) for function_name, function in functions.items() if function._range_end is None), (None, None))

					if function_name:

						function._range_end = line_index

						# unindent the code of the function
						# we do `removeprefix` instead of replacing
						# all indetation to preserve for loops, etc inside this function
						function.code = '\n'.join(function_code_line.removeprefix('\t') for function_code_line in code_lines[function._range_start:line_index])
						functions[function_name] = function

						# don't `continue` here because we're on the next line
						# that we'd still need to interpret
						# e.g. previous line was `\t… something inside a function`
						# 	   this line is a new function definition (`def …:`)
						# we don't want to skip this line so we don't miss defining
						# the new function (or any code really)

			line = line.strip()

			# skip empty lines and inline comments
			if len(line) <= 0 or line.startswith(('#', '"""', '\'\'\'')):
				continue

			is_if_statement: bool = line.startswith('if')

			if is_if_statement:

				# remove `if` and `:`
				line = line.removeprefix('if').removesuffix(':').strip()

				startswith_not: bool = line.startswith('not')

				if startswith_not:

					# remove the `not` prefix to extract the variable
					# e.g. `not item` -> `item`
					if startswith_not:
						line = line.removeprefix('not').strip()

					variable: Any = cls.get_value_from_raw_value(raw_value=line)
					variable = cls.get_variable_value_for_token(token=variable, variables=variables, restricted=restricted)

					# e.g. `if not …`
					if startswith_not:

						if variable:

							skip_indented = True
							continue

					# e.g. `if …`
					else:

						if not variable:

							skip_indented = True
							continue

				else:

					operator: str = re.findall(r'(\=\=|\>\=|\<\=|\>|\<|\bnot in\b|\bin\b|!=|\bis not\b|\bis\b)', line)

					if operator:
						operator = operator[0]

					# there's no operator in `if item:` or `if not item:` statemenets
					if not operator:

						# e.g. variable_1 = `item`
						variable_1, variable_2 = line, None
						operator = 'is not'

					else:
						variable_1, variable_2 = line.split(operator)

					# remove spaces
					variable_1 = variable_1.strip()
					variable_2 = variable_2.strip() if variable_2 else None

					# get the actual value of each variable
					variable_1 = cls.get_value_from_raw_value(raw_value=variable_1)
					variable_2 = cls.get_value_from_raw_value(raw_value=variable_2)

					# untokenize (if needed)
					variable_1 = cls.get_variable_value_for_token(token=variable_1, variables=variables, restricted=restricted)
					variable_2 = cls.get_variable_value_for_token(token=variable_2, variables=variables, restricted=restricted)

					# do the comparison
					if operator == '==':

						if not variable_1 == variable_2:
							skip_indented = True

					elif operator == '!=':

						if not variable_1 != variable_2:
							skip_indented = True

					elif operator == '>':

						if not variable_1 > variable_2:
							skip_indented = True

					elif operator == '<':

						if not variable_1 < variable_2:
							skip_indented = True

					elif operator == '>=':

						if not variable_1 >= variable_2:
							skip_indented = True

					elif operator == '<=':

						if not variable_1 <= variable_2:
							skip_indented = True

					elif operator == 'in':

						if not variable_1 in variable_2:
							skip_indented = True

					elif operator == 'not in':

						if not variable_1 not in variable_2:
							skip_indented = True

					elif operator == 'is':

						if not variable_1 is variable_2:
							skip_indented = True

					elif operator == 'is not':

						if not variable_1 is not variable_2:
							skip_indented = True

					continue

			should_return: bool = line.startswith('return')

			if should_return:

				line = line.removeprefix('return').strip()
				logger.debug(f'return: ({line=})')

			variable: str = None

			# check if this is a variable definition (e.g. `title = Item.get_title(…)`) and check that `title` is actually a valid variable
			# or check if we're setting value of a property in a dictionary (e.g. `test_dictionary['test_key'] = 1`)
			if '=' in line and (variable_raw := line.split('=')[0].strip()):

				_variable: str = variable_raw
				variable_type = None

				# get the type hint (if set)
				if ':' in _variable:

					_variable, variable_type = _variable.split(':', 1)
					_variable = _variable.strip()
					variable_type = variable_type.strip()

				# check if variable name is valid (alphanumeric)
				# e.g. `value = 1`, `item_indexes[1] = 1`
				if _variable.endswith(']') or _variable.replace('_', '').replace('.', '').isalnum():

					# set the default value of the variable to `None` (to be defined later in the code)
					# if it's not already set. it may already be set in the `variables` argument
					# when `run_code` is called.
					# the '.' check if for property assignments (e.g. `item.title = …`),
					# there's no need to store `item.title` as a variable
					if '.' not in _variable and _variable not in variables:
						variables[_variable] = None

					# remove the variable from the line
					# e.g. `_variable = function()` -> `function()`
					#      `_variable = 1` -> `1`
					line = line.split('=', 1)[1].strip()

					logger.debug(f'defining variable: {_variable}')

				else:
					_variable = None

				if _variable is not None:
					variable = _variable

			# check if this is a decorator
			if line.startswith('@'):

				decorators.append(line)
				continue

			# check if this is a function definition
			if line.startswith('def '):

				# get the function name from the signature
				function_signature: FunctionSignature = FunctionSignature.get_signature_for_code(code=line, require_types=True)

				logger.debug(f'defining function: {function_signature.name}')

				# the format should match the one from `get_functions_in_class`
				functions[function_signature.name] = Function(_range_start=line_index + 1, _range_end=None,
															  code=None, signature=function_signature, decorators=decorators,
															  is_dynamic=True)

				# skip all the lines until we get to the end of the function definition
				skip_indented = True
				continue

			if line.startswith('for '):

				logger.debug(f'starting for-loop scope: {line}')

				loop_range_start = line_index + 1

				# the variable names between `for` and `in` (e.g. `key, value` in `for key, value in dictionary_items:`)
				loop_variable_names = [variable_name.strip() for variable_name in line.split('for ')[-1].split(' in')[0].split(',')]

				# the call or variable name after `in` (e.g. `dictionary_items` in `for key, value in dictionary_items:`)
				loop_call_or_variable_name = line.split('in ')[-1].removesuffix(':')

				# skip all the lines until we get to the end of the loop scope
				skip_indented = True
				continue

			if (is_function_call := cls.get_is_function_call(line=line)):

				logger.debug(f'calling function: {line}')

				variable_value: Any = None
				function_call_code: str = line

				# if this is a chained function call (e.g. `Test.get_test2().ping_2()`)
				# call each function and create a `_tmp` variable to store the value of each function call
				# then use that to call the next function
				for function_call_raw_index, function_call_raw in enumerate(line.split(').')):

					if not function_call_raw.endswith(')'):
						function_call_raw = f'{function_call_raw})'

					if function_call_raw_index > 0:

						variables['_tmp'] = variable_value
						function_call_code = f'_tmp.{function_call_code}'

					variable_value = cls.call_function(function_code=function_call_code, variables=variables,
													   functions=functions, tool=tool, restricted=restricted)
					function_call_code = function_call_code.replace(f'{function_call_raw}.', '')

				# update the variables with the new value
				if variable is not None:

					# if the variable is actually a property, set the property
					# e.g. `variable` is `item.title`
					if '.' in variable:
						cls.set_value_for_raw_property(raw_property=variable, value=variable_value, variables=variables, restricted=restricted)

					variables[variable] = variable_value

				if '_tmp' in variables:
					del variables['_tmp']

				if should_return:
					return variable_value

				continue

			# check if it's just a raw value
			if variable is not None or should_return:

				# if this is just a `return fields` and `fields` was defined earlier
				# for consistency, we tokenize `fields` (e.g. `fields` -> `<#fields#>`)
				# then look up its value
				variable_value: Any = cls.get_value_from_raw_value(raw_value=line)

				# e.g. `<#fields#>` -> `[{'field1': …}]`
				variable_value = cls.get_variable_value_for_token(token=variable_value, variables=variables, functions=functions, tool=tool,
																  restricted=restricted)

				if should_return:
					return variable_value

				elif variable is not None:

					# if the variable is actually a property, set the property
					# e.g. `variable` is `item.title`
					if '.' in variable:
						cls.set_value_for_raw_property(raw_property=variable, value=variable_value, variables=variables, restricted=restricted)

					elif variable.endswith(']'):
						cls.set_value_for_raw_property(raw_property=variable, value=variable_value, variables=variables, restricted=restricted)

					else:
						variables[variable] = variable_value


class Dynamic:

	CLASS_NAME_MAP: dict[str, Any] = {}

	CACHED_FUNCTIONS: dict[str, dict] = {}
	CACHED_CLASSMETHODS: dict[str, dict] = {}

	def __init__(self):
		pass

	@classmethod
	def get_class_name_map(cls) -> dict[str, Any]:
		"""
		"""

		from interlinked.core.ai import AI, Observation
		from interlinked.core.classes import ExternalItem
		from interlinked.core.clients.mailclient import MailClient
		from interlinked.core.clients.slackclient import SlackClient

		if cls.CLASS_NAME_MAP is None:

			cls.CLASS_NAME_MAP = {

				're': DynamicRe,
				'str': DynamicStr(),
				'str_': DynamicStr(),
				'dict': DynamicDict(),
				'list': DynamicList(),
				'DynamicStr': DynamicStr,

				'ExternalItem': ExternalItem,

				'Response': Response,
				'requests': DynamicRequests,

				'AI': AI,
				'Observation': Observation,

				'MailClient': MailClient,
				'SlackClient': SlackClient,

				'Utilities': Utilities,
				'logger': DynamicLogger(),
			}

		return cls.CLASS_NAME_MAP

	@classmethod
	def get_unrestricted_classes(cls) -> list[Any]:
		"""
		Returns a list of classes
		"""

		from radarclient import Component
		from interlinked.core.ai import Observation

		return {

			dict,
			list,
			Response,
			DynamicRe,
			Utilities,
			Component,
			DynamicStr,
			DynamicDict,
			DynamicList,
			Observation,
			DynamicLogger,
		}

	@classmethod
	def get_functions_in_class(cls, class_: Any, classmethods: bool = False, dynamic_only: bool = False) -> list[dict]:
		"""
		Returns a list of functions in a given class (and caches them)
		"""

		functions: list[dict] = None

		if classmethods:
			functions = cls.CACHED_CLASSMETHODS.get(class_)

		else:
			functions = cls.CACHED_FUNCTIONS.get(class_)

		if not functions:

			source: str = inspect.getsource(class_)

			# some classes are unrestricted
			if class_ in cls.get_unrestricted_classes():
				dynamic_only = False

			functions = Function.get_functions_for_code(code=source, dynamic_only=dynamic_only)

			if classmethods:
				cls.CACHED_CLASSMETHODS[class_] = functions

			else:
				cls.CACHED_FUNCTIONS[class_] = functions

		if classmethods:
			return {function_name: function for function_name, function in functions.items() if function.is_classmethod}

		return {function_name: function for function_name, function in functions.items() if not function.is_classmethod}

	@classmethod
	def get_class_for_class_name(cls, class_name: str) -> Any:
		"""
		Returns a class for a given class name
		"""

		return cls.get_class_name_map().get(class_name)

	@classmethod
	def get_completions_for_code(cls, code: str, index: int | None, include_details: bool = False) -> list[dict]:
		"""
		Returns a list of code completions for a given variable in code
		"""

		# if we have an index (which tells us where the cursor is at),
		# we want to find the variable name before the cursor
		# e.g. code = `MailClient.` -> variable = `MailClient`
		variable_start: int = index

		if index is not None and index > 0:

			if index >= len(code):
				index = len(code) - 1

			while variable_start > 0 and (previous_charachter := code[variable_start - 1]) and previous_charachter not in {' ', '=', '{', '\t', '\n', '('}:
				variable_start -= 1

		variable: str = code[variable_start:index].strip('.').strip() if variable_start is not None else None

		# if there's no index/variable name, return the list of available classes
		if not variable:

			completions: list[dict] = []

			for class_name, class_ in cls.get_class_name_map().items():

				# skip some classes that wouldn't make sense to show
				if class_name in {'dict', 'str', 'str_', 'list', 'DynamicStr'}:
					continue

				completions.append({

					'name': class_name,
					'attributes': {

						'type': 'class',
						'description': class_.__doc__.strip() if class_.__doc__ else None
					}
				})

		else:

			override_as_nonclassmethod: bool = False
			class_: 'class' = cls.get_class_for_class_name(class_name=variable)

			if class_ is None:

				# if the variable is unknown, check if it was defined earlier in the code
				code_before_variable: str = code[:variable_start]
				definition_prefix: str = f'{variable} = '
				code_lines_before_variable: list[str] = code_before_variable.split('\n')

				# if the variable is defined in a for loop (e.g. `item` in `for item in items:`)
				# we look up the return type of `items` instead
				use_return_type: bool = False

				# find where the variable was defined
				# e.g. `items = Item.get_items_for_…`
				definition_line: str = next((line for line in code_lines_before_variable if line.strip().startswith(definition_prefix)), None)

				# check if it came from a for loop
				if not definition_line:

					definition_line_: str = next((line for line in code_lines_before_variable if line.strip().startswith(f'for {variable} in')), None)

					# instead of getting the definition the variable in the for loop
					# get type of the source variable
					# e.g. `for item in items:`, get the type of `items`
					if definition_line_:

						# the call or variable name after `in` (e.g. `items` in `for item in items:`)
						source_variable: str = definition_line_.split('in ')[-1].removesuffix(':')
						definition_line = next((line for line in code_lines_before_variable if line.strip().startswith(f'{source_variable} = ')), None)
						use_return_type = True

				if definition_line:

					# e.g. `titles = []` -> `[]`
					definition_line = definition_line.split('=', 1)[-1].strip()

					if definition_line.startswith(('\'', '"', 'f\'', 'f"')):
						class_ = cls.get_class_for_class_name(class_name='str')

					elif definition_line.startswith('['):
						class_ = cls.get_class_for_class_name(class_name='list')

					elif definition_line.startswith('{'):
						class_ = cls.get_class_for_class_name(class_name='dict')

					# if this is a function call (e.g. `ClassName.get_object()`)
					elif '(' in definition_line:

						class_name, function_name, _ = DynamicInterpreter.get_function_call_signature(code=definition_line)

						_class_ = cls.get_class_for_class_name(class_name=class_name)

						if _class_ is None:
							return []

						# if the class_ is an object, cast it to
						_is_classmethod: bool = isinstance(_class_, type)

						if not _is_classmethod:
							_class_ = type(_class_)

						functions: list[dict] = cls.get_functions_in_class(class_=_class_, classmethods=_is_classmethod, dynamic_only=True)

						# get the function's definition, then use the `return_type`
						# as the class
						if _class_ and function_name in functions:

							function = functions.get(function_name)
							return_type: str = function.signature.return_type

							override_as_nonclassmethod = True

							if use_return_type:

								# if `return_type` is a subscript type
								# e.g. `list[Item]`, we want to use `Item` instead
								if return_type.endswith(']'):

									# we need to indicate that this is not a classmethod
									# e.g. `item` in `for item in items:`
									return_type = return_type.split('[', 1)[-1].removesuffix(']')

							class_ = cls.get_class_for_class_name(class_name=return_type)

				if class_ is None:
					return []

			# if the class_ is an object, cast it to
			is_classmethod: bool = False

			if not override_as_nonclassmethod:

				is_classmethod = isinstance(class_, type)

				if not is_classmethod:
					class_ = type(class_)

			functions: list = cls.get_functions_in_class(class_=class_, classmethods=is_classmethod, dynamic_only=True)
			completions: list[dict] = [{'name': name, 'attributes': attributes} for name, attributes in functions.items()]

		return sorted(completions, key=lambda completion: completion['name'].lower())
