import re
import ast
import inspect
import textwrap
from inspect import Parameter
from pydantic import BaseModel
from types import FunctionType
from typing import Any, Callable, Optional


class FunctionSignature(BaseModel):

	name: str
	description: Optional[str] = None
	arguments: Optional[list[dict]]

	has_kwargs: bool
	return_type: Optional[str] = None
	raw_signature: Optional[str] = None

	@classmethod
	def get_signature_for_code(cls, code: str, require_types: bool = True) -> 'FunctionSignature':
		"""
		Returns the signature of a function definition

		e.g. `def send_message(arg1: str, arg2: bool)` -> `('send_message', {'arg1': '…', 'arg2': '…'})`

		@param code(str): raw function code or just the `def …` line
		@return (FunctionSignature): function signature
		"""

		tree: ast.Module = None

		try:
			tree: ast.Module = ast.parse(f'{code}\n\tpass' if code.strip().endswith(('"""', "'''", ':')) else code)

		except IndentationError as error:
			raise IndentationError(code)

		function_node: ast.Node = tree.body[0]

		# remove the `def ` prefix and `:` suffix
		# `def send_message(…):` -> `send_message(…)`
		code = code.removeprefix('async def ').removeprefix('def ').removesuffix(':')

		full_function_name = code.split('(', 1)[0]

		class_name, function_name = full_function_name.split('.') if '.' in full_function_name else (None, full_function_name)
		description: str = ast.get_docstring(function_node)

		# get the arguments
		arguments: list[dict[str, Any]] = []
		has_kwargs: bool = '**kwargs' in code
		return_type: str = ast.unparse(function_node.returns) if function_node.returns else None

		# if the argument has no type hinting, raise an exception
		# e.g. `def send_message(arg1: str):` (should be `def send_message(arg1: str) -> str:`)
		if not return_type and require_types:
			raise SyntaxError(f'function \'{function_name}\' has no return type (e.g. "def {function_name}(…) -> str:")')

		# get optional/required arguments
		arguments_count: int = len(function_node.args.args)
		defaults_count: int = len(function_node.args.defaults)
		required_count: int = arguments_count - defaults_count

		for argument_index, argument in enumerate(function_node.args.args):

			if any(_argument.get('name') == argument.arg for _argument in arguments):
				raise SyntaxError(f'duplicate argument \'{argument.arg}\' in function definition: \'{function_name}\'')

			argument_type: str = ast.unparse(argument.annotation) if argument.annotation else None

			# if the argument has no type hinting, raise an exception
			# e.g. `def send_message(arg1)` (should be `def send_message(arg1: str)`)
			if require_types and not argument_type:
				raise SyntaxError(f'argument \'{argument.arg}\' has no type hint set: \'{function_name}\'')

			# determine if the argument is optional
			is_optional: bool = argument_index >= required_count

			arguments.append({'name': argument.arg, 'type': ast.unparse(argument.annotation) if argument.annotation else None,
							  'optional': is_optional})

		return FunctionSignature(name=function_name, description=description, arguments=arguments, has_kwargs=has_kwargs, return_type=return_type)

	def get_description_for_argument(self, name: str) -> str:
		"""
		Returns the description of an argument
		"""

		if not hasattr(self, '_argument_definitions'):

			if self.description is None:
				return None

			self._argument_definitions = {match[0]: match[1] for match in re.findall(r'@param\s+(\w+)\(.*?\):\s+(.*)', self.description)}

		return self._argument_definitions.get(name)


class Function(BaseModel, Callable):

	_range_start: Optional[int] = None
	_range_end: Optional[int] = None

	code: Optional[str] = None
	callable_: Optional[Callable] = None

	is_dynamic: bool
	decorators: list[str]
	signature: FunctionSignature

	@classmethod
	def get_function_for_code(cls, code: str, dynamic_only: bool = False) -> 'Function':
		"""
		Returns a callable instance of `Function` for a given function code

		e.g. `def send_message(…):\n\t…`
		"""

		functions: list[Function] = list(Function.get_functions_for_code(code=code).values())

		if not functions:
			raise Exception(f'the code has no valid functions ({code=})')

		return functions[0]

	@classmethod
	def get_function_for_callable(cls, callable_: Callable, dynamic_only: bool = False) -> 'Function':
		"""
		Returns a callable instance of `Function` for a given function (callable)
		"""

		code: str = inspect.getsource(callable_)

		# check if the function is a classmethod, then deindent
		if isinstance(callable_, classmethod) or hasattr(callable_, '__func__'):

			code = textwrap.dedent(code)
			code = code.split('@classmethod')[-1]

		# if it's a function within a class, then deindent
		elif '.' in callable_.__qualname__:
			code = textwrap.dedent(code)

		function: Function = Function.get_function_for_code(code=code, dynamic_only=dynamic_only)
		function.callable_ = callable_
		function.is_dynamic = False
		return function

	@classmethod
	def get_functions_for_code(cls, code: str, dynamic_only: bool = False) -> list[dict]:
		"""
		Returns a list of dictionaries of function definitions
		"""

		functions: dict[str, Function] = {}
		tree: ast.Module = ast.parse(code)
		class_name: str = None

		for node in ast.walk(tree):

			# if this is a class definition, cache the class name
			# e.g. `class Status:` -> `Status`
			if class_name is None and isinstance(node, ast.ClassDef):
				class_name = node.name

			if isinstance(node, ast.FunctionDef):

				# if we only want dynamic functions, check if they have `@Utilities.dynamic` decorator
				if dynamic_only and not any(decorator for decorator in node.decorator_list if isinstance(decorator, ast.Attribute) and decorator.attr == 'dynamic'):
					continue

				decorator_list: list[ast.Name] = [decorator for decorator in node.decorator_list if isinstance(decorator, ast.Name)]

				name: str = node.name
				is_property: bool = any(decorator.id == 'property' for decorator in decorator_list)
				description: str = ast.get_docstring(node)

				# e.g. `property`, `classmethod`
				decorator_ids: list[str] = [decorator.id for decorator in decorator_list]

				# if this is the `__init__` function of the class
				is_init: bool = name == '__init__'

				if is_init:
					decorator_ids.append('classmethod')

				# skip any internal functions/properties
				# e.g. `_internal_function_…` and `__dict__`
				if name.startswith('_') and not is_init:
					continue

				args: list = [arg for arg in node.args.args if arg.arg not in {'self', 'cls'}]
				defaults: list = node.args.defaults

				# `defaults` in ast is each argument's default value
				# the length of it is not always the same as the number of
				# arguments, so we insert `None` to match the length
				if len(args) != len(defaults):

					for arg_index in range(len(args) - len(defaults)):
						defaults.insert(0, None)

				if is_property:

					# e.g. `def test():\n\tpass` -> `def test()`
					# 	   `def test() -> int:\n\tpass` -> `def test() -> int`
					raw_signature: str = ast.get_source_segment(source=code, node=node).split(':\n', 1)[0]

					functions[name] = Function(is_dynamic=False, decorators=decorator_ids,
											   signature=FunctionSignature(name=name, description=description, arguments=[],
																		   has_kwargs=False, raw_signature=raw_signature, return_type='TODO'))

				else:

					arguments: list[dict[str, Any]] = []

					for arg_index, arg in enumerate(args):

						default: dict = defaults[arg_index]
						default_value: Any = None

						if default:

							if isinstance(default, ast.List):
								default_value = []

							elif hasattr(default, 'value'):
								default_value = default.value

							# since we don't handle `ast.Name` default values
							# we'll use `_unknown_` which to indicate that there's
							# a default value but it's of an unknown type
							if isinstance(default_value, ast.Name):
								default_value = '_unknown_'

						arguments.append({'name': arg.arg, 'optional': default is not None,
										  'type': ast.unparse(arg.annotation) if arg.annotation else None,
										  'default_value': default_value})

					# get the return class name
					return_type: str = None
					returns: Any = node.returns

					# e.g. `str` or `list`
					if isinstance(returns, ast.Name):
						return_type = returns.id

					elif isinstance(returns, ast.Constant):
						return_type = returns.value

					# e.g. `list[Item]`
					elif isinstance(returns, ast.Subscript):

						# e.g. `list[Item]`
						if returns.slice and isinstance(returns.slice, ast.Name):
							return_type = f'{returns.value.id}[{returns.slice.id}]'

						# e.g. `list['Item']`
						elif returns.slice and isinstance(returns.slice, ast.Constant):
							return_type = f'{returns.value.id}[{returns.slice.value}]'

						# TODO: handle more complex types (e.g. `dict[str, Item]`)
						else:
							return_type = returns.value.id

					elif is_init and class_name:
						return_type = class_name

					# e.g. `def test():\n\tpass` -> `def test()`
					# 	   `def test() -> int:\n\tpass` -> `def test() -> int`
					# 	   `def test() -> int:  \n\tpass` -> `def test() -> int`
					source_segment: str = ast.get_source_segment(source=code, node=node)
					raw_signature, function_code = re.split(r':(?:\W+|)$', source_segment, flags=re.MULTILINE, maxsplit=1)

					functions[name] = Function(is_dynamic=False, decorators=decorator_ids, code=function_code.strip(),
											   signature=FunctionSignature(name=name, description=description, arguments=arguments,
																		   raw_signature=raw_signature, has_kwargs='**kwargs' in raw_signature,
																		   return_type=return_type))

		# workaround to get attributes of class
		code = code.split('@')[0].split('def ')[0].strip()

		if '=' in code:

			tree = ast.parse(code)
			nodes: list = []

			for node in ast.walk(tree):

				if isinstance(node, ast.Name):

					node_id: str = node.id

					# e.g. `predictions: Any = []`
					if isinstance(node.ctx, ast.Store):

						if node_id in functions:
							continue

						# skip internal properties
						if node_id.startswith('_'):
							continue

						# skip constants
						if node_id.isupper():
							continue

						raw_signature: str = ast.get_source_segment(source=code, node=node)

						functions[node_id] = Function(is_dynamic=False, decorators=['property'],
													  signature=FunctionSignature(name=node_id, description=None,
																				  arguments=[], raw_signature=raw_signature, has_kwargs=False,
																				  return_type='TODO'))

				elif isinstance(node, ast.Assign):

					# skip tuple fields (too complex to parse)
					if len(node.targets) > 1:
						continue

					# e.g. `title`
					target: Any = node.targets[0]

					if isinstance(target, ast.Name):

						target_id: str = target.id

						# skip internal targets
						if target_id.startswith('_'):
							continue

						# skip constants
						if target_id.isupper():
							continue

						raw_signature: str = ast.get_source_segment(source=code, node=node)

						functions[target_id] = Function(is_dynamic=False, decorators=['property'],
														signature=FunctionSignature(name=target_id, description=node.type_comment,
																					arguments=[], raw_signature=raw_signature, has_kwargs=False,
																					return_type='TODO'))
		return functions

	@property
	def __name__(self) -> bool:
		return self.signature.name

	@property
	def __doc__(self) -> bool:
		return self.signature.description or ''

	@property
	def is_classmethod(self) -> bool:
		return 'classmethod' in self.decorators

	@property
	def is_property(self) -> bool:
		return 'property' in self.decorators

	def __call__(self, *args, **kwargs) -> Any:
		"""
		Runs the code inside of this function
		"""

		# if this was initialized from a callable function (not code),
		# call the function directly
		if self.callable_:
			return self.callable_(**kwargs)

		from interlinked.core.dynamic.interpreter import DynamicInterpreter

		restricted: bool = kwargs.pop('restricted', True)
		tool: Tool = kwargs.pop('tool', None)

		return DynamicInterpreter.run_code(code=self.code, variables=kwargs, restricted=restricted)