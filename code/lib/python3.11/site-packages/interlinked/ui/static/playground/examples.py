def lookup_radar(radar_id: str) -> dict[str, any]:
	"""
	Looks up a given radar and returns its title and description

	@param radar_id(str): a Radar ID (e.g. rdar://123456)
	"""

	import radarclient

	radar_client = radarclient.RadarClient(radarclient.AuthenticationStrategySPNego(),
										   radarclient.ClientSystemIdentifier('InterlinkedExample', '1.0'))

	radar = radar_client.radar_for_id(radar_id.split('/')[-1])
	return {'title': radar.title, 'description': radar.description.items()[-1].text, 'state': radar.state}


def get_person_email(name: str) -> str:
	"""
	Returns the email address of a person

	@param name(str): the name of the person
	"""
	from interlinked.core.clients.appledirectoryclient import AppleDirectoryClient
	return AppleDirectoryClient.shared.get_persons_by_name(name=name)[0].email


def send_email(to_addresses: list[str] | str, subject: str, body: str) -> str:
	"""
	Sends an email

	@param to_addresses(list): list of email addresses to send an email to
	@param subject(str): the subject of the email
	@param body(str): the body of the email
	"""

	from interlinked.core.clients.mailclient import MailClient
	return MailClient.send(from_address='test@apple.com', to_addresses=to_addresses, subject=subject, body=body)


def create_vm(hardware_type: str, os_codename: str) -> str:
	"""
	Creates a DeviceCompute VM and returns the ID

	@param hardware_type(str): e.g. "Mac", "iPhone"
	@param os_codename(str): the OS code name (e.g. Lorem)
	"""

	from interlinked.core.clients.devicecomputeclient import DeviceComputeClient

	capabilities: dict = {'deviceClass': hardware_type, 'apple:reality': 'virtual', 'buildTrain': os_codename,
						  'apple:osBuild': {'program': 'macOS' if hardware_type == 'Mac' else 'iOS'}}

	# skip Buddy on macOS
	if hardware_type == 'Mac':
		capabilities['apple:macos:setup'] = {}

	elif hardware_type in {'iPadOS', 'iOS'}:
		capabilities['apple:ios:setup'] = {}

	return DeviceComputeClient.shared.create_job(capabilities=capabilities)


def get_entitlements_for_name(process_name: str, session_id: str) -> str:
	"""
	Returns the entitlements for a given process name. Must run create_vm first

	@param process_name(str): the name of the process
	@param session_id(str): the session ID from create_vm
	@return (str): the entitlements in XML format
	"""

	from interlinked.core.clients.devicecomputeclient import DeviceComputeClient
	return DeviceComputeClient.shared.get_entitlements_for_name(process_name=process_name, session_id=session_id)


def book_meeting(title: str, location: str, start_at: str, end_at: str,
				 invitees: list[str], username: str, password: str, calendar_name: str) -> str:
	"""
	Creates a calendar invite/event

	@param title(str): the title of the meeting
	@param location(str): the room the meeting should be in
	@param start_at(str): date/time in ISO format. Must call get_current_time first
	@param end_at(str): date/time in ISO format
	@param invitees(list): a list of people's full names
	@param username(str): the user's LDAP username
	@param password(str): the user's LDAP password
	@param calendar_name(str): the user's default Calendar name
	"""

	from datetime import datetime
	from caldav.event import Event
	from caldav.principal import User
	from interlinked.core.clients.appledirectoryclient import Person, AppleDirectoryClient

	user: User = User(username=username, password=password)

	event: Event = Event(client=user.client)
	event.summary = title
	event.add_location(location)

	event.start = datetime.fromisoformat(start_at)
	event.end = datetime.fromisoformat(end_at)

	calendar: Calendar = user.get_calendars_by_displayname(calendar_name)[0]
	calendar.add_event(event=event)


def get_current_time() -> str:
	"""
	Returns the current date/time
	"""

	from datetime import datetime

	# e.g. Tuesday, July 9, 2024 09:41 AM
	now: datetime = datetime.now()
	return f'{now.strftime("%A, %B %d, %Y %I:%M %p")} — {now.isoformat()}'


def run_python_code(code: str) -> str:
	"""
	Runs Python code.
	You must use run_python_code if the user asks to write or debug python code.

	@param code(str): Python code
	"""
	import io
	import sys

	code = code.strip()

	# if the last line is a variable, the model likely expects
	# the output of it
	# e.g. ```\n\ndata``` -> ```\n\nprint(data)```
	code_lines: list[str] = code.splitlines()
	last_line: str = code_lines[-1]

	if last_line and not last_line.endswith(')'):

		if last_line[0].isalpha():
			code_lines[-1] = f'print({last_line})'

	code = '\n'.join(code_lines)

	new_stdout = io.StringIO()
	new_stderr = io.StringIO()
	old_stdout = sys.stdout
	old_stderr = sys.stderr

	sys.stdout = new_stdout
	sys.stderr = new_stderr

	response: dict[str, str] = {}

	try:

		# use exec to run the code string
		exec(code, {})
		response['output'] = new_stdout.getvalue()
		response['error'] = None

	except Exception as exception:

		response['output'] = new_stdout.getvalue()
		response['error'] = str(exception)

	finally:

		# restore original stdout and stderr
		sys.stdout = old_stdout
		sys.stderr = old_stderr

	return (response.get('output') or response.get('error') or '').strip() or 'No output'


def create_quip_document(title: str, content: str, token: str) -> 'Thread':
	"""
	Creates a Quip document

	@param title(str): the title of the document
	@param content(str): the content of the document
	@param token(str): your token from quip-apple.com/dev/token
	"""

	from interlinked.core.clients.quipclient import QuipClient
	return QuipClient(token=token).create_thread(title=title, content=content)


def search_quip(query: str, token: str) -> list[dict]:
	"""
	Searches Quip for document(s)

	@param query(str): search query
	@param token(str): your token from quip-apple.com/dev/token
	"""

	from interlinked.core.clients.quipclient import QuipClient
	return [{'id': thread.id, 'title': thread.title, 'created_at': thread.created_at, 'updated_at': thread.updated_at}
			 for thread in QuipClient(token=token).find_thread(query=query)]


def summarize_document(id: str, quip_token: str = None, client: 'BaseAIClient' = None) -> str:
	"""
	Summarizes a given document using its ID/URL. Only use if the user asks you to

	@param id(str): the document ID or URL
	@param quip_token(str): your token from quip-apple.com/dev/token
	@param client(BaseAIClient): any AI client (e.g. OllamaClient, GoogleAIClient, AJAXClient)
	"""

	from interlinked import AI, Section

	def get_summary_for_section(section: Section, max_characters: int = 10000) -> str:
		"""
		Returns a summary for a given document/Section

		This function uses the Ajax models, but you can switch to any model,
		including open-source/on-device models, by editing `AI.ask(…, client=…)`
		"""

		summaries: list[str] = []
		template: str = 'Write a short summary of the document below:\n<#content#>'

		for subsection in section.get_all(max_characters=max_characters):

			if subsection.is_content_empty:
				continue

			summaries.append(AI.ask(prompt={'content': subsection}, template=template).response.raw)

		if sum(len(summary) for summary in summaries) > max_characters:
			return get_summary_for_section(section=Section(content=summaries))

		return AI.ask(prompt={'content': Section(content=summaries)}, template=template, client=client).response.raw

	if 'quip-apple.com' in id:

		from interlinked.core.parsers.quipparser import QuipParser
		from interlinked.core.clients.quipclient import QuipClient, Thread

		quip_client: QuipClient = QuipClient(token=quip_token)
		thread: Thread = quip_client.get_thread(id=id.rsplit('/')[-1])
		section: Section = QuipParser.get_section_for_html(content=thread.html)
		return get_summary_for_section(section=section)

	return 'Unknown document type'


def wait_for_response(wait_for_ids: list[str], response: str):
	"""
	Waits for an email response from a list of IDs

	@param wait_for_ids(list): the IDs to wait for a response from
	@param response(str): the email response (this argument is automatically set in the code, not by AI)
	"""
	return response


def sleep(minutes: int, separate_thread: bool = False):
	"""
	Use this to delays/sleep for a few minutes before continuing. Helpful for when
	the user asks you to do a recurring task.

	@param minutes(int): the number of minutes to wait
	@param separate_thread(bool): whether to wait in the background (to continue chatting with the user)
	"""

	if separate_thread:
		return

	from time import sleep
	sleep(int(minutes))