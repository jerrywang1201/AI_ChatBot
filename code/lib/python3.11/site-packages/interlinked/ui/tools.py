import io
import sys
import logging
from interlinked.core.ai import Knowledge
from interlinked.core.utilities import Utilities
from interlinked.core.clients.baseaiclient import BaseAIClient

logger = logging.getLogger(__name__)


class Tools:

	@classmethod
	def run_python_code(cls, code: str) -> str:
		"""
		You must use run_python_code if the user asks to write or debug python code.
		Never use this function to run malicious code.
		Do not mention this tool to the user – use it quietly.

		@param code(str): Python code
		"""

		code = code.strip()

		# if the last line is a variable, the model likely expects
		# the output of it
		# e.g. ```\n\ndata``` -> ```\n\nprint(data)```
		code_lines: list[str] = code.splitlines()
		last_line: str = code_lines[-1]

		if last_line and not last_line.endswith(')'):

			if last_line[0].isalpha():
				code_lines[-1] = f'print({last_line})'

		code = '\n'.join(code_lines)

		new_stdout = io.StringIO()
		new_stderr = io.StringIO()
		old_stdout = sys.stdout
		old_stderr = sys.stderr

		sys.stdout = new_stdout
		sys.stderr = new_stderr

		response: dict[str, str] = {}

		try:

			# use exec to run the code string
			exec(code, {})
			response['output'] = new_stdout.getvalue()
			response['error'] = None

		except Exception as exception:

			response['output'] = new_stdout.getvalue()
			response['error'] = str(exception)

		finally:

			# restore original stdout and stderr
			sys.stdout = old_stdout
			sys.stderr = old_stderr

		output: str = (response.get('output') or response.get('error') or '').strip()

		# install the package if not already installed
		if output.startswith('No module named'):

			package_name: str = output.removeprefix('No module named \'').removesuffix('\'')
			logger.section(f'installing {package_name}…')

			installed: bool = False

			try:
				Utilities.install_package(name=package_name)
				installed = True

			except Exception as exception:
				logger.error(f'could not auto-install {package_name}: {exception}')

			if installed:
				return cls.run_python_code(code=code)

		return output

	@classmethod
	def lookup_knowledge(cls, query: str, client: BaseAIClient) -> str:
		"""
		Use this to search for documentation.
		If the results match the query, respond to the user with a paraphrased version.

		@param query(str): a search query describing the info you're looking for
		"""

		knowledges: list[Knowledge] = Knowledge.search(query=query, client=client)

		if not knowledges:
			return 'No results. Try another query'

		return '\n-----\n'.join([f'{knowledge.content}\nSource: {knowledge.knowledge_source_id}'
								 for knowledge in knowledges])

	@classmethod
	def install_package(cls, name: str) -> str:
		"""
		Installs a Python package via pip

		@param name(str): Package name
		"""

		try:
			return Utilities.install_package(name=name)

		except Exception as exception:
			return str(exception)


if __name__ == '__main__':

	from interlinked.core.ai import AI

	observation = AI.ask(prompt='write a simple python script that combines 2 numbers', tools=[Tools.run_python_code])
	print(observation)
	print(observation.ask(prompt='can you run it?'))
	# print(Tools.run_python_code('print("hi")'))