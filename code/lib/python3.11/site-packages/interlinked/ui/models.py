import os
import re
import json
import uuid
import signal
import random
import base64
import logging
import importlib
from zoneinfo import ZoneInfo
from types import FunctionType
from enum import Enum, IntEnum
from typing import Any, Optional
from datetime import datetime, timezone
from sqlalchemy.orm import selectinload
from sqlalchemy.exc import NoResultFound
from sqlmodel.main import SQLModelMetaclass
from pydantic_core import PydanticUndefined
from sqlalchemy.engine.reflection import Inspector
from sqlalchemy.orm.attributes import flag_modified
from pydantic import BaseModel, Field, PrivateAttr, SkipValidation,  \
					 field_serializer, field_validator
from sqlmodel import select, inspect, Field as SQLField, SQLModel, Relationship
from sqlalchemy import Table, MetaData, Boolean, Column, ForeignKey, Integer, String,  \
					   BigInteger, delete, text, schema, inspect, or_, func

from interlinked.core.tool import Tool
from interlinked.core.config import Config
from interlinked.core.utilities import Utilities
from interlinked.core.dynamic.functions import Function
from interlinked.core.ai import AI, Knowledge, UserError
from interlinked.core.applet import Applet as BaseApp, MCP
from interlinked.core.clients.slackclient import SlackClient
from interlinked.core.clients.qdrantclient import QdrantClient
from interlinked.core.clients.databaseclient import DatabaseClient
from interlinked.core.clients.appledirectoryclient import AppleDirectoryClient, Person

if Config.current.USE_POSTGRES:
	from sqlalchemy.dialects.postgresql import JSONB

else:
	from sqlalchemy.dialects.sqlite import JSON as JSONB

logger = logging.getLogger(__name__)


# monkey-patch SQLModel to make the syntax for querying simpler
from sqlalchemy.sql import dml
from sqlmodel.sql import expression

def first(self, session: 'Session' = None):

	if session:
		return session.exec(self).first()
	else:

		with DatabaseClient.shared.get_managed_session() as session:
			return session.exec(self).first()


def _all(self):

	with DatabaseClient.shared.get_managed_session() as session:
		return session.exec(self).all()


def _count(self):

	with DatabaseClient.shared.get_managed_session() as session:
		return session.exec(self).count()


def _execute(self):

	with DatabaseClient.shared.get_managed_session() as session:
		session.exec(self)
		return session.commit()


expression.SelectOfScalar.first = first
expression.SelectOfScalar.all = _all
expression.SelectOfScalar.count = _count
dml.Delete.execute = _execute


class BaseSQLModel(SQLModel):

	@classmethod
	def create_all_models(cls):
		SQLModel.metadata.create_all(DatabaseClient.shared.engine)

	@classmethod
	def migrate(cls):
		"""
		Automatically adds new columns
		"""

		def _get_model_classes(cls) -> set[Any]:
			"""
			Returns all model classes that inherit BaseSQLModel directly or indirectly
			"""
			subclasses: set[Any] = set(cls.__subclasses__())
			nested_subclasses: set[Any] = {subclass for class_ in subclasses for subclass in _get_model_classes(class_)}
			return subclasses.union(nested_subclasses)

		# load the tables in the database and compare them with the code
		inspector: Inspector = inspect(DatabaseClient.shared.engine)
		meta: MetaData = MetaData()
		meta.reflect(bind=DatabaseClient.shared.engine)

		for model_class in _get_model_classes(BaseSQLModel):

			# make sure `model_class` is a table
			if not hasattr(model_class, '__table__'):
				continue

			model_instance: Any = model_class()
			table_name: str = model_instance.__table__.name

			# tables not created yet are auto-created by `create_all_models`
			if table_name not in inspector.get_table_names():
				continue

			table_columns: dict[str, Any] = {column['name']: column for column in inspector.get_columns(table_name)}
			model_columns: list[Any] = model_instance.__table__.columns

			for column_name, column_obj in model_columns.items():

				if column_name not in table_columns:

					logger.info(f'adding field to table (name={column_name}, model_name={table_name})')

					column_type: str = column_obj.type.compile(dialect=DatabaseClient.shared.engine.dialect)

					# Generating the SQL command for adding a column
					raw_sql: str = f'ALTER TABLE {table_name} ADD COLUMN {column_name} {column_type}'

					if not column_obj.nullable:
						raw_sql = f'{raw_sql} NOT NULL'

					# if there's a default value set
					if column_obj.default is not None:

						default_value: Any = column_obj.default.arg if callable(column_obj.default.arg) else column_obj.default.arg

						# make sure it's not a function (e.g. `datetime.now`)
						if not isinstance(default_value, FunctionType):
							raw_sql = f'{raw_sql} DEFAULT {default_value}'

					# create the field
					with DatabaseClient.shared.engine.connect() as connection:

						connection.execute(text(raw_sql))
						connection.commit()

			# remove unused columns/fields
			for column_name, column in table_columns.items():

				if column_name not in model_columns:

					# only in development
					if Config.current.is_development and not Config.current.USE_POSTGRES:

						logger.info(f'removing field from table (name={column_name}, model_name={table_name})')

						try:
							with DatabaseClient.shared.engine.connect() as connection:

								connection.execute(text(f'ALTER TABLE {table_name} DROP COLUMN {column_name}'))
								connection.commit()

						except Exception as exception:
							logger.error(f'could not remove field (name={column_name}, model_name={table_name})')

					else:
						logger.info(f'skipping removing field from table (name={column_name}, model_name={table_name})')

		# update any enums
		if Config.current.USE_POSTGRES:

			# TODO: this should be automatically determined from each model
			enum_classes: Any = [KnowledgeSourceEnum]

			for enum_class in enum_classes:

				enum_table_name: str = enum_class.__name__.lower()

				with DatabaseClient.shared.engine.connect() as connection:

					result = connection.execute(text(f'SELECT unnest(enum_range(NULL::{enum_table_name}))'))
					table_labels: list[str] = [row[0] for row in result]
					enum_class_labels: list[str] = [label.value for label in enum_class]

					for value in list(set(enum_class_labels) - set(table_labels)):

						connection.execute(text(f'ALTER TYPE "{enum_table_name}" ADD VALUE \'{value}\''))
						connection.commit()

	@classmethod
	def create(cls, session: 'Session' = None, **kwargs):
		"""
		Creates an instance + row of this model
		"""

		def _create(session: 'Session' = None, **kwargs):

			instance: Any = cls(**kwargs)
			session.add(instance)
			session.commit()
			session.refresh(instance)

			return instance

		if session:
			return _create(session=session, **kwargs)

		else:
			with DatabaseClient.shared.get_managed_session() as session:
				return _create(session=session, **kwargs)


	@classmethod
	def get_or_none(cls, session: 'Session' = None, **kwargs):
		"""
		Returns one row or `None`
		"""

		if session:

			try:
				return session.exec(select(cls).filter_by(**kwargs)).one_or_none()

			except NoResultFound:
				return None
		else:

			with DatabaseClient.shared.get_managed_session() as session:

				try:
					return session.exec(select(cls).filter_by(**kwargs)).one_or_none()

				except NoResultFound:
					return None

	@classmethod
	def get_or_create(cls, session: 'Session' = None, **kwargs) -> tuple[Any, bool]:
		"""
		Returns a row or creates it
		"""

		def _get_or_create(session: 'Session', **kwargs) -> tuple[Any, bool]:

			try:
				return session.query(cls).filter_by(**kwargs).one(), False

			except NoResultFound:
				pass

			return cls.create(**kwargs), True

		if session:
			return _get_or_create(session=session, **kwargs)

		else:

			with DatabaseClient.shared.get_managed_session() as session:
				return _get_or_create(session=session, **kwargs)

	@classmethod
	def select(cls):
		"""
		Method for convenience since SQLAlchemy's syntax is too long
		"""
		return select(cls)

	@classmethod
	def delete(cls):
		"""
		Method for convenience since SQLAlchemy's syntax is too long
		"""
		return delete(cls)

	def save(self, session: 'Session' = None) -> None:
		"""
		Saves changes
		"""

		def _save(session: 'Session') -> None:

			session.add(self)
			session.commit()
			session.refresh(self)

		if session:
			return _save(session)

		else:

			with DatabaseClient.shared.get_managed_session() as session:
				return _save(session)


""" User """

class User(BaseModel):
	"""
	Not a database model
	"""

	dsid: Optional[int] = 0
	email: Optional[str] = None
	last_name: Optional[str] = None
	first_name: Optional[str] = None

	group_dsids_: list[int] = None
	daw_token: Optional[str] = None

	core_group_dsids_: Optional[list[int]] = None

	latest_version: str | None = None
	has_latest_version: bool | None = False

	setups: Optional[list['Setup']] = None

	@property
	def group_dsids(self) -> list[int]:
		"""
		Returns a list of groups' DSIDs this user is in
		"""

		if self.group_dsids_ is None:
			self.group_dsids_ = AppleDirectoryClient.shared.get_group_dsids_for_person_dsid(dsid=self.dsid)

		return self.group_dsids_

	@property
	def core_group_dsids(self) -> list[int]:
		"""
		Returns a list of groups' DSIDs this user is in
		"""

		if self.core_group_dsids_ is None:
			self.core_group_dsids_ = AppleDirectoryClient.shared.get_matching_group_dsids(group_dsids=[1000168827, 9438527, 12075573, 13554683, 13438964, 1000152537],
																						  person_dsid=self.dsid)

		return self.core_group_dsids_

	@property
	def is_admin(self) -> bool:
		"""
		Returns whether this user is an admin
		"""
		return 9438527 in self.core_group_dsids

	def get_setups(self, session: 'Session') -> list['Setup']:
		"""
		Returns a list of Setups for this user
		"""
		query = session.query(Setup).where(Setup.created_by == self.dsid)
		return query.all()


""" Workflow """

class BaseWorkflow:

	# if this is a Python file, this would represent
	# the class name
	name: str


""" Configuration """

class BaseConfiguration(BaseSQLModel):

	id: Optional[int] = SQLField(default=None, primary_key=True)

	# when this configuration was created/modified
	created_at: Optional[datetime] = SQLField(default_factory=datetime.now)
	modified_at: Optional[datetime] = None

	# the DSID of the person that created/modified this configuration
	created_by: Optional[int] = None
	modified_by: Optional[int] = None

	# the data set by the user to configure the workflow
	data: dict = SQLField(sa_column=Column(JSONB))

	@classmethod
	def get_defaults(cls) -> dict[str, str]:
		return {field_name: field.default if field.default is not PydanticUndefined else None for field_name, field in cls.model_fields['data'].annotation.model_fields.items()}

	@classmethod
	def validate_data(cls, data: dict[str, Any]):
		raise NotImplementedError()


class Configuration(BaseConfiguration, table=True):

	# the Workflow this configuration is for
	workflow_name: str

	# the Apple Directory group that can access this configuration
	group_dsid: int

	# if this Configuration requires disclosures
	project_names: Optional[list[str]] = SQLField(default=[], sa_column=Column(JSONB))

	# when automation started this configuration
	started_at: Optional[datetime] = None
	ended_at: Optional[datetime] = None

	# if this configuration is enabled (whether it should run)
	enabled: Optional[bool] = True

	# AI's suggestions
	threads: list['Thread'] = Relationship(back_populates='configuration')
	suggestions: list['Suggestion'] = Relationship(back_populates='configuration')
	knowledge_sources: list['KnowledgeSource'] = Relationship(back_populates='configuration')

	@property
	def workflow_class(self) -> Any:
		"""
		Returns the WorkflowClass for this Configuration

		For example, if the `workflow_name` is `screen_radars`, the class returned is `AIScreener`
		"""

		module = importlib.import_module(f'interlinked.core.workflows.{self.workflow_name}.workflow')
		WorkflowClass: Any = next((cls for name, cls in vars(module).items() if isinstance(cls, type) and issubclass(cls, BaseWorkflow) and  \
								   cls is not BaseWorkflow), None)

		return WorkflowClass

	@classmethod
	def get_for_user(cls, user: User, workflow_name: str) -> list['Configuration']:
		"""
		Returns all configurations a given DSID has access to
		"""

		if Config.current.is_development:
			return Configuration.select().where(Configuration.workflow_name == workflow_name).all()

		if not Config.current.USE_POSTGRES:

			return Configuration.select().where(Configuration.workflow_name == workflow_name,
												or_(Configuration.group_dsid.in_(user.group_dsids),
													text('json_extract(project_names, \'$[0]\') = \'todo\''),
													Configuration.group_dsid == -1)).all()

		return Configuration.select().where(Configuration.workflow_name == workflow_name,
											or_(Configuration.group_dsid.in_(user.group_dsids), Configuration.group_dsid == -1)).all()

	def run(self, *args, **kwargs) -> None:
		"""
		Runs the Workflow for this Configuration (if the Workflow is directly runnable)
		"""

		# cache the previous `started_at` if an error occurs
		previous_started_at: datetime = self.started_at
		previous_ended_at: datetime = self.ended_at

		self.started_at = datetime.now()
		self.ended_at = None
		self.save()

		try:
			self.workflow_class.run(configuration_id=self.id, **kwargs)

		except Exception as exception:

			# revert to the previous `started_at`, so this configuration runs again as soon as possible
			self.started_at = previous_started_at
			self.ended_at = previous_ended_at
			self.save()

			raise exception

		self.ended_at = datetime.now()
		self.save()

	def apply(self, values: dict[str, Any], dsid: int):

		if not self.created_by:
			self.created_by = dsid

		else:

			# update modified_* fields
			self.modified_at = datetime.now()
			self.modified_by = dsid

		for key, value in values.items():

			# don't allow changing some fields
			if key.startswith(('modified_', 'created_', 'enabled')):
				raise Exception('manually changing the value of `modified_/created_/enabled` is not permitted')

			if key == 'group_dsid':

				if not value:

					# this should be replaced with a Pydantic exception
					from fastapi import HTTPException
					raise HTTPException(status_code=422, detail='Please add a Directory Group ID')

				# -1 makes all configurations public
				if value != -1:

					if value != self.group_dsid and not Config.current.is_development:

						# make sure the user is part of the group
						persons: list[Person] = AppleDirectoryClient.shared.get_persons_for_group_dsid(dsid=value, nested=True)

						if not any(person for person in persons if person.dsid == dsid):
							raise Exception(f'The group members are either hidden or you are not a group member')

					# make sure the group is flat (does not have nested groups)
					if AppleDirectoryClient.shared.get_is_group_has_nested(dsid=value):
						raise Exception(f'The group "{value}" has nested groups. For added security, we only support non-nested groups. '
										'For example, you can use your core team group')

		# validate `data` according to the workflow's configuration
		module = importlib.import_module(f'interlinked.core.workflows.{values.get("workflow_name", self.workflow_name)}.workflow')
		ConfigurationClass: Any = next((cls for name, cls in vars(module).items() if isinstance(cls, type) and issubclass(cls, BaseConfiguration) and  \
										cls is not BaseConfiguration and cls is not Configuration), None)

		if ConfigurationClass and ConfigurationClass.model_fields['data'].annotation != dict:

			configuration_data: Any = ConfigurationClass.model_fields['data'].annotation(**values['data'])

			if hasattr(configuration_data, 'custom_validate'):
				configuration_data.custom_validate(values=values, previous=ConfigurationClass.model_fields['data'].annotation(**self.data) if self.id else None, dsid=dsid)

		for key, value in values.items():

			# don't allow changing some fields if they are already set
			if key == 'workflow_name' and getattr(self, key, None):
				continue

			setattr(self, key, value)

	def delete(self) -> None:
		"""
		Deletes this Configuration
		"""

		self.reset(current_only=False)

		with DatabaseClient.shared.get_managed_session() as session:

			session.delete(self)
			session.commit()

	def reset(self, current_only: bool = False) -> None:
		"""
		Resets this Configuration
		"""

		# if this is a Knowledge configuration, delete all Knowledge
		if self.workflow_name == 'knowledge':
			Knowledge.delete_all(knowledge_source_ids=[knowledge_source.id for knowledge_source in KnowledgeSource.select().where(KnowledgeSource.configuration_id == self.id).all()])

		if current_only:
			Suggestion.delete().where(Suggestion.configuration_id == self.id, Suggestion.result.is_(None)).execute()

		else:
			Suggestion.delete().where(Suggestion.configuration_id == self.id).execute()

		KnowledgeSource.delete().where(KnowledgeSource.configuration_id == self.id).execute()


""" Suggestion """

class SuggestionResultEnum(IntEnum):

	# the suggestion was invalid and no alternative
	# was given by the user
	invalid: int = 0

	# the suggestion was valid and accepted by the user
	valid: int = 1

	# the suggestion was invalid and an alternative
	# was given by the user
	modified: int = 2


class Suggestion(BaseSQLModel, table=True):

	id: Optional[int] = SQLField(default=None, primary_key=True)

	name: str

	# the value AI suggested for this field
	value: str
	display_value: Optional[str]

	# AI's thoughts/reasoning for suggesting this value
	thought: Optional[str]

	# the ID of the item this suggestion is for
	item_external_id: str

	# the user's action on this suggestion
	result: Optional[SuggestionResultEnum]

	# when the user actioned the suggestion
	result_datetime: Optional[datetime]

	# if the `result` is `.invalid` or `.modified`,
	# the actual value the user used
	result_value: Optional[str]

	# the configuration this suggestion was made by
	configuration_id: Optional[int] = SQLField(default=None, foreign_key='configuration.id')
	configuration: Optional[Configuration] = Relationship(back_populates='suggestions')


""" KnowledgeSource """

class KnowledgeSourceEnum(str, Enum):
	"""
	Internal class
	"""

	stackoverflow: str = 'stackoverflow'
	confluence: str = 'confluence'
	chorus: str = 'chorus'
	github: str = 'github'
	slack: str = 'slack'
	quip: str = 'quip'
	file: str = 'file'
	box: str = 'box'
	pdf: str = 'pdf'

	@classmethod
	def from_raw(cls, raw: str) -> 'KnowledgeSourceEnum':

		raw_lower: str = raw.lower()

		if 'stackoverflow' in raw_lower:
			return KnowledgeSourceEnum.stackoverflow

		elif 'confluence' in raw_lower:
			return KnowledgeSourceEnum.confluence

		elif 'chorus' in raw_lower:
			return KnowledgeSourceEnum.chorus

		elif '.slack.com' in raw_lower:
			return KnowledgeSourceEnum.slack

		elif 'github.' in raw_lower:
			return KnowledgeSourceEnum.github

		elif 'quip-apple' in raw_lower:
			return KnowledgeSourceEnum.quip

		elif '.box' in raw_lower:
			return KnowledgeSourceEnum.box

		elif '.pdf' in raw_lower:
			return KnowledgeSourceEnum.pdf

		elif os.path.exists(raw):
			return KnowledgeSourceEnum.file

		else:
			raise Exception(f'"{raw}" is not a known Knowledge Source')


class KnowledgeSource(BaseSQLModel, table=True):

	__tablename__: str = 'knowledge_source'

	id: Optional[int] = SQLField(default=None, primary_key=True)
	created_at: Optional[datetime] = SQLField(default_factory=datetime.now)

	# the DSID of the person that created/modified this Knowledge Source
	created_by: Optional[int] = None
	modified_by: Optional[int] = None

	source: Optional[KnowledgeSourceEnum]

	# varies based on source (e.g. if this is quip, it'd be the document/folder ID)
	external_id: str
	external_created_at: Optional[datetime] = None
	external_modified_at: Optional[datetime] = None

	# if this is a file, the path to it. if something else, the title
	# not used as a unique identified (use `external_id` instead)
	name: Optional[str] = None

	# used in Playground to help demonstrate the API to the user
	content: Optional[str] = None

	# used to avoid regenerating Knowledge if no changes were made
	content_hash: Optional[str] = None

	# any custom source-specific data/settings
	data: dict = SQLField(sa_column=Column(JSONB))

	# the configuration this `KnowledgeSource` was made by
	configuration_id: Optional[int] = SQLField(default=None, foreign_key='configuration.id')
	configuration: Optional[Configuration] = Relationship(back_populates='knowledge_sources')

	@property
	def display_source(self) -> str:
		"""
		Returns a display representation of the source

		e.g. if `source` is `quip`, this will return `quip-apple.com/ElRgAaaTbxmi`
		"""

		if self.source == KnowledgeSourceEnum.quip:
			return f'https://quip-apple.com/{self.external_id}'

		elif self.source == KnowledgeSourceEnum.confluence:
			return self.external_id

		elif self.source == KnowledgeSourceEnum.chorus:
			return f'https://chorus.apple.com/page/{self.external_id}'

		elif self.source == KnowledgeSourceEnum.pdf:
			return f'PDF {self.external_id}'

		elif self.source == KnowledgeSourceEnum.github:
			return self.external_id

		elif self.source == KnowledgeSourceEnum.stackoverflow:

			if self.external_id.startswith('article'):
				return f'https://stackoverflow.apple.com/articles/{self.external_id.removeprefix("article:")}'

		elif self.source == KnowledgeSourceEnum.slack:
			return self.external_id

		elif self.source == KnowledgeSourceEnum.file:
			return f'file://{self.external_id}'

		raise NotImplementedError()

	@property
	def knowledges(self) -> ['Knowledge']:
		return []

	@classmethod
	def get_for_configuration(cls, config_id: int) -> list['KnowledgeSource']:
		"""
		Returns all `KnowledgeSource`(s) for a given configuration
		"""

		if Config.current.is_development:
			out = KnowledgeSource.select().join(Configuration).  \
								   where(Configuration.id == config_id).all()
			return out

	@classmethod
	def get_for_user(cls, user: User) -> list['KnowledgeSource']:
		"""
		Returns all `KnowledgeSource`(s) a given user has access to
		"""

		if Config.current.is_development:
			out = KnowledgeSource.select().join(Configuration).  \
								   where(Configuration.workflow_name == 'knowledge').all()
			return out

		return KnowledgeSource.select().where(KnowledgeSource.created_by == user.dsid).all()

	def get_has_access(self, user: User) -> bool:
		"""
		Returns whether a given user has access to this KnowledgeSource
		"""

		if not self.configuration_id:
			raise Exception(f'no configuration ID set (knowledge_source.id={self.id})')

		configuration: Configuration = Configuration.get_or_none(id=self.configuration_id)

		if configuration.group_dsid == -1:
			return True

		return configuration.group_dsid in user.group_dsids

	def get_display_source_for_knowledge(self, knowledge: Knowledge) -> str:

		if self.source in {KnowledgeSourceEnum.confluence, KnowledgeSourceEnum.chorus, KnowledgeSourceEnum.quip,
						   KnowledgeSourceEnum.github, KnowledgeSourceEnum.stackoverflow}:
			return f'{self.display_source}#{knowledge.external_id}'

		return self.display_source


""" Thread """

class ThreadSource(IntEnum):

	email: int = 0
	slack: int = 1
	playground: int = 2


class Thread(BaseSQLModel, table=True):

	id: Optional[int] = SQLField(default=None, primary_key=True)
	created_at: Optional[datetime] = SQLField(default_factory=datetime.now)

	# date/time when this was converted to Knowledge
	converted_at: Optional[datetime] = None

	external_id: str
	source: ThreadSource

	_messages: list['Message'] = Relationship(back_populates='thread')

	# the configuration this Thread was made by
	configuration_id: Optional[int] = SQLField(default=None, foreign_key='configuration.id')
	configuration: Optional[Configuration] = Relationship(back_populates='threads')

	@property
	def messages(self) -> list['Message']:
		return Message.select().where(Message.thread_id == self.id).order_by(Message.id).all()


class Message(BaseSQLModel, table=True):

	id: Optional[int] = SQLField(default=None, primary_key=True)
	created_at: Optional[datetime] = SQLField(default_factory=datetime.now)

	# the values depend on the Thread source
	# email:
	# slack:
	sender: Optional[str] = None
	raw: dict = SQLField(sa_column=Column(JSONB))

	thread_id: int = SQLField(default=None, foreign_key='thread.id')
	thread: Optional[Thread] = Relationship(back_populates='_messages')


""" Feedback (Qdrant) """

class Feedback(BaseModel):
	"""
	Used for collecting feedback from users on responses and improving quality of responses
	"""

	__collection_name__: str = 'feedback'

	id: Optional[str] = None

	@classmethod
	def get_or_create(cls, *args, **kwargs) -> tuple[Any, bool]:
		"""
		Returns an existing Feedback or creates it
		"""

		is_new: bool = False
		feedback: Feedback = Feedback.get_or_none(*args, **kwargs)

		# if no matches, create `Feedback`
		if not feedback:

			is_new = True
			feedback = cls.create(*args, **kwargs)

		return feedback, is_new


""" Events & Office Hours """

class Event(BaseSQLModel, table=True):

	id: Optional[int] = SQLField(default=None, primary_key=True)

	# the category/event type
	category_id: Optional[int] = None

	title: Optional[str] = None
	description: Optional[str] = None
	locations: list = SQLField(sa_column=Column(JSONB))

	# when this member was created/modified
	created_at: Optional[datetime] = SQLField(default_factory=datetime.now)
	modified_at: Optional[datetime] = None

	# the DSID of the person that created/modified this event
	created_by: Optional[int] = Field(default=None, sa_column=Column(BigInteger()))
	modified_by: Optional[int] = Field(default=None, sa_column=Column(BigInteger()))

	slack_thread_id: Optional[str] = None
	slack_reply_thread_id: Optional[str] = None

	start_at: Optional[datetime] = None
	end_at: Optional[datetime] = None

	# manually set when voting should be enabled
	can_vote: Optional[bool] = False

	_posts: list['Post'] = Relationship(back_populates='event')
	_attendees: list['EventAttendee'] = Relationship(back_populates='event')

	@property
	def display_title(self) -> str:

		if self.title:
			return self.title.removeprefix('Interlinked ')

		if self.category_id == 0:
			return 'Office Hours'

		elif self.category_id == 1:
			return 'Community Event'

		elif self.category_id == 2:
			return 'Special Event'

		elif self.category_id == 3:
			return 'Walkthrough'

	@property
	def attendee_dsids(self) -> list[int]:
		return [event_attendee.created_by for event_attendee in EventAttendee.select().where(EventAttendee.event_id == self.id).all()]

	def notify_subscribers(self) -> None:
		"""
		Notifies all EventsSubscribers and posts in Slack

		Call this when creating an Event
		"""

		import pathlib
		from interlinked.core.clients.mailclient import MailClient

		BASE_PATH: str = pathlib.Path(__file__).resolve().parent
		STATIC_PATH: str = pathlib.Path(f'{BASE_PATH}/static')

		emails: list[str] = []

		# development-only
		if Config.current.is_development:
			emails = ['interlinked-admin@group.apple.com']

		else:

			for event_subscriber in EventsSubscriber.select().all():

				if Config.current.is_development and event_subscriber.created_by != 2319733545:
					continue

				person: Person = AppleDirectoryClient.shared.get_person_for_dsid(dsid=event_subscriber.created_by)

				if person and person.email:
					emails.append(person.email)

			emails = set(emails + ['Interlinked_AI_Users@group.apple.com'])

			if self.category_id == 0 or (self.title and 'office hours' in self.title.lower()):

				logger.info(f'sending Slack emssage…')

				blocks: list[dict] = [
					{
						'type': 'header',
						'text': {
							'type': 'plain_text',
							'text': ':bubble: Office Hours',
							'emoji': True
						}
					},
					{
						'type': 'section',
						'text': {
							'type': 'mrkdwn',
							'text': 'If you\'re interested in learning more about Interlinked :interlinked:, how to bring AI to your projects today, ask us any questions, chat about <https://interlinked.apple.com/community|Community> ideas, we\'d love to see you at our Office Hours! Everyone at Apple is welcome! :hugging_face:\n\n' \
									'*<https://interlinked.apple.com/events|Add to Calendar › >*'
						}
					},
				]
				self.slack_thread_id = SlackClient.shared.send_message(channel='test-interlinked' if Config.current.is_development else 'help-interlinked', blocks=blocks,
																	   unfurl_links=False, username='Interlinked', icon_emoji='interlinked').get('ts')
				self.save()

		for email in emails:

			logger.info(f'sending email… ({email=})')
			template: str = open(f'{STATIC_PATH}/event_reminder.html', 'r').read()
			template = template.replace('<#event_id#>', str(self.id))
			template = template.replace('<#event_title#>', self.display_title)

			display_start_at: datetime = self.start_at.replace(tzinfo=ZoneInfo('UTC')).astimezone(ZoneInfo('US/Pacific'))
			template = template.replace('<#message#>', f'Join us for {self.display_title} on {display_start_at.strftime("%m/%d/%Y")} at {display_start_at.strftime("%I:%M %p")} PT')

			MailClient.send(to_addresses=[email], from_address='noreply@apple.com',
							subject=f'Sign up for Interlinked {self.display_title}', body=template)


class EventAttendee(BaseSQLModel, table=True):

	id: Optional[int] = SQLField(default=None, primary_key=True)

	# when this member was created/modified
	created_at: Optional[datetime] = SQLField(default_factory=datetime.now)
	modified_at: Optional[datetime] = None

	# the DSID of the person that created/modified this configuration
	created_by: Optional[int] = Field(default=None, sa_column=Column(BigInteger()))
	modified_by: Optional[int] = Field(default=None, sa_column=Column(BigInteger()))

	notified: Optional[bool] = False
	approved: Optional[bool] = False
	final_rsvp: Optional[bool] = None

	event_id: int = SQLField(default=None, foreign_key='event.id')
	event: Optional[Event] = Relationship(back_populates='_attendees')

	# any preferences
	preferences: list = SQLField(sa_column=Column(JSONB))


class EventsSubscriber(BaseSQLModel, table=True):
	"""
	Subscribes to all upcoming events
	"""

	id: Optional[int] = SQLField(default=None, primary_key=True)

	# when this member was created/modified
	created_at: Optional[datetime] = SQLField(default_factory=datetime.now)
	modified_at: Optional[datetime] = None

	created_by: Optional[int] = Field(default=None, sa_column=Column(BigInteger()))


""" Community """

class Member(BaseSQLModel, table=True):

	id: Optional[int] = SQLField(default=None, primary_key=True)
	dsid: int

	# when this member was created/modified
	created_at: Optional[datetime] = SQLField(default_factory=datetime.now)
	modified_at: Optional[datetime] = None


class Post(BaseSQLModel, table=True):

	id: Optional[int] = SQLField(default=None, primary_key=True)

	# when this member was created/modified
	created_at: Optional[datetime] = SQLField(default_factory=datetime.now)
	modified_at: Optional[datetime] = None

	# the DSID of the person that created/modified this configuration
	created_by: Optional[int] = None
	modified_by: Optional[int] = None

	title: str
	description: str
	team_name: Optional[str] = None

	view_count: Optional[int] = 0

	# maps to values in the UI
	category_id: Optional[int] = None

	# if the post is related to an event
	event_id: int | None = SQLField(default=None, foreign_key='event.id')
	event: Optional[Event] = Relationship(back_populates='_posts')
	allows_members: Optional[bool] = False

	_members: list['PostMember'] = Relationship(back_populates='post')
	_comments: list['PostComment'] = Relationship(back_populates='post')
	_reactions: list['PostReaction'] = Relationship(back_populates='post')

	@property
	def has_code(self) -> bool:
		return len(re.findall(r'github\.|stashweb\.', self.description, flags=re.IGNORECASE|re.MULTILINE)) > 0

	@property
	def comments(self) -> list['PostComment']:
		return PostComment.select().where(PostComment.post_id == self.id).order_by(PostComment.id).all()

	@property
	def created_by_person(self) -> Person:

		if not self.created_by:
			return None

		return AppleDirectoryClient.shared.get_person_for_dsid(dsid=self.created_by)

	@property
	def member_dsids(self) -> list[int]:
		return set([post_member.created_by for post_member in PostMember.select().where(PostMember.post_id == self.id).all()] + [self.created_by])

	@property
	def reaction_dsids(self) -> list[int]:

		post_reactions: list[PostReaction] = []

		if self.event_id and (event := Event.get_or_none(id=self.event_id)) and event.can_vote:
			post_reactions = PostReaction.select().where(PostReaction.post_id == self.id, PostReaction.is_vote == True).all()

		else:
			post_reactions = PostReaction.select().where(PostReaction.post_id == self.id).all()

		return [post_reaction.created_by for post_reaction in post_reactions]

	@property
	def reaction_count(self) -> int:

		with DatabaseClient.shared.get_managed_session() as session:
			return session.query(PostReaction).where(PostReaction.post_id == self.id).count()

	@property
	def comment_count(self) -> int:

		with DatabaseClient.shared.get_managed_session() as session:
			return session.query(PostComment).where(PostComment.post_id == self.id).count()

	@property
	def comment_dsids(self) -> list[int]:
		return [post_comment.created_by for post_comment in PostComment.select().where(PostComment.post_id == self.id).all()]


class PostComment(BaseSQLModel, table=True):

	id: Optional[int] = SQLField(default=None, primary_key=True)

	# when this member was created/modified
	created_at: Optional[datetime] = SQLField(default_factory=datetime.now)
	modified_at: Optional[datetime] = None

	# the DSID of the person that created/modified this configuration
	created_by: Optional[int] = None
	modified_by: Optional[int] = None

	content: str

	post_id: int = SQLField(default=None, foreign_key='post.id')
	post: Optional[Post] = Relationship(back_populates='_comments')

	@property
	def created_by_person(self) -> Person:

		if not self.created_by:
			return None

		return AppleDirectoryClient.shared.get_person_for_dsid(dsid=self.created_by)


class PostReaction(BaseSQLModel, table=True):

	id: Optional[int] = SQLField(default=None, primary_key=True)

	# when this member was created/modified
	created_at: Optional[datetime] = SQLField(default_factory=datetime.now)
	modified_at: Optional[datetime] = None

	# the DSID of the person that created/modified this configuration
	created_by: Optional[int] = None
	modified_by: Optional[int] = None

	is_vote: Optional[bool] = False

	post_id: int = SQLField(default=None, foreign_key='post.id')
	post: Optional[Post] = Relationship(back_populates='_reactions')


class PostMember(BaseSQLModel, table=True):
	"""
	If this is a post related to a project, `PostMember` has a list
	of all users who signed up to be a member of the team (excluding the creator)
	"""

	id: Optional[int] = SQLField(default=None, primary_key=True)

	# when this member was created/modified
	created_at: Optional[datetime] = SQLField(default_factory=datetime.now)
	modified_at: Optional[datetime] = None

	# the DSID of the person that created/modified this configuration
	created_by: Optional[int] = None
	modified_by: Optional[int] = None

	post_id: int = SQLField(default=None, foreign_key='post.id')
	post: Optional[Post] = Relationship(back_populates='_members')


""" Community (Qdrant) """

class PostKnowledge(Knowledge):

	__collection_name__ = 'post'


""" Documentation (Qdrant) """

class DocumentationKnowledge(Knowledge):

	__collection_name__ = 'documentation'

	is_code: bool = False
	language: str = 'python'


""" Playground """

class RunStatusEnum(IntEnum):

	running: int = 0
	paused: int = 1
	stopped: int = 2


class Run(BaseSQLModel, table=True):

	id: Optional[int] = SQLField(default=None, primary_key=True)

	created_at: Optional[datetime]
	finished_at: Optional[datetime] = None

	file_path: Optional[str] = None
	external_id: Optional[str] = None

	class_name: Optional[str] = None
	function_name: Optional[str] = None

	pid: Optional[int] = None

	@property
	def status(self) -> int:
		"""
		Returns the status of this Run/process
		"""

		if not self.pid:
			return RunStatusEnum.stopped

		import psutil
		try:

			process = psutil.Process(self.pid)

			if process.name() != 'Python':
				return RunStatusEnum.stopped

			status: str = process.status()

			if status == psutil.STATUS_ZOMBIE:
				return RunStatusEnum.stopped

			elif status == psutil.STATUS_STOPPED:
				return RunStatusEnum.paused

			return RunStatusEnum.running

		except:
			return RunStatusEnum.stopped

	def resume(self):
		"""
		Resume this run
		"""

		try:
			os.kill(self.pid, signal.SIGCONT)

		except:
			pass

	def pause(self):
		"""
		Pauses this run
		"""

		try:
			os.kill(self.pid, signal.SIGSTOP)

		except:
			pass

	def stop(self):
		"""
		Stops this run
		"""

		try:
			os.kill(self.pid, signal.SIGKILL)

		except:
			pass

	""" Serializers """

	def serialize_to_timestamp(self, value: datetime, _info):
		return value.timestamp() if value else None

	created_at_serializer = field_serializer('created_at')(serialize_to_timestamp)
	finished_at_serializer = field_serializer('finished_at')(serialize_to_timestamp)


class Step(BaseSQLModel, table=True):

	id: Optional[int] = SQLField(default=None, primary_key=True)

	created_at: Optional[datetime]
	finished_at: Optional[datetime]

	class_name: Optional[str] = None
	function_name: Optional[str] = None
	level: int = 0

	kwargs: dict = SQLField(sa_column=Column(JSONB))

	# e.g. `{"type": "AIClientResponse", "value": "…"}`
	return_value: dict = SQLField(sa_column=Column(JSONB))

	# the full stack trace for this step
	stack: Optional[list] = SQLField(default=None, sa_column=Column(JSONB))

	run_id: int = SQLField(default=None, foreign_key='run.id')

	""" Serializers """

	def serialize_to_timestamp(self, value: datetime, _info):
		return value.timestamp() if value else None

	created_at_serializer = field_serializer('created_at')(serialize_to_timestamp)
	finished_at_serializer = field_serializer('finished_at')(serialize_to_timestamp)


class Log(BaseSQLModel, table=True):

	id: Optional[int] = SQLField(default=None, primary_key=True)

	created_at: Optional[datetime] = SQLField(default=None)

	content: Optional[str] = None
	step_id: int = SQLField(default=None, foreign_key='step.id')

	""" Serializers """

	def serialize_to_timestamp(self, value: datetime, _info):
		return value.timestamp() if value else None

	created_at_serializer = field_serializer('created_at')(serialize_to_timestamp)


""" API """

class APIKey(BaseSQLModel, table=True):

	id: Optional[int] = SQLField(default=None, primary_key=True)

	# when this API Key was created/modified
	created_at: Optional[datetime] = SQLField(default_factory=datetime.now)
	modified_at: Optional[datetime] = None

	# the DSID of the person that created/modified this API access
	created_by: Optional[int] = Field(default=None, sa_column=Column(BigInteger()))
	modified_by: Optional[int] = Field(default=None, sa_column=Column(BigInteger()))

	# (Optional) the name of the API Key
	# (to help differentiate between models)
	name: Optional[str] = None

	# the use-case for this API Key
	description: Optional[str] = None

	# the hash of the API Key that was provisioned
	value: Optional[str] = None

	# the name of the applet that created this API Key
	# always lowercase
	# options:
	# - genai
	# - endor
	app_name: Optional[str] = None

	# any additional metadata stored by the applet that created this API Key
	questionnaire: Optional[dict] = SQLField(sa_column=Column(JSONB))

	# API keys can be turned off at any time by the user
	enabled: bool = True

	# whether to use FloodGate
	use_proxy: bool = False

	# cost center. automatically generated from the `created_by` DSID
	svp_dsid: Optional[int] = None
	svp_full_name: Optional[str] = None
	department_number: Optional[str] = None

	# rate limits
	rate_limits: dict = SQLField(sa_column=Column(JSONB))

	# true if API Key is used for Platform
	is_for_platform: bool = False

	# indicates that this API Key is only used to track the answer
	# to questionnaire and the user does not actually need to use `in-…`
	is_transient: bool = False

	# for special API Keys
	# available permissions
	# - create_api_key:anthropicclient:genai.apple.com
	# - create_api_key:anthropicclient:endor
	permissions: list[str] = SQLField(default=[], sa_column=Column(JSONB))

	@property
	def client_names(self) -> list[str]:
		"""
		Returns a list of client names this API Key has in its rate-limits
		"""

		if not self.rate_limits:
			return []

		return set([key.split(':', 1)[0] for key in self.rate_limits['chat'].keys()])

	@classmethod
	def create_value(cls) -> str:
		"""
		Creates a random API Key value
		"""
		return f'in-{base64.urlsafe_b64encode(uuid.uuid4().bytes).rstrip(b"=").decode("ascii").replace("_", "").replace("-", "")}'

	@classmethod
	def get_eligibility(cls, dsid: int, client_name: str, type: str = None, **kwargs) -> dict:
		"""
		Checks whether a given person can create an API Key
		"""

		from interlinked.core.clients.googleaiclient import GoogleAIClient

		# if the person is in HWT
		if type is None and AppleDirectoryClient.shared.get_person_for_dsid(dsid=dsid).svp.dsid == 22094965:
			return {'eligible': False, 'reason': 'HWT'}

		elif type == 'code_bases':

			code_bases: str = kwargs['code_bases']

			client: GoogleAIClient = GoogleAIClient()
			client.labels = {'interlinked:location': 'api_key_eligibility'}

			observation: Observation = AI.ask(prompt=
			f'''
			Your task is to determine the user's eligibility to use {client_name.removesuffix("client")} based on whether the user listed any of the:
			Ineligible: FairPlay, Secure Enclave Processor firmware, or sepOS.

			Unless the user lists a name/URL that is explicitly says any of the ineligible names above, they are eligible with no restrictions.
			Only deny if you are over 90% certain.

			If the user input nonsense (random characters), pick `invalid` for restriction.

			Let's respond with the following format:
			Restriction<!type:enum,required:true!>: Any of [highly_sensitive, invalid, none]
			Message<!type:string,required:false!>: A message to the user (if they are not eligible) explaining why they are not eligible.
			Codebases<!type:json,required:true!>: One line list of codebase names (not URLs) the user referenced. JSON format
			---
			User input:
			{code_bases}
			''', client=client)

			return {'eligible': observation.restriction.is_none, 'reason': observation.message}

		return {'eligible': True, 'reason': None}


class APIKeyUsage(BaseSQLModel, table=True):
	"""
	Tracks API key usage per day
	"""

	id: Optional[int] = SQLField(default=None, primary_key=True)

	# when this ask was created/modified (in UTC)
	created_at: datetime

	# `chat`, `embedding`, or `token_count`
	type: str

	# e.g. `googleaiclient`
	client_name: str

	# e.g. `gemini-2.5-pro`
	client_model_name: Optional[str] = None

	# number of requests
	count: int = 0

	api_key_id: int = SQLField(default=None, foreign_key='apikey.id')


""" Model Review (Leaderboard) """

class ModelReview(BaseSQLModel, table=True):

	id: Optional[int] = SQLField(default=None, primary_key=True)

	# when this member was created/modified
	created_at: Optional[datetime] = SQLField(default_factory=datetime.now)
	modified_at: Optional[datetime] = None

	# the DSID of the person that created/modified this review
	created_by: Optional[int] = None
	modified_by: Optional[int] = None

	client_name: str
	client_model_name: str
	rating: Optional[int] = None
	comment: Optional[str] = None

	# maps to values in the UI
	criteria_ids: list[int] = SQLField(default=[], sa_column=Column(JSONB))


class AppletMeta(type):
	"""
	Used to simplify the user experience
	"""

	def __call__(cls, *args, **kwargs):

		instance = super().__call__(*args, **kwargs)
		return instance


class CombinedAppletMeta(AppletMeta, SQLModelMetaclass):
	pass


class Applet(BaseSQLModel, metaclass=CombinedAppletMeta, table=True):
	"""
	Used for Applet
	"""

	id: Optional[int] = SQLField(default=None, primary_key=True)

	# when this member was created/modified
	created_at: Optional[datetime] = SQLField(default_factory=datetime.now)
	modified_at: Optional[datetime] = None

	# the DSID of the person that created/modified this event
	created_by: Optional[int] = Field(default=None, sa_column=Column(BigInteger()))
	modified_by: Optional[int] = Field(default=None, sa_column=Column(BigInteger()))

	# not used
	type: str = 'native'

	# the URL/path to the Applet's code
	# for uploaded Apps, it is `None`
	external_id: Optional[str] = None
	branch_name: Optional[str] = None

	# cached code files
	# for UI, the files will contain the definition + code
	# for backend, the files will contain the definition only
	# e.g. `[{'type': 'backend', 'tools': […]}, …]`
	files: Optional[list] = SQLField(sa_column=Column(JSONB))

	# file paths + function names (`.py`)
	selected_functions: Optional[list] = SQLField(sa_column=Column(JSONB))

	name: str

	# a brief one-line summary of the Applet
	summary: str

	# e.g. `com.apple.ai_screener`
	bundle_id: str

	# Markdown is supported
	description: str

	# maps to values in the UI
	category_id: Optional[str] = None

	# (internal) whether this applet is public and visible in Store
	is_published: Optional[bool] = False

	# review process fields
	request_at: Optional[datetime] = None
	approved_at: Optional[datetime] = None

	# (optional) restrict viewing/using this applet
	# by Apple Directory group
	read_group_dsid: Optional[str] = None

	# (optional) the requirements this applet needs to run
	# - mac
	# - knowledge
	requirements: list = SQLField(sa_column=Column(JSONB))

	# (optional) the names of the other apps this applet depends on
	installation_commands: list = SQLField(sa_column=Column(JSONB))

	# (optional) example messages with AI
	examples: list = SQLField(default=[], sa_column=Column(JSONB))

	# assets
	icon_external_id: Optional[str] = None
	icon_average_color: Optional[str] = None

	banner_external_id: Optional[str] = None
	banner_average_color: Optional[str] = None

	screenshot_external_ids: list = SQLField(default=[], sa_column=Column(JSONB))

	# suggested AI model
	client_name: Optional[str] = None
	client_model_name: Optional[str] = None

	# e.g. `system_message`
	applet_metadata: dict = SQLField(sa_column=Column(JSONB))

	# type: mcp
	mcp: Optional[MCP] = SQLField(default=None, sa_column=Column(JSONB))

	# limit availability to a certain Apple Directory group
	group_dsid: Optional[int] = None

	# kwargs in functions the user needs to fill out
	kwargs: Optional[dict] = SQLField(default=None, sa_column=Column(JSONB))

	# how many times this Applet was viewed
	view_count: Optional[int] = 0

	# how many times this Applet was downloaded
	installation_count: Optional[int] = 0

	_comments: list['AppletComment'] = Relationship(back_populates='applet')

	@classmethod
	def create_from_definition(cls, definition: dict[str, Any], external_id: str = None, upload_assets: bool = True) -> 'Applet':
		"""
		[Internal]
		Creates, saves, and returns an `Applet` given a JSON definition

		@param definition(dict): A dictionary containing the applet name, icon, and more
		@param external_id(str): (Optional) The path or URL to the Applet (`None` for Connected Apps)
		@param upload_assets(bool): Whether to upload icon/banner
		"""

		from interlinked.core.clients.objectstorageclient import ObjectStorageClient

		bundle_id: str = definition['bundle_id'].replace(' ', '_').replace('-', '_')

		if not bundle_id.startswith('com.'):
			raise Exception('bundle_id should start with `com.` (e.g. `com.apple.radar`)')

		applet: Applet = Applet.get_or_none(bundle_id=bundle_id) or Applet(bundle_id=bundle_id)

		# update values
		applet.name = definition['name']

		# make sure we don't unset this accidentally
		if external_id:
			applet.external_id = external_id

		applet.mcp = definition.get('mcp')
		applet.summary = definition.get('summary')
		applet.kwargs = definition.get('kwargs', {})
		applet.description = definition['description']
		applet.requirements = definition.get('requirements')
		applet.category_id = definition.get('category', 'tools')
		applet.installation_commands = definition.get('installation_commands')
		applet.read_group_dsid = int(definition.get('read_group_dsid')) if 'read_group_dsid' in definition else None

		# make sure `Applet` is capitalized
		applet.summary = applet.summary.replace('applet', 'Applet')

		if applet.id:
			applet.modified_at = datetime.now()

		# get the code for the applet
		included_file_paths: list[str] = definition.get('files')
		files: list[dict] = definition.get('files_full') or  \
							Applet.get_files_for_external_id(external_id=external_id, included_file_paths=included_file_paths, is_mcp=definition.get('mcp') is None)

		for file in files:

			# compile each ui file
			if file['type'] == 'ui':

				with open(file['path'], 'r') as _file:
					file['code'] = Applet.get_compiled_code(code=_file.read())

		# if no `mcp` was defined, try to check the description for any MCP definitions
		if not files and not applet.mcp:


			raise Exception('No code files found in the Applet directory.')

		applet.files = files
		flag_modified(applet, 'files')

		if upload_assets:

			# upload icon
			if 'icon_base64' in definition:
				applet.upload_asset(type='icon', data=base64.b64decode(definition['icon_base64']))

			else:

				icon_path: str = None

				if 'icon' in definition:
					icon_path = f'{external_id}/{definition.get("icon")}'

				elif os.path.exists(f'{external_id}/icon.jpg'):
					icon_path = f'{external_id}/icon.jpg'

				elif os.path.exists(f'{external_id}/icon.png'):
					icon_path = f'{external_id}/icon.png'

				if not icon_path or not os.path.exists(icon_path):

					import pathlib
					BASE_PATH: str = pathlib.Path(__file__).resolve().parent
					STATIC_PATH: str = pathlib.Path(f'{BASE_PATH}/static')
					icon_path = f'{STATIC_PATH}/missing_applet_icon.jpg'

				applet.upload_asset(type='icon', data=open(icon_path, 'rb').read())

			# upload banner
			if banner_base64 := definition.get('banner_base64'):
				applet.upload_asset(type='banner', data=base64.b64decode(banner_base64))

			elif banner := definition.get('banner'):
				applet.upload_asset(type='banner', data=open(f'{external_id}/{banner}', 'rb').read())

			# upload screenshots
			if screenshots_base64 := definition.get('screenshots_base64'):

				# delete previous screenshots
				for screenshot_external_id in applet.screenshot_external_ids:
					ObjectStorageClient.shared.delete(key=screenshot_external_id)

				applet.screenshot_external_ids = []

				for screenshot_base64 in screenshots_base64:
					applet.upload_asset(type='screenshot', data=base64.b64decode(screenshot_base64))

			elif screenshots := definition.get('screenshots'):

				# delete previous screenshots
				for screenshot_external_id in applet.screenshot_external_ids:
					ObjectStorageClient.shared.delete(key=screenshot_external_id)

				applet.screenshot_external_ids = []

				for screenshot in screenshots:
					applet.upload_asset(type='screenshot', data=open(f'{external_id}/{screenshot}', 'rb').read())

		# create examples
		if not applet.examples:

			from interlinked.core.clients.googleaiclient import GoogleAIClient

			observation: Observation = None
			client: GoogleAIClient = GoogleAIClient(model_name='gemini-2.0-flash')

			if applet.files:

				observation = AI.ask(
					prompt={'name': applet.name, 'summary': applet.summary, 'description': applet.description,
							'tools': '\n\n'.join([f'{tool["name"]}: {tool["description"]}' for tool in sum([file['tools'] for file in applet.files if 'tools' in file], [])])},
					template='''
				Given the Applet description and functions below, respond with a JSON array containing example questions a user
				may task AI with through this Applet. Here are some examples:
				- [{"prompt": "Look up rdar://1234567", "tool_call": {"function_name": "lookup_radar", "arguments": {"id": "rdar://1234567"}}}, …]
				- [{"prompt": "Find an available meeting room for tomorrow", "tool_call": {"function_name": "get_available_rooms", "arguments": {"when": "tomorrow"}}}, …]
				- [{"prompt": "Send an email to Jane Appleseed", "tool_call": {"function_name": "send_email", "arguments": {"to_address": "Jane Appleseed"}}}, …]
				- [{"prompt": "What meetings do I have today?", "tool_call": {"function_name": "lookup_meetings", "arguments": {"when": "today"}}}, …]

				They MUST be short and simple (less than 8 words).

				----
				Applet description:
				<#name#>
				<#summary#>
				<#description#>
				----
				Functions:
				<#tools#>''', client=client)

			elif applet.mcp:

				observation = AI.ask(
					prompt={'name': applet.name, 'summary': applet.summary, 'description': applet.description}, template='''
				Given the Applet description and functions below, respond with a JSON array containing example questions a user
				may task AI with through this Applet. Here are some examples:
				- [{"prompt": "Look up rdar://1234567"}, …]
				- [{"prompt": "Find an available meeting room for tomorrow"}, …]
				- [{"prompt": "Send an email to Jane Appleseed"}, …]
				- [{"prompt": "What meetings do I have today?"}, …]

				They MUST be short and simple (less than 8 words).

				----
				Applet description:
				<#name#>
				<#summary#>
				<#description#>''', client=client)

			# make sure we have a list
			if isinstance(observation.response_as_dictionary, list):

				examples: list[dict] = observation.response_as_dictionary

				# e.g. `What's` › `What is`. Needed since the interface uses single quotes
				for example_index, example in enumerate(examples):

					prompt: str = example.pop('prompt')
					examples[example_index] = {'prompt': prompt.replace('\'s', ' is').replace('\'m', ' am').replace('\n', ''), **example}

				applet.examples = examples
				flag_modified(applet, 'examples')

		applet.save()
		return applet

	@classmethod
	def create_from_path(cls, path: dict[str, Any], dsid: int, **kwargs) -> 'Applet':
		"""
		[Internal]
		Helper function.
		Creates (or updates), saves, and returns an `Applet` given a directory path

		@param path(dict): A dictionary containing the `applet.json` file
		"""

		external_id: str = kwargs.pop('external_id', path)

		# get the definition of the applet
		definition: dict[str, Any] = Tool.get_dictionary_from_string(string=open(f'{path}/applet.json', 'r').read())

		# if the description is a file path, read the file
		if (description_file_path := definition.get('description')) and len(description_file_path) < 40 and  \
		   '.' in description_file_path and os.path.exists(f'{path}/{description_file_path}'):

			with open(f'{path}/{description_file_path}', 'r') as file:
				definition['description'] = file.read()

		# if no description, but we have a `README.md`, get the contents of the file
		elif 'description' not in definition and os.path.exists(f'{path}/README.md'):

			with open(f'{path}/README.md', 'r') as file:
				definition['description'] = file.read()

		# check to see if the Applet already exists and matches the DSID
		applet: Applet = Applet.get_or_none(bundle_id=definition['bundle_id'])

		if applet and applet.created_by != dsid and not Config.current.is_development:

			user: User = User(dsid=dsid)

			if not user.is_admin:
				raise Exception('You must be the creator of the Applet to publish updates')

		applet: Applet = cls.create_from_definition(definition=definition, external_id=external_id, **kwargs)

		# set/update who made this applet
		if not applet.created_by:

			# if the user is part of Interlinked, remove the `created_by` field
			if not Config.current.is_development and 9438527 not in AppleDirectoryClient.shared.get_group_dsids_for_person_dsid(dsid=dsid):
				applet.created_by = dsid

			else:
				applet.created_by = None

		# unset the external ID since this is an uploaded Applet
		applet.external_id = None

		# recompress just the applet, then upload
		# this allows us to skip any `__MACOSX` directories
		skipped_file_names: list[str] = []

		# skip compressing icon and banner
		for key in {'icon', 'banner'}:

			if key not in definition:
				continue

			skipped_file_names.append(definition[key])

		applet.upload_asset(type='package', data=Utilities.compress(path=path, skipped_file_names=skipped_file_names))
		applet.save()
		return applet

	@classmethod
	def create_from_repository_url(cls, url: dict[str, Any], dsid: int, **kwargs) -> 'Applet':
		"""
		[Internal]
		Helper function.
		Creates (or updates), saves, and returns an `Applet` given a repository URL

		@param url(str): A repository URL (and specific directory path (e.g. `github.pie.apple.com/interlinked/apps:seer`))
		"""

		import tempfile
		from interlinked.core.clients.githubclient import GitHubClient, Blob

		directory_path: str = None

		if ':' in url:
			url, directory_path = url.rsplit(':', 1)

		# get the repository owner name and name
		branch_name: str = 'main'
		owner_name, name = GitHubClient.parse_repository_url(url=url)
		repository: Repository = GitHubClient.shared.get_repository(owner_name=owner_name, name=name)

		# do not allow creating from a private repository
		if repository.is_private and not Config.current.is_development:

			# make a temporary exception for some repositories
			if repository.name == 'interlinked-next' and repository.owner_name == 'interlinked':
				branch_name = 'main-develop'

			else:
				raise Exception('The repository must be public')

		# get the blobs and filter them by directory, so we don't fetch all files
		blobs: list[Blob] = repository.get_blobs(recursive=True, branch_name=branch_name)

		if directory_path:
			blobs = [blob for blob in blobs if blob.path.startswith(directory_path)]

		applet_path: str = tempfile.mkdtemp()

		# make sure the size of the repository is not over 8mb
		if sum(blob.size for blob in blobs) > (1024 * 1024) * 8:
			raise Exception('The repository is bigger than 8mb.')

		for blob in blobs:

			output_file_path: str = os.path.join(applet_path, blob.path)
			output_directory_path: str = os.path.dirname(output_file_path)

			# this is a bit complex, but for example, if there's a repo "apps"
			# the repo has multiple apps. If the `directory_path` passed from the UI is
			# `seer`, we will only extract files in `seer` and we will extract them to the root
			# directory (apps) rather than nested in apps/seer/…
			if directory_path:

				if not output_directory_path.endswith(directory_path):
					continue

				output_file_path = output_file_path.replace(output_directory_path, output_directory_path.removesuffix(directory_path))
				output_directory_path = os.path.dirname(output_file_path)

			if not os.path.exists(output_directory_path):
				os.makedirs(output_directory_path)

			with open(output_file_path, 'w' if isinstance(blob.content, str) else 'wb') as file:
				file.write(blob.content)

		# get the definition of the applet
		applet: Applet = Applet.create_from_path(path=applet_path, dsid=dsid, upload_assets=True)
		applet.external_id = url if not directory_path else f'{url}:{directory_path}'
		applet.save()
		return applet

	def upload_asset(self, type: str, data: bytes, dsid: int = None) -> str:
		"""
		Uploads an asset (e.g. icon)
		"""

		import uuid
		from interlinked.core.clients.objectstorageclient import ObjectStorageClient

		# upload the asset
		# TODO: resize asset if needed
		external_id: str = f'{"development_" if Config.current.is_development else ""}{str(uuid.uuid4())}'
		ObjectStorageClient.shared.upload(key=external_id, data=data)

		if type == 'icon':

			self.icon_external_id = external_id

			# get the average color
			self.icon_average_color = '#%02x%02x%02x' % Utilities.get_average_color(data=data)

		elif type == 'banner':

			self.banner_external_id = external_id

			# get the average color
			self.banner_average_color = '#%02x%02x%02x' % Utilities.get_average_color(data=data)

		elif type == 'screenshot':

			if self.screenshot_external_ids is None:
				self.screenshot_external_ids = []

			self.screenshot_external_ids.append(external_id)
			flag_modified(self, 'screenshot_external_ids')

		elif type == 'package':

			asset: Asset = Asset.create(created_by=dsid, external_id=external_id, type='package', applet_id=self.id)
			logger.info(f'created package asset ({asset.external_id=}, applet.id={self.id})')

			# clear cache
			from redis import Redis

			redis: Redis = Redis.from_url(Config.current.REDIS_URL)
			redis.delete(f'applet_package:{self.bundle_id}')

		else:
			raise HTTPException(status_code=400, detail='Unknown asset type')

		return external_id

	@classmethod
	def get_files_for_external_id(cls, external_id: str, include_backend: bool = True,
								  included_file_paths: str = None, is_mcp: bool = False) -> list[dict]:
		"""
		[Internal]
		Returns a list of files (dicts) for a given path/URL
		The list only includes supported formats (`.py` and `.tsx`)

		e.g. `[{'path': '….py', 'type': 'backend', 'tools': […], …}, {'path': '….tsx', 'type': 'ui'}]`

		@param external_id(str): the path/URL that contains supported files
		@param include_backend(bool): Whether to include backend files (e.g. Python)
		"""

		# local file path
		if external_id.startswith(('/', '~', '.')):
			return BaseApp.get_files_for_path(path=external_id, include_backend=include_backend,
											  included_file_paths=included_file_paths, is_mcp=is_mcp)

		elif 'github.' in external_id:

			# get the repository owner name and name
			owner_name, name = GitHubClient.parse_repository_url(url=path)
			repository: Repository = GitHubClient.shared.get_repository(owner_name=owner_name, name=name)

			return return_dict

		raise NotImplementedError(f'Unsupported path/URL: {external_id}')

	""" Access """

	def get_has_access(self, dsid: int) -> bool:
		"""
		Checks if a user has access to this Applet
		"""

		if not self.read_group_dsid:
			return True

		return len(AppleDirectoryClient.shared.get_matching_group_dsids(group_dsids=[self.read_group_dsid], person_dsid=dsid)) > 0

	""" Utilities """

	@classmethod
	def _get_applet_definition(cls, directory_path: str) -> dict:
		"""
		Returns the applet definition by reading the `applet.json`,
		encoding images, and compiling UI
		"""

		applet_definition: dict[str, Any] = None

		try:
			applet_definition = json.loads(open(f'{directory_path}/applet.json', 'r').read())

		except FileNotFoundError:
			raise UserError('Please create an `applet.json` file in your Applet’s directory')

		# assets: icon and banner
		for key in {'icon', 'banner'}:

			if key not in applet_definition:
				continue

			try:

				with open(f'{directory_path}/{applet_definition[key]}', 'rb') as file:
					applet_definition[f'{key}_base64'] = base64.b64encode(file.read()).decode('utf-8')

				del applet_definition[key]

			except FileNotFoundError:
				raise UserError(f'The {key} file is missing from your Applet’s directory')

		# assets: screenshots
		if screenshots := applet_definition.get('screenshots'):

			screenshots_base64: list[dict] = []

			for screenshot in screenshots:

				with open(f'{directory_path}/{screenshot}', 'rb') as file:
					screenshots_base64.append(base64.b64encode(file.read()).decode('utf-8'))

			applet_definition['screenshots_base64'] = screenshots_base64
			del applet_definition['screenshots']

		# code
		included_file_paths: list[str] = applet_definition.get('files')
		files: list[dict] = Applet.get_files_for_external_id(external_id=directory_path, included_file_paths=included_file_paths)

		if not files:

			logger.error('The Applet has no code files, or none of the paths in `files` exists')
			quit()

		for file in files:

			# compile each ui file
			if file['type'] == 'ui':

				with open(file['path'], 'r') as _file:
					file['code'] = Applet.get_compiled_code(code=_file.read())

			elif file['type'] == 'backend':

				for tool in file['tools']:

					if error := tool.get('error'):
						logger.warning(f'⚠️  {error}')

		applet_definition['files_full'] = files

		return applet_definition

	@classmethod
	def _get_mtime(cls, directory_path: str) -> dict[str, int]:
		"""
		Return a dict of modification time for all files in directory
		"""

		mtime_dict: dict[str, int] = {}

		for filename in os.listdir(directory_path):

			filepath = os.path.join(directory_path, filename)

			if os.path.isfile(filepath):
				mtime_dict[filepath] = os.path.getmtime(filepath)

		return mtime_dict

	""" Validators """

	@field_validator('bundle_id')
	def check_bundle_id(cls, value: str) -> str:

		value = value.replace('-', '_').replace(' ', '_').lower()
		return value


class AppVersion(BaseSQLModel, table=True):
	"""
	Same as `Applet`, but used to track versions and their files
	"""
	id: Optional[int] = SQLField(default=None, primary_key=True)

	# the applet version
	version: Optional[float] = None

	external_id: Optional[str] = None

	# description of what changed in this version
	changelog: Optional[str] = None

	# the ID of the applet (version) for this version
	applet_id: int = SQLField(default=None, foreign_key='applet.id')


class AppletSubscriber(BaseSQLModel, table=True):
	"""
	Notify user when new Applet is published
	"""

	__tablename__ = 'applet_subscribers'

	id: Optional[int] = SQLField(default=None, primary_key=True)
	enabled: Optional[bool] = SQLField(default=False)

	created_at: Optional[datetime] = SQLField(default_factory=datetime.now)
	modified_at: Optional[datetime] = None

	created_by: Optional[int] = Field(default=None, sa_column=Column(BigInteger()))
	modified_by: Optional[int] = Field(default=None, sa_column=Column(BigInteger()))

	@property
	def applet_subscribers(self) -> list[int]:
		return AppletSubscriber.select().where(AppletSubscriber.enabled == True).all()

	@classmethod
	def notify_subscribers(self, applet: 'Applet') -> None:
		"""
		Notifies all AppletSubscribers when a new applet is published
		"""

		import base64
		from pathlib import Path

		from interlinked.core.clients.mailclient import MailClient
		from interlinked.core.clients.objectstorageclient import ObjectStorageClient

		BASE_PATH: str = Path(__file__).resolve().parent
		STATIC_PATH: str = Path(f'{BASE_PATH}/static')

		emails: list[str] = []

		# development-only
		if Config.current.is_development:
			emails = ['interlinked-admin@group.apple.com']

		else:

			subscribers: list[AppletSubscriber] = AppletSubscriber.select().where(AppletSubscriber.enabled == True).all()

			for applet_subscriber in subscribers:

				person: Person = AppleDirectoryClient.shared.get_person_for_dsid(dsid=applet_subscriber.created_by)

				if person and person.email:
					emails.append(person.email)

			emails = set(emails)

		try:

			data = ObjectStorageClient.shared.download(key=applet.icon_external_id, stream=False)
			image_base64 = base64.b64encode(data).decode('utf-8')

		except Exception as e:

			logger.warning(f'Failed to fetch applet image: {e}')
			image_base64 = ''

		person: Person = AppleDirectoryClient.shared.get_person_for_dsid(dsid=applet.created_by)

		template: str = open(f'{STATIC_PATH}/applet_notification.html', 'r').read()

		template = template.replace('<#icon_color#>', applet.icon_average_color or '#333333')
		template = template.replace('<#applet_image#>', image_base64)
		template = template.replace('<#applet_name#>', applet.name or '')
		template = template.replace('<#applet_author#>', person.name if person else '')
		template = template.replace('<#applet_description#>', applet.summary.replace("\n", '<br/>'))
		template = template.replace('<#applet_url#>', f'https://interlinked.apple.com/applets?bundle_id={applet.bundle_id}')

		for email in emails:

			subject = f'New Applet Published: {applet.name or ""}'

			logger.info(f'sending email… ({email=})')

			MailClient.send(to_addresses=[email], from_address='noreply@apple.com', from_name='Interlinked',
							subject=subject, body=template)

class Asset(BaseSQLModel, table=True):
	"""
	Used for apps
	"""

	id: Optional[int] = SQLField(default=None, primary_key=True)

	# when this asset was created/modified
	created_at: Optional[datetime] = SQLField(default_factory=datetime.now)
	modified_at: Optional[datetime] = None

	# the DSID of the person that created/modified this asset
	created_by: Optional[int] = Field(default=None, sa_column=Column(BigInteger()))
	modified_by: Optional[int] = Field(default=None, sa_column=Column(BigInteger()))

	# the URL/path to/ID of the asset
	external_id: Optional[str] = None
	version: Optional[float] = 0.0

	# any of
	# - icon
	# - banner
	# - screenshot
	# - package (zip file)
	# - system (zip file)
	type: str = 'package'

	applet_id: Optional[int] = SQLField(default=None, foreign_key='applet.id')

	@classmethod
	def create_from_data(cls, data: bytes, type: str, dsid: str = None, external_id: str = None) -> 'Asset':
		"""
		[Internal]
		Uploads and creates an Asset
		"""

		import uuid
		from interlinked.core.clients.objectstorageclient import ObjectStorageClient

		# upload the asset
		external_id: str = external_id if external_id else f'{"development_" if Config.current.is_development else ""}{str(uuid.uuid4())}'
		ObjectStorageClient.shared.upload(key=external_id, data=data)

		return Asset.create(external_id=external_id, type=type, created_by=dsid)


class AppletComment(BaseSQLModel, table=True):

	id: Optional[int] = SQLField(default=None, primary_key=True)

	# when this comment was created/modified
	created_at: Optional[datetime] = SQLField(default_factory=datetime.now)
	modified_at: Optional[datetime] = None

	# the DSID of the person that created/modified this configuration
	created_by: Optional[int] = None
	modified_by: Optional[int] = None

	content: str

	applet_id: int = SQLField(default=None, foreign_key='applet.id')
	applet: Optional[Applet] = Relationship(back_populates='_comments')

	@property
	def created_by_person(self) -> Person:

		if not self.created_by:
			return None

		return AppleDirectoryClient.shared.get_person_for_dsid(dsid=self.created_by)


""" Setup """

class Setup(BaseSQLModel, table=True):

	id: Optional[int] = SQLField(default=None, primary_key=True)

	# when this member was created/modified
	created_at: Optional[datetime] = SQLField(default_factory=datetime.now)
	modified_at: Optional[datetime] = None

	# the DSID of the person that created/modified this Setup
	created_by: Optional[int] = Field(default=None, sa_column=Column(BigInteger()))
	modified_by: Optional[int] = Field(default=None, sa_column=Column(BigInteger()))

	name: Optional[str] = None
	system_message: Optional[str] = None

	def apply(self, values: dict[str, Any], session: 'Session', dsid: int = None) -> int:
		"""
		Applies and saves changes to this Setup
		"""

		if not self.created_by:
			self.created_by = dsid

		else:

			# update modified_* fields
			self.modified_at = datetime.now(timezone.utc)
			self.modified_by = dsid

		for key, value in values.items():

			# don't allow changing some fields
			if key.endswith(('_at', '_by')) or key in {'id', 'name'}:
				continue

			# skip internal keys
			if '__' in key or key.startswith('_'):
				continue

			elif key == 'system_message' and value != self.system_message:

				from interlinked.core.clients.googleaiclient import GoogleAIClient

				# create/update the name
				observation = AI.ask(prompt={'text': value}, template='''
				Your task is to review the prompt for another AI below and based on the prompt, provide a name
				to name this AI. For example "Code Expert".

				Let's respond with the following format:
				Name<!type:string,required:true!>: Maximum of two words
				---

				Prompt:
				<#text#>''', client=GoogleAIClient())

				self.name = observation.name

			if not hasattr(self, key):

				logger.info(f'skipping unknown key: {key}')
				continue

			setattr(self, key, value)

		session.add(self)
		session.commit()
		session.refresh(self)

		return self.id


""" Research """

class ResearchApplication(BaseSQLModel, table=True):

	id: Optional[int] = SQLField(default=None, primary_key=True)

	# when this comment was created/modified
	created_at: Optional[datetime] = SQLField(default_factory=datetime.now)
	modified_at: Optional[datetime] = None

	# the DSID of the person that created/modified this configuration
	created_by: Optional[int] = None
	modified_by: Optional[int] = None

	questionnaire: Optional[dict] = SQLField(default=None, sa_column=Column(JSONB))

	@property
	def created_by_person(self) -> Person:

		if not self.created_by:
			return None

		return AppleDirectoryClient.shared.get_person_for_dsid(dsid=self.created_by)