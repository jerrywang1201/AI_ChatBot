"""
MCP Server for Interlinked Applets
"""

import os
import sys
import json
import logging
import asyncio
import argparse
from typing import Any
from datetime import datetime
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from contextlib import asynccontextmanager

# Imports for stdio mode
try:

	from mcp import types
	from mcp.server.stdio import stdio_server
	from mcp.server import NotificationOptions, Server
	from mcp.server.models import InitializationOptions
	MCP_AVAILABLE = True

except ImportError:
	MCP_AVAILABLE = False

# Imports for SSE mode
try:

	import uvicorn
	import asyncio
	from asyncio import Queue
	from pydantic import BaseModel, Field
	from fastapi.responses import StreamingResponse
	from fastapi.middleware.cors import CORSMiddleware
	from fastapi import FastAPI, HTTPException, Request
	FASTAPI_AVAILABLE = True

except ImportError:
	FASTAPI_AVAILABLE = False


@dataclass
class ServerConfig:
	"""Configuration for the MCP server"""

	bundle_id: str
	api_key: str | None = None
	base_url: str | None = None
	function_kwargs: dict[str, Any] = field(default_factory=dict)

	port: int = 3000
	host: str = '0.0.0.0'
	log_level: str = 'INFO'
	transport_mode: str | None = None
	interlinked_path: str | None = None

	@classmethod
	def from_env(cls) -> 'ServerConfig':
		"""
		Create configuration from environment variables

		@return(ServerConfig): configured server instance
		"""

		bundle_id = os.getenv('BUNDLE_ID')

		if not bundle_id:
			raise ValueError('BUNDLE_ID environment variable is required')

		function_kwargs = {}
		kwargs_str = os.getenv('FUNCTION_KWARGS', '{}')

		if kwargs_str:

			try:
				function_kwargs = json.loads(kwargs_str)

			except json.JSONDecodeError as parse_error:
				logging.warning(f'Failed to parse FUNCTION_KWARGS: {parse_error}')

		standard_env_vars = {
			'BUNDLE_ID', 'API_KEY', 'BASE_URL', 'FUNCTION_KWARGS',
			'INTERLINKED_PATH', 'MCP_TRANSPORT', 'HOST', 'PORT', 'LOG_LEVEL',
			'PATH', 'HOME', 'USER', 'PWD', 'SHELL', 'TERM', 'LANG', 'LC_ALL'
		}

		for key, value in os.environ.items():
			if key not in standard_env_vars and not key.startswith(('_', 'PYTHON')):
				function_kwargs[key.lower()] = value

		return cls(bundle_id=bundle_id, api_key=os.getenv('API_KEY'), base_url=os.getenv('BASE_URL'),
					function_kwargs=function_kwargs, interlinked_path=os.getenv('INTERLINKED_PATH'),
					transport_mode=os.getenv('MCP_TRANSPORT'), host=os.getenv('HOST', '0.0.0.0'),
					port=int(os.getenv('PORT', '3000')), log_level=os.getenv('LOG_LEVEL', 'INFO'))

	def validate(self) -> None:
		"""
		Validate configuration
		"""

		if not self.bundle_id:
			raise ValueError('bundle_id is required')

		if self.transport_mode and self.transport_mode not in ['stdio', 'sse']:
			raise ValueError(f'Invalid transport mode: {self.transport_mode}')

		if self.port < 1 or self.port > 65535:
			raise ValueError(f'Invalid port: {self.port}')


class MCPRequest(BaseModel):
	"""MCP request model for communication"""

	jsonrpc: str = Field(default='2.0')

	id: str | None = None
	method: str
	params: dict[str, Any] | None = None


class MCPResponse(BaseModel):
	"""MCP response model for communication"""

	jsonrpc: str = Field(default='2.0')

	id: str | None = None
	result: Any | None = None
	error: dict[str, Any] | None = None


class MCPError(Exception):
	"""Custom exception for MCP-related errors"""

	def __init__(self, error_code: int, message: str, data: Any | None = None):
		"""
		Initialize MCP error

		@param error_code(int): MCP protocol error code
		@param message(str): error message
		@param data(Any): optional error data
		"""

		self.code = error_code
		self.message = message
		self.data = data

		super().__init__(message)


class ToolManager:
	"""Manages tool loading and execution"""

	def __init__(self, config: ServerConfig, logger: logging.Logger):
		"""
		Initialize tool manager

		@param config(ServerConfig): server configuration
		@param logger(logging.Logger): logger instance
		"""

		self.config = config
		self.logger = logger
		self.applet = None
		self.tools: list[Any] = []
		self._tools_loaded = False

	async def load_tools(self) -> None:
		"""
		Load tools from the Interlinked Applet
		"""

		if self._tools_loaded:
			return

		try:

			self.logger.info(f'Loading applet: {self.config.bundle_id}')

			if self.config.interlinked_path:
				sys.path.insert(0, self.config.interlinked_path)

			from interlinked import Applet

			self.applet = Applet.get(
				bundle_id=self.config.bundle_id,
				api_key=self.config.api_key,
				base_url=self.config.base_url
			)

			if hasattr(self.applet, 'mcp') and self.applet.mcp:
				raise MCPError(-32603, f'Applet is already configured for MCP mode, try {self.applet.mcp}')

			self.logger.debug(f'Getting tools for applet: {self.applet.name}')
			self.tools = self.applet.get_tools(
				function_kwargs=self.config.function_kwargs
			)

			self.logger.debug(f'Loaded {len(self.tools)} tools from {self.applet.name}')
			self._tools_loaded = True

		except Exception as load_error:
			self.logger.error(f'Failed to load applet tools: {load_error}')
			raise MCPError(-32603, f'Failed to load applet tools: {str(load_error)}')

	def find_tool(self, tool_name: str) -> Any | None:
		"""
		Find a tool by name

		@param tool_name(str): name of the tool to find
		@return(Any): tool instance or None if not found
		"""

		for tool in self.tools:

			current_tool_name = getattr(tool, 'alternative_name', None) or tool.name

			if current_tool_name == tool_name:
				return tool

		return None

	def execute_tool(self, tool_name: str, arguments: dict[str, Any]) -> Any:
		"""
		Execute a tool with given arguments

		@param tool_name(str): name of the tool to execute
		@param arguments(dict): tool arguments
		@return(Any): tool execution result
		"""

		tool = self.find_tool(tool_name)

		if not tool:
			raise MCPError(-32601, f'Tool \'{tool_name}\' not found')

		try:
			return tool.run(arguments)

		except Exception as execution_error:
			self.logger.error(f'Error executing tool \'{tool_name}\': {execution_error}')
			raise MCPError(-32603, f'Error executing tool: {str(execution_error)}')

	def convert_tool_to_mcp(self, tool: Any) -> dict[str, Any]:
		"""
		Convert an Interlinked Tool to MCP Tool format

		@param tool(Any): interlinked tool instance
		@return(dict): MCP tool dictionary
		"""

		tool_name = getattr(tool, 'alternative_name', None) or tool.name

		properties = {}
		required = []

		if hasattr(tool, 'function') and hasattr(tool.function, 'signature'):

			for argument in tool.function.signature.arguments:

				argument_name = argument['name']
				argument_type = argument.get('type', 'str')
				optional = argument.get('optional', False)

				if hasattr(tool, 'function_kwargs') and tool.function_kwargs and argument_name in tool.function_kwargs:
					continue

				description = None
				if hasattr(tool.function.signature, 'get_description_for_argument'):
					description = tool.function.signature.get_description_for_argument(argument_name)

				json_type = self._python_type_to_json_type(argument_type)

				properties[argument_name] = {
					'type': json_type,
					'description': description or f'The {argument_name} parameter'
				}

				if not optional:
					required.append(argument_name)

		return {
			'name': tool_name,
			'description': getattr(tool, 'description', None) or f'Execute {tool_name} function',
			'inputSchema': {
				'type': 'object',
				'properties': properties,
				'required': required
			}
		}

	@staticmethod
	def _python_type_to_json_type(python_type: str) -> str:
		"""
		Convert Python type string to JSON Schema type

		@param python_type(str): python type string
		@return(str): JSON schema type
		"""

		type_mapping = {
			'int': 'integer',
			'float': 'number',
			'bool': 'boolean',
			'dict': 'object',
			'str': 'string'
		}

		if python_type.startswith('list'):
			return 'array'

		return type_mapping.get(python_type, 'string')


class BaseTransport(ABC):
	"""Base class for transport implementations"""

	def __init__(self, config: ServerConfig, tool_manager: ToolManager, logger: logging.Logger):
		"""
		Initialize base transport

		@param config(ServerConfig): server configuration
		@param tool_manager(ToolManager): tool manager instance
		@param logger(logging.Logger): logger instance
		"""

		self.config = config
		self.tool_manager = tool_manager
		self.logger = logger
		self.server_info = {
			'name': f'interlinked-{config.bundle_id.split(".")[-1]}',
			'version': '1.0.0'
		}

	@abstractmethod
	async def start(self) -> None:
		"""
		Start the transport server
		"""

		pass

	def format_tool_result(self, result: Any) -> str:
		"""
		Format tool execution result as string

		@param result(Any): tool execution result
		@return(str): formatted result string
		"""

		if isinstance(result, (dict, list)):
			return json.dumps(result, indent=2, default=str, ensure_ascii=False)

		return str(result)


class StdioTransport(BaseTransport):
	"""Stdio transport implementation"""

	def __init__(self, config: ServerConfig, tool_manager: ToolManager, logger: logging.Logger):
		"""
		Initialize stdio transport

		@param config(ServerConfig): server configuration
		@param tool_manager(ToolManager): tool manager instance
		@param logger(logging.Logger): logger instance
		"""

		super().__init__(config, tool_manager, logger)

		if not MCP_AVAILABLE:
			raise ImportError('MCP library is required for stdio mode. Install with: pip install mcp')

		server_name = f'interlinked-{config.bundle_id.split(".")[-1]}'
		self.server = Server(server_name)
		self._setup_handlers()

	def _setup_handlers(self) -> None:
		"""
		Setup MCP server handlers
		"""

		@self.server.list_tools()
		async def handle_list_tools() -> list[types.Tool]:
			"""
			List available tools from the Interlinked Applet

			@return(list): list of MCP tools
			"""

			await self.tool_manager.load_tools()

			mcp_tools = []

			for tool in self.tool_manager.tools:

				tool_dict = self.tool_manager.convert_tool_to_mcp(tool)
				mcp_tools.append(types.Tool(
					name=tool_dict['name'],
					description=tool_dict['description'],
					inputSchema=tool_dict['inputSchema']
				))

			return mcp_tools

		@self.server.call_tool()
		async def handle_call_tool(tool_name: str, arguments: dict[str, Any]) -> list[types.TextContent]:
			"""
			Execute a tool function

			@param tool_name(str): name of the tool to execute
			@param arguments(dict): tool arguments
			@return(list): list of text content responses
			"""

			try:

				await self.tool_manager.load_tools()
				result = self.tool_manager.execute_tool(tool_name, arguments)
				result_text = self.format_tool_result(result)

				return [types.TextContent(
					type='text',
					text=result_text
				)]

			except MCPError as mcp_error:

				return [types.TextContent(
					type='text',
					text=f'Error: {mcp_error.message}'
				)]

			except Exception as unexpected_error:

				self.logger.error(f'Unexpected error executing tool \'{tool_name}\': {unexpected_error}')
				return [types.TextContent(
					type='text',
					text=f'Unexpected error executing tool: {str(unexpected_error)}'
				)]


	async def start(self) -> None:
		"""
		Start the stdio MCP server
		"""

		self.logger.info('Starting stdio MCP server')

		async with stdio_server() as (read_stream, write_stream):

			await self.server.run(
				read_stream,
				write_stream,
				InitializationOptions(
					server_name=self.server_info['name'],
					server_version=self.server_info['version'],
					capabilities=self.server.get_capabilities(
						notification_options=NotificationOptions(),
						experimental_capabilities={}
					)
				)
			)


class SSETransport(BaseTransport):
	"""Server-Sent Events transport implementation"""

	def __init__(self, config: ServerConfig, tool_manager: ToolManager, logger: logging.Logger):
		"""
		Initialize SSE transport

		@param config(ServerConfig): server configuration
		@param tool_manager(ToolManager): tool manager instance
		@param logger(logging.Logger): logger instance
		"""

		super().__init__(config, tool_manager, logger)

		if not FASTAPI_AVAILABLE:
			raise ImportError('FastAPI is required for SSE mode. Install with: pip install fastapi uvicorn')

		if not MCP_AVAILABLE:
			raise ImportError('MCP library is required for SSE mode. Install with: pip install mcp')

		self.app = FastAPI(
			title=f'MCP SSE Server - {config.bundle_id}',
			description='Model Context Protocol server over Server-Sent Events',
			version='1.0.0'
		)

		self.app.add_middleware(
			CORSMiddleware,
			allow_origins=['*'],
			allow_credentials=True,
			allow_methods=['*'],
			allow_headers=['*'],
		)

		self._setup_routes()

	def _setup_routes(self) -> None:
		"""
		Setup FastAPI routes
		"""

		@self.app.get('/')
		async def root():
			"""
			Root endpoint with server information

			@return(dict): server information
			"""

			return {
				'server': self.server_info['name'],
				'version': self.server_info['version'],
				'protocol': 'MCP over SSE',
				'bundle_id': self.config.bundle_id,
				'transport': 'sse',
				'endpoints': {
					'sse': '/sse',
					'mcp': '/mcp',
					'health': '/health'
				}
			}

		@self.app.get('/health')
		async def health_check():
			"""
			Health check endpoint

			@return(dict): health status information
			"""

			return {
				'status': 'healthy',
				'server': 'interlinked-mcp-server',
				'timestamp': datetime.now().isoformat(),
				'tools_loaded': self.tool_manager._tools_loaded,
				'tool_count': len(self.tool_manager.tools)
			}

		@self.app.get('/sse')
		async def sse_endpoint():
			"""
			SSE endpoint for MCP communication

			@return(StreamingResponse): server-sent events response
			"""

			return StreamingResponse(
				self._sse_stream(),
				media_type='text/event-stream',
				headers={
					'Cache-Control': 'no-cache',
					'Connection': 'keep-alive',
					'Access-Control-Allow-Origin': '*',
					'Access-Control-Allow-Headers': 'Cache-Control'
				}
			)

		@self.app.post('/sse')
		async def sse_message_endpoint(request: Request):
			"""
			Handle MCP messages via POST to SSE endpoint (client-to-server)

			@param request(Request): HTTP request with MCP message
			@return(dict): MCP response
			"""

			try:

				# Parse the request body as JSON
				message_data = await request.json()

				# Handle the MCP message using stdio transport
				response = await self._handle_sse_message(message_data)

				return response

			except Exception as request_error:
				self.logger.error(f'Error handling SSE message: {request_error}')
				raise HTTPException(status_code=500, detail=str(request_error))

		@self.app.post('/mcp')
		async def mcp_request_handler(request: MCPRequest):
			"""
			Handle MCP requests via POST

			@param request(MCPRequest): MCP request
			@return(dict): MCP response
			"""

			try:
				response = await self._handle_mcp_request(request)
				return response.dict(exclude_none=True)

			except Exception as request_error:
				self.logger.error(f'Error handling MCP request: {request_error}')
				raise HTTPException(status_code=500, detail=str(request_error))

	async def _sse_stream(self):
		"""
		Generator for SSE stream - provides MCP transport capabilities
		"""

		try:

			# Send initial connection acknowledgment
			init_event = {
				'jsonrpc': '2.0',
				'method': 'initialized',
				'params': {}
			}
			yield f'data: {json.dumps(init_event)}\n\n'

			# Keep connection alive with periodic pings
			while True:

				await asyncio.sleep(30)
				ping_event = {
					'jsonrpc': '2.0',
					'method': 'ping',
					'params': {'timestamp': datetime.utcnow().isoformat()}
				}
				yield f'data: {json.dumps(ping_event)}\n\n'

		except asyncio.CancelledError:
			pass

		except Exception as stream_error:

			self.logger.error(f'SSE stream error: {stream_error}')
			error_event = {
				'jsonrpc': '2.0',
				'method': 'error',
				'params': {'message': str(stream_error)}
			}
			yield f'data: {json.dumps(error_event)}\n\n'

	async def _handle_sse_message(self, message_data: dict) -> dict:
		"""
		Handle MCP message received via SSE POST

		@param message_data(dict): MCP message data
		@return(dict): MCP response
		"""

		try:

			# Convert to MCPRequest and handle using existing logic
			mcp_request = MCPRequest(**message_data)
			response = await self._handle_mcp_request(mcp_request)
			return response.dict(exclude_none=True)

		except Exception as sse_error:

			self.logger.error(f'Error handling SSE message: {sse_error}')
			return {
				'jsonrpc': '2.0',
				'id': message_data.get('id'),
				'error': {
					'code': -32603,
					'message': f'Internal error: {str(sse_error)}'
				}
			}

	async def _handle_mcp_request(self, request: MCPRequest) -> MCPResponse:
		"""
		Handle MCP protocol requests

		@param request(MCPRequest): MCP request
		@return(MCPResponse): MCP response
		"""

		try:

			if request.method == 'initialize':

				result = {
					'protocolVersion': '2024-11-05',
					'capabilities': {
						'tools': {}
					},
					'serverInfo': self.server_info
				}
				return MCPResponse(id=request.id, result=result)

			elif request.method == 'tools/list':

				await self.tool_manager.load_tools()

				mcp_tools = []

				for tool in self.tool_manager.tools:

					tool_dict = self.tool_manager.convert_tool_to_mcp(tool)
					mcp_tools.append(tool_dict)

				result = {'tools': mcp_tools}
				return MCPResponse(id=request.id, result=result)

			elif request.method == 'tools/call':

				await self.tool_manager.load_tools()

				if not request.params:
					raise MCPError(-32602, 'Invalid params: params required for tools/call')

				tool_name = request.params.get('name')
				arguments = request.params.get('arguments', {})

				if not tool_name:
					raise MCPError(-32602, 'Invalid params: name is required')

				result = self.tool_manager.execute_tool(tool_name, arguments)
				result_text = self.format_tool_result(result)

				response_result = {
					'content': [
						{
							'type': 'text',
							'text': result_text
						}
					]
				}
				return MCPResponse(id=request.id, result=response_result)

			else:
				raise MCPError(-32601, f'Method \'{request.method}\' not found')

		except MCPError as mcp_error:

			return MCPResponse(
				id=request.id,
				error={
					'code': mcp_error.code,
					'message': mcp_error.message,
					'data': mcp_error.data
				}
			)

		except Exception as unexpected_error:

			self.logger.error(f'Unexpected error handling MCP request: {unexpected_error}')
			return MCPResponse(
				id=request.id,
				error={
					'code': -32603,
					'message': f'Internal error: {str(unexpected_error)}'
				}
			)


	async def start(self) -> None:
		"""
		Start the SSE MCP server
		"""

		config = uvicorn.Config(
			self.app,
			host=self.config.host,
			port=self.config.port,
			log_level=self.config.log_level.lower()
		)
		server = uvicorn.Server(config)
		await server.serve()


class TransportFactory:
	"""Factory for creating transport instances"""

	@staticmethod
	def create_transport(config: ServerConfig, tool_manager: ToolManager, logger: logging.Logger) -> BaseTransport:
		"""
		Create appropriate transport based on configuration

		@param config(ServerConfig): server configuration
		@param tool_manager(ToolManager): tool manager instance
		@param logger(logging.Logger): logger instance
		@return(BaseTransport): transport instance
		"""

		transport_mode = TransportFactory._determine_transport_mode(config)

		if transport_mode == 'stdio':
			return StdioTransport(config, tool_manager, logger)

		elif transport_mode == 'sse':
			return SSETransport(config, tool_manager, logger)

		else:
			raise ValueError(f'Unsupported transport mode: {transport_mode}')

	@staticmethod
	def _determine_transport_mode(config: ServerConfig) -> str:
		"""
		Determine which transport mode to use

		@param config(ServerConfig): server configuration
		@return(str): transport mode
		"""

		if config.transport_mode:
			return config.transport_mode.lower()

		if '--sse' in sys.argv:
			return 'sse'

		if '--stdio' in sys.argv:
			return 'stdio'

		if not sys.stdin.isatty():

			if MCP_AVAILABLE:
				return 'stdio'

			else:
				logging.warning('MCP library not available, falling back to SSE mode')
				return 'sse'

		return 'stdio'


class InterlinkedAppletServer:
	"""Main server class that orchestrates the MCP server"""

	def __init__(self, config: ServerConfig | None = None):
		"""
		Initialize the server

		@param config(ServerConfig): server configuration
		"""

		self.config = config or ServerConfig.from_env()
		self.config.validate()

		self.logger = self._setup_logging()

		self.tool_manager = ToolManager(self.config, self.logger)
		self.transport = TransportFactory.create_transport(self.config, self.tool_manager, self.logger)

	def _setup_logging(self) -> logging.Logger:
		"""
		Setup structured logging

		@return(logging.Logger): configured logger
		"""

		logger = logging.getLogger(__name__)
		logger.handlers.clear()

		formatter = logging.Formatter(
			'%(asctime)s - %(name)s - %(levelname)s - %(message)s'
		)

		handler = logging.StreamHandler()
		handler.setFormatter(formatter)
		logger.addHandler(handler)

		level = getattr(logging, self.config.log_level.upper(), logging.INFO)
		logger.setLevel(level)

		logger.propagate = False

		return logger

	async def start(self) -> None:
		"""
		Start the MCP server
		"""

		try:
			await self.transport.start()

		except KeyboardInterrupt:
			self.logger.info('Server shutdown requested')

		except Exception as server_error:
			self.logger.error(f'Server error: {server_error}')
			raise

		finally:
			self.logger.info('Server stopped')

	@asynccontextmanager
	async def run_context(self):
		"""
		Context manager for running the server
		"""

		try:
			yield self

		finally:
			pass


def parse_args() -> argparse.Namespace:
	"""
	Parse command line arguments

	@return(argparse.Namespace): parsed arguments
	"""

	parser = argparse.ArgumentParser(
		description='MCP Server with Multiple Transport Support',
		formatter_class=argparse.RawDescriptionHelpFormatter,
		epilog=__doc__
	)

	parser.add_argument(
		'--sse',
		action='store_true',
		help='Force SSE transport mode (HTTP-based)'
	)

	parser.add_argument(
		'--stdio',
		action='store_true',
		help='Force stdio transport mode (pipe-based)'
	)

	parser.add_argument(
		'--transport',
		choices=['stdio', 'sse'],
		help='Explicitly set transport mode'
	)

	parser.add_argument(
		'--log-level',
		choices=['DEBUG', 'INFO', 'WARNING', 'ERROR'],
		help='Set logging level'
	)

	return parser.parse_args()


async def main() -> None:
	"""
	Main entry point
	"""

	try:

		args = parse_args()
		config = ServerConfig.from_env()

		if args.transport:
			config.transport_mode = args.transport

		elif args.sse:
			config.transport_mode = 'sse'

		elif args.stdio:
			config.transport_mode = 'stdio'

		if args.log_level:
			config.log_level = args.log_level

		async with InterlinkedAppletServer(config).run_context() as server:
			await server.start()

	except KeyboardInterrupt:
		pass

	except Exception as startup_error:
		logging.error(f'Server startup error: {startup_error}')
		sys.exit(1)


if __name__ == '__main__':
	asyncio.run(main())