import logging
from redis import Redis
from sqlalchemy import or_
from functools import wraps
from typing import Any, Callable
from sqlmodel import select, Session
from celery.schedules import crontab
from celery import Celery, group, chain
from datetime import datetime, timedelta, timezone

from interlinked.core.config import Config
from interlinked.core.ai import AI, Knowledge, Section, Steps
from interlinked.core.clients.slackclient import SlackClient
from interlinked.ui.models import Configuration, Thread, Post, PostKnowledge,  \
								  Event, EventAttendee, APIKeyUsage, Applet, Asset, KnowledgeSource

logger = logging.getLogger(__name__)

celery: Celery = Celery(__name__)
celery.conf.broker_url = Config.current.REDIS_URL
celery.conf.result_backend = Config.current.REDIS_URL
celery.conf.broker_connection_retry_on_startup = True
is_main: bool = __name__ == '__main__'


""" Events """

@celery.on_after_configure.connect
def start(sender: Celery, **kwargs):

	sender.add_periodic_task(3600, learn_from_posts, name='Learn from Posts')
	sender.add_periodic_task(4000, delete_knowledge, name='Delete Knowledge')
	sender.add_periodic_task(3600, send_event_reminder, name='Send event reminder')
	sender.add_periodic_task(600, add_onboarding_groups, name='Add onboarding groups')
	sender.add_periodic_task(4000, update_applet_packages, name='Update Applet Packages')
	sender.add_periodic_task(crontab(minute=2), store_api_key_usage, name='Store API Key Usage')
	# sender.add_periodic_task(7200, post_trending_community, name='Post trending Community posts')


""" Decorators """

def run_once():
	"""
	Ensures that a given task only runs once at a time (using the first ID argument)
	"""

	def decorator(function: Callable):

		@wraps(function)
		def wrapper(*args, **kwargs):

			if is_main:
				return function(*args, **kwargs)

			have_lock: bool = False
			lock_id: str = f'once_task_{function.__name__}_{args[0]}' if len(args) > 0 else f'once_task_{function.__name__}'

			lock: Any = celery.backend.client.lock(lock_id, timeout=14400)

			try:

				have_lock = lock.acquire(blocking=False)

				if have_lock:
					return function(*args, **kwargs)

			finally:

				if have_lock:
					lock.release()

		return wrapper

	return decorator


""" Tasks: Community """

@celery.task(name='learn_from_posts')
@run_once()
def learn_from_posts():
	"""
	Learns from Community posts
	"""

	now: datetime = datetime.now()
	posts: list[Post] = Post.select().  \
		where(Post.created_at >= now - timedelta(seconds=72000)).all()

	for post in posts:

		section: Section = Section(title=post.title, content=[post.description])
		AI.learn(from_=section, knowledge_source_id=post.id, knowledge_class=PostKnowledge)


@celery.task(name='post_trending_community')
@run_once()
def post_trending_community():
	"""
	Sends a Slack message with trending posts
	"""

	now: datetime = datetime.now()
	# if now.

	posts: list[Post] = Post.select().  \
		where(Post.created_at >= now - timedelta(seconds=604800)).all()

	if not posts:
		return

	user_name: str = 'Community'
	channel_name: str = 'test-interlinked'
	new_this_week: list[str] = []

	def _get_emoji_for_post(post: Post) -> str:
		"""
		Returns an emoji for a given post
		"""

		title_description: str = f'{post.title} {post.description}'.lower()

		# the checks below can be fully replaced by an enum field in `AI.ask(â€¦)`
		# added to reduce the amount of API requests
		if 'radar' in title_description:
			return ':radar8:'

		elif 'code' in title_description:
			return ':xcode:'

		elif 'database' in title_description:
			return ':postgres:'

		elif 'cli' in title_description:
			return ':terminal-1:'

		elif 'calendar' in title_description:
			return ':calendar11:'

		elif 'meeting' in title_description:
			return ':webex:'

		elif 'sysdiagnose' in title_description or 'logs' in title_description:
			return ':console:'

		elif 'slack' in title_description:
			return ':slack:'

		elif 'directory' in title_description:
			return ':directory:'

		# ask AI to pick an emoji
		prompt: str = 'Given the idea description below, identify the best emoji to describe the idea.'  \
					  '\n\nYou must respond with the exact format:'  \
					  '\nSummary<!type:string!>: a summary of the idea'  \
					  '\nEmoji<!type:string,required:true,max_length:2!>: the emoji to use. only one emoji. Avoid emojis with people'  \
					  '\n\n---'  \
					  f'\n{post.title}'  \
					  f'\n{post.description}'

		return (AI.ask(prompt=prompt).emoji or 'âž¡ï¸')[0]

	for post in sorted(posts, key=lambda post: post.title):

		emoji: str = _get_emoji_for_post(post=post)
		new_this_week.append(f'> *{emoji} {post.title}* (by <@{post.created_by_person.slack_member_id}>)'
							 f'\n> *<https://interlinked.apple.com/community/{post.id}|View idea â€º >*')


	thread_ts: str = SlackClient.shared.send_message(channel=channel_name, text=':star: Check out the latest ideas in Community this week! :thread:',
													 username=user_name, icon_emoji='interlinked')['ts']

	SlackClient.shared.send_message(channel=channel_name, text='\n\n'.join(new_this_week),
									thread_ts=thread_ts, username=user_name, icon_emoji='interlinked')

	SlackClient.shared.send_message(channel=channel_name, text='Got an idea, use-case, prototype, or project?'
															   ' <https://interlinked.apple.com/community|Share yours> now.'
															   ' Inspire many across Apple, and collaborate! :heart:',
									thread_ts=thread_ts, username=user_name, icon_emoji='interlinked')

""" Tasks: Knowledge """

@celery.task(name='delete_knowledge')
@run_once()
def delete_knowledge():
	"""
	Deletes Knowledge uploaded in Playground over a day ago
	"""

	now: datetime = datetime.now()
	knowledge_sources: list[KnowledgeSource] = KnowledgeSource.select().where(KnowledgeSource.created_at < now - timedelta(days=1)).all()
	Knowledge.delete_all(knowledge_source_ids=[knowledge_source.id for knowledge_source in knowledge_sources])


""" Tasks: Events """

@celery.task(name='send_event_reminder')
@run_once()
def send_event_reminder():
	"""
	Sends event reminder to attendees
	"""

	import pathlib
	from interlinked.core.clients.mailclient import MailClient
	from interlinked.core.clients.appledirectoryclient import AppleDirectoryClient, Person

	BASE_PATH: str = pathlib.Path(__file__).resolve().parent
	STATIC_PATH: str = pathlib.Path(f'{BASE_PATH}/static')

	now: datetime = datetime.now()
	time_2_hours_later = now + timedelta(hours=2)

	# fetch events that start in exactly 2 hours
	events: list[Event] = Event.select().where((Event.start_at >= now) & (Event.start_at <= time_2_hours_later) & (Event.end_at > now)).all()

	if not events:
		return

	for event in events:

		event_attendees: list[EventAttendee] = EventAttendee.select().where(EventAttendee.event_id == event.id,
																			EventAttendee.notified != True).all()

		logger.info(f'sending {len(event_attendees)} invites for {event.display_title} ({event.id})')

		for event_attendee in event_attendees:

			event_attendee.notified = True
			event_attendee.save()

			person: Person = AppleDirectoryClient.shared.get_person_for_dsid(dsid=event_attendee.created_by)

			if person and person.email:

				template: str = open(f'{STATIC_PATH}/event_reminder.html', 'r').read()
				template = template.replace('<#event_id#>', event.id)
				template = template.replace('<#event_title#>', event.display_title)
				template = template.replace('<#message#>', f'We look forward to seeing you today at {event.display_title}! ðŸ¤—')

				MailClient.send(to_addresses=[person.email], from_address='noreply@apple.com',
								subject=f'Interlinked {event.display_title}. See you soon!', body=template)


@celery.task(name='store_api_key_usage')
@run_once()
def store_api_key_usage():
	"""
	Stores cached API Key usage
	"""

	redis: Redis = Redis.from_url(Config.current.REDIS_URL)

	pipeline = redis.pipeline()

	for key in redis.scan_iter('akue:*'):

		count: int = int(redis.get(key) or 0)

		# Parse the key to extract information
		pieces = key.decode('utf-8').split(':')

		api_key_id: int = int(pieces[1])
		type: str = pieces[2]
		client_name: str = pieces[3]

		# if the `client_name` is `*`, adjust the offsets
		# e.g. `akue:6:token_count:*:2024-10-28T05` instead of `akue:6:token_count:googleaiclient:gemini-2.5-flash:2024-10-28T05`
		# `client_model_name` would be `None`
		client_model_name: str = pieces[4] if client_name != '*' else None
		datetime_raw: str = pieces[5 if client_name != '*' else 4]

		created_at: datetime = datetime.strptime(datetime_raw, '%Y-%m-%dT%H').replace(tzinfo=timezone.utc)

		# check if we should handle this usage
		# only if it's in the past (the `minutes=2` is just an added buffer)
		if datetime.now(timezone.utc) <= created_at + timedelta(hours=1, minutes=2):
			continue

		api_key_usage, _ = APIKeyUsage.get_or_create(api_key_id=api_key_id, type=type, client_name=client_name,
													 client_model_name=client_model_name, created_at=created_at)

		api_key_usage.count = count
		api_key_usage.save()

		# delete the key from Redis
		redis.delete(key)


""" Tasks: Apps """

@celery.task(name='update_applet_packages')
@run_once()
def update_applet_packages():
	"""
	Updates Applet assets (for Apps from GitHub)
	"""

	now: datetime = datetime.now()
	hour_ago = now - timedelta(hours=1)

	subtasks: list[Callable] = []
	applets: list[Applet] = Applet.select().join(Asset).where(Applet.external_id.contains('github.'), Asset.created_at > hour_ago).all()

	for applet in applets:
		subtasks.append(update_applet_package.si(applet.id))

	chain(group(subtasks)).apply_async()


@celery.task(name='update_applet_package')
@run_once()
def update_applet_package(id: int):
	"""
	Updates an Applet
	"""

	from interlinked.core.clients.mailclient import MailClient
	from interlinked.core.clients.appledirectoryclient import AppleDirectoryClient, Person

	applet: Applet = Applet.get_or_none(id=id)

	logger.info(f'updating Appletâ€¦ ({applet.bundle_id=})')

	try:
		Applet.create_from_repository_url(url=applet.external_id, dsid=applet.created_by)

	except Exception as exception:

		logger.error(f'Could not update applet from repository ({applet.bundle_id=})', exc_info=True)

		person: Person = AppleDirectoryClient.shared.get_person_for_dsid(dsid=applet.created_by)
		MailClient.send(to_addresses=[person.email] if person else None, from_address='noreply@apple.com', bcc_addresses=['interlinked-admin@group.apple.com'],
						subject=f'Error in {applet.name}', body=f'An error occured in the latest changes in {applet.external_id}.\n\n{exception}')


@celery.task(name='add_onboarding_groups')
@run_once()
def add_onboarding_groups():
	"""
	Adds groups to the onboarding group
	"""

	from interlinked.ui.schemas import Questionnaire
	from interlinked.core.clients.mailclient import MailClient
	from interlinked.core.clients.appledirectoryclient import AppleDirectoryClient

	logger.info('adding groupsâ€¦')

	try:
		for group_dict in Questionnaire.get_access_groups():
			AppleDirectoryClient.shared.add_to_group(dsid=group_dict.get('access_dsid'), group_dsid=Questionnaire.BETA_GROUP_DSID, type=2)

	except Exception as exception:

		logger.error(f'Could not add group to onboarding', exc_info=True)

		if not Config.current.is_development:
			MailClient.send(to_addresses=['interlinked-admin@group.apple.com'], from_address='noreply@apple.com',
							subject=f'Could not add onboarding group', body=str(exception))


if __name__ == '__main__':
	# pass

	# learn_from_posts()
	# update_applet_packages()
	update_applet_package(id=6)
	# store_api_key_usage()
	# send_event_reminder()
	# post_trending_community()