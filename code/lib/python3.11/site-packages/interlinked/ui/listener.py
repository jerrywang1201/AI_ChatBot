import logging
from typing import Any
from sqlalchemy import or_, and_

from interlinked.core.ai import Knowledge
from interlinked.core.config import Config
from interlinked.ui.models import Configuration
from interlinked.core.singleton import SingletonMeta
from interlinked.core.clients.slackclient import SlackClient
from interlinked.core.clients.appledirectoryclient import Person, AppleDirectoryClient

logger = logging.getLogger(__name__)


class Listener(metaclass=SingletonMeta):
	"""
	Listens to Slack, Email, etc events
	"""

	def __init__(self):

		if Config.current.SLACK_BOT_TOKEN:

			logger.info('listening to Slack messages…')
			SlackClient.shared.listen_for(event_names={'message', 'app_mention', 'reaction_added'},
										  callback=self.handle_slack_event)

	@SingletonMeta.Shared
	def shared(cls) -> 'Listener':
		return cls(shared=True)

	""" Slack """

	def handle_slack_event(self, event: dict[str, Any]) -> None:
		"""
		Handles Slack events (messages, reactions, etc)
		"""

		event_type: str = event.get('type')

		if event_type == 'message':

			user: str = event.get('user')
			text: str = event.get('text')
			channel_id: str = event.get('channel')
			channel_type: str = event.get('channel_type')
			person: Person = Person(_slack_member_id=user)
			parent_user_id: str = event.get('parent_user_id')
			subtype: str = event.get('subtype', 'message_sent')
			thread_ts: str = event.get('thread_ts', event.get('ts'))

			# TODO: add support for `message_changed` and update the message if it's Knowledge Configuration
			if subtype not in {'message_sent', 'message_replied'}:
				return

			if channel_type == 'im':

				user_profile: dict[str, Any] = event.get('user_profile')
				person_name: str = user_profile.get('real_name')

				SlackClient.shared.send_message(channel=channel_id, text='Sorry, I am not configured yet to reply to Slack DMs', thread_ts=thread_ts)

			elif channel_type in {'channel', 'group'}:

				# find all configurations for this channel
				# knowledge configurations can be not enabled (when first added to a channel), so we want
				# to make sure we get them
				configurations: list[Configuration] = Configuration.select().  \
					where(or_(and_(Configuration.workflow_name == 'agent', Configuration.enabled == True),
							  Configuration.workflow_name == 'knowledge')).all()

				agent_configurations: list[Configuration] = [configuration for configuration in configurations if channel_id in configuration.data.get('slack_channels', [])]
				knowledge_configurations: list[Configuration] = [configuration for configuration in configurations if channel_id in configuration.data.get('external_id', '')]

				if not agent_configurations and not knowledge_configurations:

					logger.info(f'ignoring message from an unknown channel ({channel_id})…')
					return

				if agent_configurations:

					logger.info('agent will handle the message…')

					try:
						agent_configurations[0].workflow_class.handle_slack_message(text=text, channel_id=channel_id, thread_ts=thread_ts,
																					sender=person, configuration=agent_configurations[0])

					except Exception as exception:
						logger.error('agent failed to handle message', exc_info=True)

				# convert the message to knowledge
				if knowledge_configurations:

					knowledge_configuration: Configuration = knowledge_configurations[0]

					if Config.current.is_development:
						logger.info(f'passing slack message to knowledge configuration… (id={knowledge_configuration.id}, {text=!r})')

					else:
						logger.info(f'passing slack message to knowledge configuration… (id={knowledge_configuration.id})')

					knowledge_configurations[0].workflow_class.handle_slack_message(text=text, channel_id=channel_id, thread_ts=thread_ts,
																					is_reply=parent_user_id is not None, sender=person,
																					configuration=knowledge_configurations[0])

			else:
				raise Exception(f'unhandled channel_type ({channel_type=}, {event=})')

		else:
			logger.error(f'unhandled event ({event=})')


if __name__ == '__main__':

	from interlinked.ui.models import BaseSQLModel
	BaseSQLModel.create_all_models()

	Listener.shared

	# keep running in the background
	while True: pass